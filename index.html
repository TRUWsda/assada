<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TRUWPi - Rule the Economy</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        /* Custom styles for background and font */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a1a2e; /* Dark purple/blue background */
            color: #e0e0e0; /* Light grey text */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            overflow: hidden; /* Hide overflow for background elements */
            position: relative;
        }

        /* Custom button styles */
        .btn-primary {
            background: linear-gradient(135deg, #8a2be2, #4b0082); /* Purple gradient */
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }
        .btn-primary:disabled {
            background: #4a4a5a; /* Darker grey for disabled */
            cursor: not-allowed;
            box-shadow: none;
        }
        .btn-secondary {
            background-color: #33334d; /* Darker grey */
            transition: all 0.3s ease;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        .btn-secondary:hover {
            background-color: #444466;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }
        .input-field {
            background-color: #33334d;
            border: 1px solid #555577;
            color: #e0e0e0;
            padding: 0.75rem 1rem;
            border-radius: 0.5rem;
            outline: none;
            transition: border-color 0.3s ease;
        }
        .input-field:focus {
            border-color: #8a2be2;
        }

        /* Main container styling for Lobby Page */
        .main-container {
            width: 100%;
            height: 100vh;
            display: flex;
            flex-direction: column;
            background-color: #1a1a2e; /* Match body background */
        }

        /* Header styling for Lobby Page */
        .lobby-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 2rem;
            background-color: #22223b; /* Darker header background */
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            border-bottom-left-radius: 0.5rem;
            border-bottom-right-radius: 0.5rem;
        }

        .lobby-header .left-section {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .lobby-header .right-section {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        /* Game modes navigation for Lobby Page */
        .game-modes-nav {
            display: flex;
            justify-content: center;
            gap: 1.5rem;
            padding: 1rem 0;
            background-color: #2a2a47; /* Slightly lighter background for nav */
            box-shadow: inset 0 -2px 5px rgba(0, 0, 0, 0.1);
            overflow-x: auto; /* Allow horizontal scrolling on small screens */
            -webkit-overflow-scrolling: touch; /* Smooth scrolling on iOS */
            white-space: nowrap; /* Prevent wrapping */
            padding-left: 2rem;
            padding-right: 2rem;
        }

        .game-modes-nav a {
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            color: #b0b0b0;
            font-weight: 500;
            transition: all 0.2s ease;
            white-space: nowrap; /* Keep text on one line */
        }

        .game-modes-nav a:hover {
            background-color: #3e3e60;
            color: #e0e0e0;
        }

        .game-modes-nav a.active {
            background-color: #8a2be2;
            color: white;
            font-weight: bold;
        }

        /* Main content area for Lobby Page */
        .content-area {
            flex-grow: 1;
            display: flex;
            flex-direction: column; /* Stack items vertically */
            align-items: center; /* Center items horizontally */
            justify-content: center; /* Center items vertically if space allows */
            padding: 2rem;
            gap: 2rem;
            overflow-y: auto;
            position: relative; /* For absolute positioning of sidebar */
        }

        /* Party section for Lobby Page */
        .party-section {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            align-items: center; /* Center children horizontally within party-section */
            justify-content: center; /* Center children vertically if space allows */
            height: 100%; /* Take full height of content-area */
            width: 100%; /* Take full width of content-area */
            max-width: 900px; /* Increased max width for better card layout */
            margin: 0 auto; /* Center party-section itself within content-area */
        }

        .party-controls {
            display: flex;
            align-items: center;
            gap: 1rem;
            background-color: #22223b;
            padding: 1rem 1.5rem;
            border-radius: 0.75rem;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            justify-content: center; /* Center content horizontally within party-controls */
            width: fit-content; /* Shrink to fit content */
            margin-left: auto; /* Auto margins for horizontal centering */
            margin-right: auto; /* Auto margins for horizontal centering */
            max-width: 90%; /* Prevent it from becoming too wide on smaller screens */
        }

        .party-code-input {
            background-color: #33334d;
            border: 1px solid #555577;
            color: #e0e0e0;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            outline: none;
            text-align: center;
        }

        .player-cards-container {
            display: flex;
            flex-wrap: wrap; /* Allow wrapping */
            justify-content: center; /* Center cards horizontally */
            gap: 1.5rem;
            width: 100%; /* Ensure it takes full width to allow centering of cards */
        }

        .player-card {
            background-color: #22223b;
            border-radius: 0.75rem;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            padding: 1rem; /* Reduced padding */
            text-align: center;
            width: 160px; /* Smaller width for cards */
            min-height: 200px; /* Smaller consistent height */
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            border: 2px solid transparent; /* Default border */
            transition: border-color 0.3s ease;
            position: relative; /* For crown positioning */
        }

        .player-card.active-player {
            border-color: #8a2be2; /* Highlight active player */
        }

        .player-card .player-icon {
            font-size: 3rem; /* Smaller icon size */
            margin-bottom: 0.5rem; /* Reduced margin */
            color: #e0e0e0; /* Default icon color */
        }

        .player-card h4 {
            font-size: 1.125rem; /* Equivalent to text-lg in Tailwind, smaller than text-xl */
            font-weight: bold;
            color: white;
        }

        .player-card .status-badge {
            background-color: #6ee7b7; /* Green for READY */
            color: #1a1a2e;
            padding: 0.25rem 0.75rem;
            border-radius: 9999px; /* Pill shape */
            font-size: 0.75rem;
            font-weight: bold;
            margin-top: 0.5rem;
        }
        .player-card .status-badge.not-ready {
            background-color: #fca5a5; /* Red for not ready */
        }

        /* Leader crown icon */
        .leader-crown {
            position: absolute;
            top: 5px;
            right: 5px;
            color: gold;
            font-size: 1.5rem;
            text-shadow: 0 0 5px rgba(0,0,0,0.5);
        }

        /* Kick button styling */
        .kick-button {
            background-color: #dc2626; /* Red color */
            color: white;
            padding: 0.3rem 0.6rem;
            border-radius: 0.375rem;
            font-size: 0.8rem;
            margin-top: 0.5rem;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        .kick-button:hover {
            background-color: #b91c1c;
        }
        .kick-button:disabled {
            background-color: #4a4a5a;
            cursor: not-allowed;
        }


        #lobbyPlayButton {
            background: linear-gradient(135deg, #8a2be2, #4b0082); /* Purple gradient */
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            color: white;
            font-size: 1.5rem; /* Reduced font size */
            padding: 0.75rem 3rem; /* Reduced padding */
            border-radius: 0.75rem;
            font-weight: bold;
            letter-spacing: 0.1em; /* Spacing between letters */
            margin-top: 1.5rem; /* Reduced margin top */
            cursor: pointer;
            border: none;
            outline: none;
            display: flex;
            align-items: center;
            justify-content: center;
            text-transform: uppercase;
        }

        #lobbyPlayButton:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }
        #lobbyPlayButton:disabled {
            background: #4a4a5a; /* Darker grey for disabled */
            cursor: not-allowed;
            box-shadow: none;
        }

        /* Online players sidebar for Lobby Page */
        .online-players-sidebar {
            position: absolute; /* Take out of normal flow */
            top: 2rem; /* Adjust as needed */
            right: 2rem; /* Adjust as needed */
            width: 300px; /* Fixed width */
            background-color: #22223b;
            border-radius: 0.75rem;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            padding: 1.5rem;
            overflow-y: auto;
            transition: visibility 0s, opacity 0.3s ease;
            opacity: 1;
            z-index: 20; /* Ensure it's on top */
        }
        .online-players-sidebar.hidden-content {
            visibility: hidden;
            opacity: 0;
        }

        .online-players-sidebar h3 {
            font-size: 1.25rem;
            font-weight: bold;
            margin-bottom: 1rem;
            border-bottom: 1px solid #444466;
            padding-bottom: 0.5rem;
            display: flex; /* Added flex for toggle button alignment */
            justify-content: space-between; /* Space between title and button */
            align-items: center;
        }

        .online-players-sidebar ul li {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 0;
            border-bottom: 1px dashed #33334d;
            font-size: 0.9rem;
        }
        .online-players-sidebar ul li:last-child {
            border-bottom: none;
        }

        .online-players-sidebar .player-status {
            color: #b0b0b0;
            font-size: 0.8rem;
        }

        /* Footer styling for Lobby Page */
        .lobby-footer {
            background-color: #22223b;
            padding: 1rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-top-left-radius: 0.5rem;
            border-top-right-radius: 0.5rem;
            box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.2);
            margin-top: auto; /* Push to bottom */
        }

        /* Game board specific styles */
        .game-board-grid {
            display: grid;
            grid-template-columns: repeat(11, 1fr); /* 11 columns */
            grid-template-rows: repeat(11, 1fr); /* 11 rows */
            width: 850px; /* Fixed size for the board */
            height: 850px; /* Fixed size for the board */
            background-color: #33334d; /* Board background */
            overflow: hidden;
            border: 2px solid #555577;
            margin: auto; /* Center the board */
        }

        .board-cell {
            background-color: #444466; /* Changed back to original color */
            border: 1px solid #555577; /* Changed back to original color */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 0.75rem; /* Kept original size */
            text-align: center;
            padding: 0.25rem; /* Kept original padding */
            position: relative;
            min-width: 0;
            min-height: 0;
            transition: background-color 0.2s ease-in-out;
        }

        /* Hover effect for board cells: change background color */
        .board-cell:hover {
            background-color: #555580; /* Slightly lighter shade on hover */
        }

        /* Player token styling */
        .player-token {
            position: absolute;
            width: 25px;
            height: 25px;
            border-radius: 50%;
            border: 2px solid #fff;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.7rem;
            font-weight: bold;
            color: white;
            z-index: 10;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            transition: all 0.5s ease-in-out;
        }

        /* Different colors for players (you can add more) */
        .player-color-1 { background-color: #FF0000; } /* Red */
        .player-color-2 { background-color: #0000FF; } /* Blue */
        .player-color-3 { background-color: #00FF00; } /* Green */
        .player-color-4 { background-color: #FFFF00; } /* Yellow */
        .player-color-5 { background-color: #FF4500; } /* OrangeRed */

        /* Player token movement animation */
        .player-token.moving {
            transform: scale(1.2);
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.7);
        }

        /* Current player highlight */
        .player-card.current-player-highlight {
            border-color: #6ee7b7;
            box-shadow: 0 0 20px rgba(110, 231, 183, 0.5);
        }
        .player-token.current-player-highlight {
            border-color: #6ee7b7;
            box-shadow: 0 0 10px rgba(110, 231, 183, 0.8);
        }

        /* Corner cells */
        .corner-cell {
            background-color: #555577;
            font-weight: bold;
            font-size: 1rem;
        }

        /* Explicit grid positioning for each cell type */
        /* Top Row (from right to left in RTL layout) */
        .cell-top-right-corner { grid-column: 11; grid-row: 1; }
        .cell-top-1 { grid-column: 10; grid-row: 1; }
        .cell-top-2 { grid-column: 9; grid-row: 1; }
        .cell-top-3 { grid-column: 8; grid-row: 1; }
        .cell-top-4 { grid-column: 7; grid-row: 1; }
        .cell-top-5 { grid-column: 6; grid-row: 1; } /* Water */
        .cell-top-6 { grid-column: 5; grid-row: 1; }
        .cell-top-7 { grid-column: 4; grid-row: 1; }
        .cell-top-8 { grid-column: 3; grid-row: 1; }
        .cell-top-9 { grid-column: 2; grid-row: 1; }
        .cell-top-left-corner { grid-column: 1; grid-row: 1; }

        /* Left Column (from top to bottom) */
        .cell-left-1 { grid-column: 1; grid-row: 2; }
        .cell-left-2 { grid-column: 1; grid-row: 3; }
        .cell-left-3 { grid-column: 1; grid-row: 4; }
        .cell-left-4 { grid-column: 1; grid-row: 5; }
        .cell-left-5 { grid-column: 1; grid-row: 6; } /* Electricity */
        .cell-left-6 { grid-column: 1; grid-row: 7; }
        .cell-left-7 { grid-column: 1; grid-row: 8; }
        .cell-left-8 { grid-column: 1; grid-row: 9; }
        .cell-left-9 { grid-column: 1; grid-row: 10; }

        /* Bottom Row (from left to right in RTL layout) */
        .cell-bottom-left-corner { grid-column: 1; grid-row: 11; }
        .cell-bottom-1 { grid-column: 2; grid-row: 11; }
        .cell-bottom-2 { grid-column: 3; grid-row: 11; }
        .cell-bottom-3 { grid-column: 4; grid-row: 11; }
        .cell-bottom-4 { grid-column: 5; grid-row: 11; }
        .cell-bottom-5 { grid-column: 6; grid-row: 11; } /* Internet */
        .cell-bottom-6 { grid-column: 7; grid-row: 11; }
        .cell-bottom-7 { grid-column: 8; grid-row: 11; }
        .cell-bottom-8 { grid-column: 9; grid-row: 11; }
        .cell-bottom-9 { grid-column: 10; grid-row: 11; }
        .cell-bottom-right-corner { grid-column: 11; grid-row: 11; }

        /* Right Column (from bottom to top) */
        .cell-right-1 { grid-column: 11; grid-row: 10; }
        .cell-right-2 { grid-column: 11; grid-row: 9; }
        .cell-right-3 { grid-column: 11; grid-row: 8; }
        .cell-right-4 { grid-column: 11; grid-row: 7; }
        .cell-right-5 { grid-column: 11; grid-row: 6; } /* Airport */
        .cell-right-6 { grid-column: 11; grid-row: 5; }
        .cell-right-7 { grid-column: 11; grid-row: 4; }
        .cell-right-8 { grid-column: 11; grid-row: 3; }
        .cell-right-9 { grid-column: 11; grid-row: 2; }

        /* Center area for play button and random number */
        .board-center {
            grid-column: 2 / span 9; /* Spans 9 columns from 2 to 10 */
            grid-row: 2 / span 9;    /* Spans 9 rows from 2 to 10 */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: #22223b; /* Darker center background */
            border-radius: 0.5rem;
            padding: 1rem;
        }

        .chat-window {
            height: 300px;
            background-color: #22223b;
            border-radius: 0.5rem;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .chat-messages {
            flex-grow: 1;
            padding: 1rem;
            overflow-y: auto;
            border-bottom: 1px solid #444466;
            display: flex;
            flex-direction: column; /* Ensure messages stack vertically */
        }

        .chat-input-container {
            display: flex;
            padding: 0.5rem;
            background-color: #33334d;
        }

        .chat-input {
            flex-grow: 1;
            background-color: #444466;
            border: none;
            border-radius: 0.25rem;
            padding: 0.5rem 1rem;
            color: #e0e0e0;
            outline: none;
        }
        .chat-input::placeholder {
            color: #b0b0b0;
        }

        .chat-send-btn {
            background-color: #8a2be2;
            color: white;
            border-radius: 0.25rem;
            padding: 0.5rem 1rem;
            margin-right: 0.5rem;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        .chat-send-btn:hover {
            background-color: #6a1bbd;
        }

        /* Property Details Modal Styles */
        .property-details-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #22223b;
            border-radius: 0.75rem;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
            padding: 1.5rem;
            z-index: 30;
            width: 90%;
            max-width: 450px;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            border: 2px solid #8a2be2;
        }
        .property-details-modal .close-btn {
            position: absolute;
            top: 0.75rem;
            right: 0.75rem;
            background: none;
            border: none;
            font-size: 1.5rem;
            color: #e0e0e0;
            cursor: pointer;
            transition: color 0.2s ease;
        }
        .property-details-modal .close-btn:hover {
            color: #ff0000;
        }
        .property-details-modal .rent-level-item {
            display: flex;
            justify-content: space-between;
            padding: 0.25rem 0;
            border-bottom: 1px dashed #444466;
        }
        .property-details-modal .rent-level-item:last-child {
            border-bottom: none;
        }
        .property-details-modal .rent-level-item.current-rent {
            font-weight: bold;
            color: #6ee7b7;
        }
        .property-details-modal .upgrade-controls button {
            background-color: #8a2be2;
            color: white;
            border-radius: 0.5rem;
            padding: 0.5rem 1rem;
            font-size: 1.25rem;
            transition: background-color 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.25rem;
        }
        .property-details-modal .upgrade-controls button:hover {
            background-color: #6a1bbd;
        }

        /* Money change effect in player list */
        .money-change {
            font-size: 0.8rem;
            font-weight: bold;
            margin-left: 5px;
            opacity: 0;
            transition: opacity 0.7s ease-out, transform 0.7s ease-out;
            position: relative;
            display: inline-block;
            min-width: 30px;
            text-align: right;
        }
        .money-change.plus {
            color: #6ee7b7;
        }
        .money-change.minus {
            color: #fca5a5;
        }
        .money-change.active {
            opacity: 1;
            transform: translateY(-3px);
        }

        .property-color-bar {
            width: 100%;
            height: 5px;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        /* Ensure content is above the color bar but below tokens */
        .board-cell > div:not(.property-color-bar):not(.player-token) {
            position: relative; /* Ensure z-index works */
            z-index: 2;
        }

        /* Responsive adjustments */
        @media (max-width: 1024px) {
            .game-board-grid {
                width: 800px;
                height: 800px;
            }
            .online-players-sidebar {
                position: relative;
                top: unset;
                right: unset;
                width: 100%;
                max-width: 100%;
                margin-top: 2rem;
            }
            .content-area {
                flex-direction: column;
                align-items: center;
                padding: 1rem;
            }
            .party-section {
                max-width: 100%; /* Allow it to take full width on smaller screens */
            }
            .player-cards-container {
                flex-direction: row;
                justify-content: center;
                flex-wrap: wrap;
            }
            .player-card {
                width: 140px; /* Adjusted for smaller screens */
                min-height: 180px; /* Adjusted for smaller screens */
                flex-shrink: 0;
            }
            .lobby-footer {
                flex-direction: column;
                gap: 1rem;
                text-align: center;
            }
            .game-modes-nav {
                justify-content: flex-start;
            }
        }

        @media (max-width: 768px) {
            .game-board-grid {
                width: 95vw;
                height: 95vw;
                max-width: 650px;
                max-height: 650px;
                font-size: 0.6rem;
            }
            .board-cell {
                padding: 0.1rem;
            }
            .corner-cell {
                font-size: 0.8rem;
            }
            .main-game-container {
                flex-direction: column;
            }
            .left-sidebar, .right-sidebar {
                width: 100%;
                margin-top: 1rem;
            }
            .property-details-modal {
                width: 95%;
                padding: 1rem;
            }
        }

        @media (max-width: 640px) {
            .lobby-header {
                padding: 0.75rem 1rem;
            }
            .lobby-header .play-button {
                padding: 0.5rem 1rem;
                font-size: 1rem;
            }
            .game-modes-nav {
                padding-left: 1rem;
                padding-right: 1rem;
            }
            .game-modes-nav a {
                padding: 0.4rem 0.8rem;
                font-size: 0.8rem;
            }
            .content-area {
                padding: 0.75rem;
            }
            .party-controls {
                flex-direction: column;
                gap: 0.75rem;
                width: 100%;
                max-width: 350px;
            }
            .party-code-input {
                width: 100%;
            }
        }

        /* New styles for horizontal pending trades */
        .pending-trades-container {
            display: flex;
            flex-wrap: wrap; /* Allow wrapping onto multiple lines if needed */
            gap: 0.5rem; /* Smaller gap between trade offers */
            overflow-x: auto; /* Enable horizontal scrolling if content overflows */
            -webkit-overflow-scrolling: touch; /* Smooth scrolling on iOS */
            padding-bottom: 0.5rem; /* Add some padding for scrollbar */
        }

        .pending-trade-item {
            background-color: #33334d;
            border-radius: 0.375rem; /* Smaller rounded corners */
            padding: 0.5rem 0.75rem; /* Smaller padding */
            font-size: 0.75rem; /* Smaller font size */
            color: #b0b0b0;
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.1s ease;
            white-space: nowrap; /* Keep text on one line */
            flex-shrink: 0; /* Prevent items from shrinking */
            min-width: 120px; /* Minimum width for each item */
            text-align: center;
        }

        .pending-trade-item:hover {
            background-color: #444466;
            transform: translateY(-1px);
        }

        .pending-trade-item .trade-summary {
            display: block;
            font-weight: bold;
            color: #e0e0e0;
            margin-bottom: 0.25rem;
        }
        .pending-trade-item .trade-details {
            display: block;
            font-size: 0.65rem; /* Even smaller font for details */
            color: #909090;
        }

        /* Username Modal Styles */
        #usernameModal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
        #usernameModalContent {
            background-color: #22223b;
            padding: 2rem;
            border-radius: 0.75rem;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
            width: 90%;
            max-width: 400px;
            text-align: center;
        }
        #usernameError {
            color: #fca5a5;
            font-size: 0.85rem;
            margin-top: 0.5rem;
            min-height: 1.2rem; /* Reserve space to prevent layout shift */
        }
    </style>
</head>
<body dir="ltr">
    <div id="usernameModal" class="hidden">
        <div id="usernameModalContent">
            <h3 class="text-xl font-bold mb-4" id="usernameModalTitle">Choose Your Username</h3>
            <p class="text-gray-300 mb-4" id="usernameModalDescription">This will be your unique name in the game. Only lowercase letters, numbers, and underscores are allowed.</p>
            <input type="text" id="usernameInput" class="input-field w-full mb-2" placeholder="Enter username" maxlength="15">
            <p id="usernameError" class="text-red-400 text-sm mb-4"></p>
            <button id="saveUsernameBtn" class="btn-primary py-2 px-6 rounded-md w-full">Save Username</button>
        </div>
    </div>

    <div id="lobbyPage" class="main-container hidden">
        <header class="lobby-header">
            <div class="left-section">
                <button class="text-gray-300 hover:text-white transition-colors duration-200">
                    <i class="fas fa-arrow-left mr-2"></i> <span id="backButtonText">BACK</span>
                </button>
                <span class="text-xl font-bold text-white" id="lobbyTitle">LOBBY</span>
            </div>
            <div class="right-section">
                <span class="text-gray-300">
                    <i class="fas fa-users mr-1"></i> <span id="lobbyPlayerCount">0/5</span>
                </span>
                <span class="text-green-400 font-bold">
                    <i class="fas fa-coins mr-1"></i> <span id="playerMoneyDisplay">0</span>
                </span>
                <button id="toggleOnlinePlayers" class="text-gray-400 hover:text-white text-sm ml-2">
                    <i class="fas fa-eye"></i>
                </button>
                <button id="settingsBtn" class="text-gray-400 hover:text-white text-sm ml-2">
                    <i class="fas fa-cog"></i>
                </button>
            </div>
        </header>

        <nav class="game-modes-nav">
            <a href="#" class="active" id="unratedMode">UNRATED</a>
            <a href="#" id="competitiveMode">COMPETITIVE</a>
            </nav>

        <div class="content-area">
            <div class="party-section">
                <div class="party-controls">
                    <label class="flex items-center space-x-2 cursor-pointer">
                        <input type="checkbox" class="toggle-checkbox hidden" id="closedPartyToggle">
                        <div class="toggle-switch relative w-10 h-6 bg-gray-600 rounded-full shadow-inner">
                            <div class="toggle-dot absolute w-4 h-4 bg-white rounded-full shadow inset-y-1 left-1 transition-all duration-300 ease-in-out"></div>
                        </div>
                        <span class="text-gray-300" id="closedPartyText">CLOSED PARTY</span>
                    </label>
                    <input type="text" placeholder="PARTY CODE" class="party-code-input" id="partyCodeInput" />
                    <button id="createJoinPartyBtn" class="btn-primary py-1 px-3 rounded-md text-sm">Create/Join</button>
                </div>

                <div class="player-cards-container" id="lobbyPlayerCardsContainer">
                    </div>

                <button id="lobbyPlayButton">
                    PLAY
                </button>
            </div>

            <div class="online-players-sidebar hidden-content" id="onlinePlayersSidebar">
                <h3 id="onlinePlayersTitle">ONLINE <span class="text-green-400">(0)</span>
                </h3>
                <ul id="onlinePlayersList">
                    </ul>
            </div>
        </div>

        <footer class="lobby-footer">
            </footer>
    </div>

    <div id="gamePage" class="hidden flex flex-col items-center justify-center min-h-screen p-4 md:p-8 w-full overflow-auto">
        <header class="w-full flex justify-center items-center mb-6">
            </header>

        <div class="flex flex-col lg:flex-row gap-6 justify-center items-center w-full">
            <div class="left-sidebar w-full lg:w-1/4 flex flex-col gap-4">
                <div class="bg-[#22223b] p-4 rounded-lg shadow-md">
                    <h3 class="text-lg font-bold mb-2" id="shareGameTitle">Share This Game</h3>
                    <input type="text" value="https://game-1-b46e1.web.app/" readonly class="input-field w-full mb-3 text-sm" id="gameShareLink"/>
                    <div class="flex gap-2">
                        <button class="btn-secondary w-full py-2 rounded-md" id="copyButton"><i class="fas fa-copy mr-2"></i> <span id="copyButtonText">Copy</span></button>
                        <button class="btn-secondary w-full py-2 rounded-md" id="roomSettingsButton"><i class="fas fa-cog mr-2"></i> <span id="roomSettingsButtonText">Room Settings</span></button>
                    </div>
                </div>

                <div class="bg-[#22223b] p-4 rounded-lg shadow-md">
                    <h3 class="text-lg font-bold mb-2" id="userIdTitle">User ID</h3>
                    <p id="currentUserIdDisplay" class="text-sm text-gray-400 break-all">Loading...</p>
                </div>

                <div class="chat-window shadow-md">
                    <div class="chat-messages text-sm" id="chatMessages">
                        <p class="text-gray-400" id="chatUnavailableText">Chat is currently unavailable (No Database Connection).</p>
                        </div>
                    <div class="chat-input-container">
                        <input type="text" id="chatInput" placeholder="Say something..." class="chat-input" disabled />
                        <button id="chatSendBtn" class="chat-send-btn" disabled><span id="sendButtonText">Send</span></button>
                    </div>
                </div>
            </div>

            <div class="game-board-container flex-grow flex justify-center items-center relative">
                <div class="game-board-grid relative">
                    </div>
                <div id="buyPropertyModal" class="absolute inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center z-20 hidden">
                    <div class="bg-[#22223b] p-6 rounded-lg shadow-xl text-center w-80">
                        <h3 class="text-xl font-bold mb-4" id="propertyModalTitle"></h3>
                        <p class="text-gray-300 mb-2" id="propertyModalPriceLabel">Price: <span id="propertyModalPrice" class="text-green-400 font-bold"></span></p>
                        <p class="text-gray-300 mb-4" id="playerCurrentMoneyLabel">Current Money: <span id="playerCurrentMoney" class="text-green-400 font-bold"></span></p>
                        <div class="flex justify-center gap-4">
                            <button id="buyPropertyBtn" class="btn-primary py-2 px-6 rounded-md"><span id="buyButtonText">Buy</span></button>
                            <button id="cancelBuyBtn" class="btn-secondary py-2 px-6 rounded-md"><span id="passButtonText">Pass</span></button>
                        </div>
                    </div>
                </div>

                <div id="propertyDetailsModal" class="property-details-modal hidden">
                    <button class="close-btn" onclick="document.getElementById('propertyDetailsModal').classList.add('hidden');">&times;</button>
                    <div class="flex items-center justify-center gap-3 mb-2">
                        <div id="propertyDetailIcon"></div>
                        <h3 class="text-2xl font-bold text-white text-center" id="propertyDetailName"></h3>
                    </div>
                    <p class="text-gray-300 text-center text-lg" id="propertyDetailPriceLabel">Price: <span id="propertyDetailPrice" class="text-green-400 font-bold"></span></p>

                    <div class="bg-[#33334d] p-4 rounded-md">
                        <h4 class="text-md font-bold mb-2 text-white" id="rentLevelsTitle">Rent Levels:</h4>
                        <ul id="propertyRentLevels">
                            </ul>
                    </div>

                    <div id="upgradeSection" class="flex flex-col items-center gap-2">
                        <p class="text-gray-300 text-center text-md" id="currentUpgradeLevelDisplayLabel">Current Level: <span id="currentUpgradeLevelDisplay" class="font-bold"></span></p>
                        <div class="upgrade-controls flex gap-4">
                            <button id="downgradePropertyBtn" class="py-2 px-4 rounded-md">
                                <i class="fas fa-arrow-down"></i> <span id="downgradeRefundText"></span>
                            </button>
                            <button id="upgradePropertyBtn" class="py-2 px-4 rounded-md">
                                <i class="fas fa-arrow-up"></i> <span id="upgradeCostText"></span>
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <div class="right-sidebar w-full lg:w-1/4 flex flex-col gap-4">
                <div class="bg-[#22223b] p-4 rounded-lg shadow-md">
                    <h3 class="text-lg font-bold mb-2" id="playersTitle">Players</h3>
                    <ul id="playersList">
                        </ul>
                </div>

                <div class="bg-[#22223b] p-4 rounded-lg shadow-md">
                    <h3 class="text-lg font-bold mb-2" id="tradesTitle">Trades</h3>
                    <p class="text-sm text-gray-400 mb-3" id="makeTradeText">
                        Make trades with other players to exchange properties, money, bonus cards.
                    </p>
                    <p class="text-sm text-gray-400 mb-3" id="useCreateText">
                        Use the "Create" button to initiate a new trade.
                    </p>
                    <button class="btn-primary w-full py-2 rounded-md" onclick="openTradeCreationModal('${currentUserId}')"><i class="fas fa-plus mr-2"></i> <span id="createButtonText">Create</span></button>
                </div>

                <div class="bg-[#22223b] p-4 rounded-lg shadow-md">
                    <h3 class="text-lg font-bold mb-2" id="pendingTradesTitle">Pending Trades (<span id="pendingTradesCount">0</span>)</h3>
                    <div id="pendingTradesList" class="pending-trades-container">
                        <p class="text-gray-400" id="noPendingTradesText">No pending trades.</p>
                    </div>
                </div>

                <div class="bg-[#22223b] p-4 rounded-lg shadow-md">
                    <h3 class="text-lg font-bold mb-2" id="myPropertiesTitle">My Properties (<span id="myPropertiesCount">0</span>)</h3>
                    <ul id="myPropertiesList" class="text-sm text-gray-400">
                        <li id="noPropertiesText">No properties currently.</li>
                    </ul>
                    <button class="btn-secondary w-full py-2 rounded-md mt-4" onclick="openSellPropertyModal()"><i class="fas fa-hand-holding-usd mr-2"></i> <span id="sellPropertyButtonText">Sell Property</span></button>
                </div>
            </div>
        </div>
    </div>

    <div id="tradeCreationModal" class="fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center z-40 hidden">
        <div class="bg-[#22223b] p-6 rounded-lg shadow-xl text-center w-11/12 max-w-lg relative">
            <h3 class="text-xl font-bold mb-4" id="createTradeOfferTitle">Create Trade Offer</h3>
            <button class="close-btn absolute top-3 right-3 text-gray-400 hover:text-white" onclick="document.getElementById('tradeCreationModal').classList.add('hidden');">&times;</button>
            <input type="hidden" id="tradeOfferIdToModify" value="">

            <div class="mb-4 text-left">
                <label for="tradeRecipient" class="block text-gray-300 text-sm font-bold mb-2" id="tradeWithLabel">Trade with:</label>
                <select id="tradeRecipient" class="input-field w-full"></select>
            </div>

            <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                <div class="bg-[#33334d] p-4 rounded-md text-left">
                    <h4 class="font-bold mb-2" id="youOfferTitle">You Offer:</h4>
                    <label for="offerMoney" class="block text-gray-300 text-xs mb-1" id="offerMoneyLabel">Money:</label>
                    <input type="number" id="offerMoney" class="input-field w-full mb-2" value="0" min="0">
                    <p class="text-gray-300 text-xs mb-1" id="yourPropertiesLabel">Your Properties:</p>
                    <div id="offeredPropertiesList" class="max-h-32 overflow-y-auto border border-gray-600 rounded-md p-2 text-sm">
                        <p class="text-gray-400" id="noPropertiesToOfferText">No properties to offer.</p>
                    </div>
                </div>

                <div class="bg-[#33334d] p-4 rounded-md text-left">
                    <h4 class="font-bold mb-2" id="youRequestTitle">You Request:</h4>
                    <label for="requestMoney" class="block text-gray-300 text-xs mb-1" id="requestMoneyLabel">Money:</label>
                    <input type="number" id="requestMoney" class="input-field w-full mb-2" value="0" min="0">
                    <p class="text-gray-300 text-xs mb-1" id="theirPropertiesLabel">Their Properties:</p>
                    <div id="requestedPropertiesList" class="max-h-32 overflow-y-auto border border-gray-600 rounded-md p-2 text-sm">
                        <p class="text-gray-400" id="noPropertiesToRequestText">No properties to request from this player.</p>
                    </div>
                </div>
            </div>

            <button id="sendTradeOfferBtn" class="btn-primary py-2 px-6 rounded-md w-full"><span id="sendOfferButtonText">Send Offer</span></button>
        </div>
    </div>

    <div id="incomingTradeOfferModal" class="fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center z-40 hidden">
        <div class="bg-[#22223b] p-6 rounded-lg shadow-xl text-center w-11/12 max-w-md relative">
            <h3 class="text-xl font-bold mb-4" id="incomingTradeOfferTitle">Incoming Trade Offer</h3>
            <button class="close-btn absolute top-3 right-3 text-gray-400 hover:text-white" onclick="document.getElementById('incomingTradeOfferModal').classList.add('hidden');">&times;</button>
            <p class="text-gray-300 mb-2" id="offerFromLabel">From: <span id="offerSenderName" class="font-bold"></span></p>

            <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                <div class="bg-[#33334d] p-4 rounded-md text-left">
                    <h4 class="font-bold mb-2" id="theyOfferTitle">They Offer:</h4>
                    <p class="text-gray-300 text-sm mb-1" id="offerReceivedMoneyLabel">Money: $<span id="offerReceivedMoney"></span></p>
                    <p class="text-gray-300 text-sm mb-1" id="offerReceivedPropertiesLabel">Properties:</p>
                    <ul id="offerReceivedProperties" class="list-disc list-inside text-sm text-gray-400"></ul>
                </div>
                <div class="bg-[#33334d] p-4 rounded-md text-left">
                    <h4 class="font-bold mb-2" id="theyRequestTitle">They Request:</h4>
                    <p class="text-gray-300 text-sm mb-1" id="requestSentMoneyLabel">Money: $<span id="requestSentMoney"></span></p>
                    <p class="text-gray-300 text-sm mb-1" id="requestSentPropertiesLabel">Properties:</p>
                    <ul id="requestSentProperties" class="list-disc list-inside text-sm text-gray-400"></ul>
                </div>
            </div>

            <div class="flex justify-center gap-4">
                <button id="acceptTradeBtn" class="btn-primary py-2 px-6 rounded-md"><span id="acceptButtonText">Accept</span></button>
                <button id="declineTradeBtn" class="btn-secondary py-2 px-6 rounded-md"><span id="declineButtonText">Decline</span></button>
                </div>
        </div>
    </div>

    <div id="tradeDetailsViewModal" class="fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center z-40 hidden">
        <div class="bg-[#22223b] p-6 rounded-lg shadow-xl text-center w-11/12 max-w-md relative">
            <h3 class="text-xl font-bold mb-4" id="tradeDetailsViewTitle">Trade Offer Details</h3>
            <button class="close-btn absolute top-3 right-3 text-gray-400 hover:text-white" onclick="document.getElementById('tradeDetailsViewModal').classList.add('hidden');">&times;</button>
            <p class="text-gray-300 mb-2" id="tradeDetailsHeader"><span id="tradeDetailsSenderName" class="font-bold"></span> <span id="tradeDetailsToText"></span> <span id="tradeDetailsRecipientName" class="font-bold"></span></p>

            <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                <div class="bg-[#33334d] p-4 rounded-md text-left">
                    <h4 class="font-bold mb-2" id="offeringTitle">Offering:</h4>
                    <p class="text-gray-300 text-sm mb-1" id="tradeDetailsOfferedMoneyLabel">Money: $<span id="tradeDetailsOfferedMoney"></span></p>
                    <p class="text-gray-300 text-sm mb-1" id="tradeDetailsOfferedPropertiesLabel">Properties:</p>
                    <ul id="tradeDetailsOfferedProperties" class="list-disc list-inside text-sm text-gray-400"></ul>
                </div>
                <div class="bg-[#33334d] p-4 rounded-md text-left">
                    <h4 class="font-bold mb-2" id="requestingTitle">Requesting:</h4>
                    <p class="text-gray-300 text-sm mb-1" id="tradeDetailsRequestedMoneyLabel">Money: $<span id="tradeDetailsRequestedMoney"></span></p>
                    <p class="text-gray-300 text-sm mb-1" id="tradeDetailsRequestedPropertiesLabel">Properties:</p>
                    <ul id="tradeDetailsRequestedProperties" class="list-disc list-inside text-sm text-gray-400"></ul>
                </div>
            </div>

            <div id="tradeDetailsActionButtons" class="flex justify-center gap-4">
                </div>
        </div>
    </div>

    <div id="sellPropertyModal" class="fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center z-40 hidden">
        <div class="bg-[#22223b] p-6 rounded-lg shadow-xl text-center w-11/12 max-w-lg relative">
            <h3 class="text-xl font-bold mb-4" id="sellPropertiesTitle">Sell Properties</h3>
            <button class="close-btn absolute top-3 right-3 text-gray-400 hover:text-white" onclick="document.getElementById('sellPropertyModal').classList.add('hidden');">&times;</button>

            <div id="propertiesToSellList" class="max-h-64 overflow-y-auto border border-gray-600 rounded-md p-2 text-sm mb-4">
                <p class="text-gray-400" id="noPropertiesToSellText">No properties to sell.</p>
            </div>

            <button id="confirmSellPropertiesBtn" class="btn-primary py-2 px-6 rounded-md w-full"><span id="sellSelectedPropertiesButtonText">Sell Selected Properties</span></button>
        </div>
    </div>

    <div id="settingsModal" class="fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center z-50 hidden">
        <div class="bg-[#22223b] p-6 rounded-lg shadow-xl text-center w-11/12 max-w-sm relative">
            <h3 class="text-xl font-bold mb-4" id="settingsModalTitle">Settings</h3>
            <div class="mb-4 text-left">
                <label for="languageSelect" class="block text-gray-300 text-sm font-bold mb-2" id="languageLabel">Language:</label>
                <select id="languageSelect" class="input-field w-full">
                    <option value="en" id="langOptionEn">English</option>
                    <option value="ar" id="langOptionAr">العربية</option>
                </select>
            </div>
            <div class="flex justify-center gap-4">
                <button id="applySettingsBtn" class="btn-primary py-2 px-6 rounded-md"><span id="applyButtonText">Apply</span></button>
                <button id="closeSettingsBtn" class="btn-secondary py-2 px-6 rounded-md"><span id="closeButtonText">Close</span></button>
            </div>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot, collection, query, where, addDoc, getDocs, deleteDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Global Firebase variables
        let app;
        let db;
        let auth;
        let currentUserId = null;
        let currentUsername = null;
        let gameDocRef = null; // Reference to the current game document in Firestore
        let gameUnsubscribe = null; // To unsubscribe from game state changes
        let userProfileUnsubscribe = null; // To unsubscribe from user profile changes

        // Global app ID from environment
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'game-1-b46e1'; // Updated appId
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        // Game State Object
        const gameState = {
            players: [], // Initialized as empty
            currentPlayerIndex: 0,
            boardProperties: {}, // To store ownership of properties
            boardCellsInfo: [], // To store details of each cell including price and owner
            STARTING_MONEY: 5000, // Increased starting money due to initial level 3 properties
            PASS_GO_MONEY: 500, // Money received for passing/landing on Start (changed to 500)
            pendingTradeOffers: [], // Array to store pending trade offers
            currentActiveTradeOffer: null, // Stores the offer currently displayed to the recipient
            leaderId: null, // ID of the current party leader
            currentLanguage: 'en', // Default language
            gameStatus: 'lobby', // 'lobby', 'in-game', 'ended'
            partyCode: null // The code for the current party/game
        };

        const MAX_PLAYERS = 5; // Maximum number of players allowed

        // Timer variables
        let turnTimer = null;
        let timeLeft = 0;
        const TURN_DURATION_SECONDS = 90; // 1.5 minutes

        // Translation dictionary
        const translations = {
            en: {
                back: "BACK",
                lobby: "LOBBY",
                unrated: "UNRATED",
                competitive: "COMPETITIVE",
                closedParty: "CLOSED PARTY",
                partyCode: "PARTY CODE",
                addPlayer: "Add Player",
                play: "PLAY",
                online: "ONLINE",
                money: "Money",
                ready: "Ready",
                userId: "User ID",
                shareGame: "Share This Game",
                copy: "Copy",
                roomSettings: "Room Settings",
                saySomething: "Say something...",
                send: "Send",
                players: "Players",
                trades: "Trades",
                create: "Create",
                pendingTrades: "Pending Trades",
                myProperties: "My Properties",
                sellProperty: "Sell Property",
                noProperties: "No properties currently.",
                noPendingTrades: "No pending trades.",
                start: "Start",
                surprise: "Surprise",
                goToJail: "Go to Jail",
                vacation: "Vacation",
                water: "Water",
                electricity: "Electricity",
                internet: "Internet",
                airport: "Airport",
                timeExpired: (playerName) => `${playerName}'s turn time expired! They have been removed from the game.`,
                allPlayersRemoved: "All players have been removed. Game Over!",
                playerPassedStart: (playerName, amount) => `Player ${playerName} passed Start and collected $${amount}!`,
                playerInDebt: (playerName, balance) => `${playerName}, you are in debt! You cannot play until your balance is non-negative. Sell properties to clear your debt. Your balance: $${balance}.`,
                landedOnUnowned: (propertyName) => `Landed on unowned property: ${propertyName}.`,
                landedOnOwned: (propertyName, ownerName, rent, playerName) => `${playerName} landed on ${propertyName}, owned by ${ownerName}. Paid rent $${rent}.`,
                landedOnOwn: (propertyName) => `You landed on your own property: ${propertyName}.`,
                landedOnJail: (playerName) => `${playerName} went to Jail! (Jail logic not yet implemented)`,
                landedOnSurprise: (playerName) => `${playerName} landed on Surprise! (Surprise logic not yet implemented)`,
                landedOnVacation: (playerName) => `${playerName} is on Vacation!`,
                landedOnMisc: (content) => `You landed on: ${content}`,
                buyPropertyQuestion: (propertyName) => `Do you want to buy ${propertyName}?`,
                price: "Price",
                currentMoney: "Current Money",
                buy: "Buy",
                pass: "Pass",
                playerBought: (playerName, propertyName, price) => `${playerName} bought ${propertyName} for $${price}!`,
                playerPassed: (playerName, propertyName) => `${playerName} decided to pass on ${propertyName}.`,
                notOwnedOrExists: "You do not own this city or it does not exist!",
                mustOwnAllCities: (country) => `You must own all cities in ${country} to upgrade this property!`,
                maxLevel: "Property is already at maximum upgrade level!",
                notEnoughMoney: "You do not have enough money to upgrade this property!",
                playerUpgraded: (playerName, propertyName, level) => `${playerName} upgraded ${propertyName}! Current Level: ${level}`,
                minLevel: "Property is at base level, cannot downgrade further!",
                playerDowngraded: (playerName, propertyName, amount, level) => `${playerName} downgraded ${propertyName} and received $${amount}! Current Level: ${level}`,
                sellProperties: "Sell Properties",
                sellSelected: "Sell Selected Properties",
                noPropertiesToSell: "You have no properties to sell.",
                selectAtLeastOne: "Please select at least one property to sell.",
                playerSold: (playerName, count, amount, balance) => `${playerName} sold ${count} property(ies) and received $${amount}! Your current balance: $${balance}`,
                maxPlayersReached: "Maximum number of players reached!",
                addAtLeastOnePlayer: "Please add at least one player to start the game.",
                turnEnded: (currentPlayerName, nextPlayerName) => `Turn ended for ${currentPlayerName}. It's now ${nextPlayerName}'s turn.`,
                createTradeOffer: "Create Trade Offer",
                tradeWith: "Trade with:",
                youOffer: "You Offer:",
                money: "Money",
                yourProperties: "Your Properties:",
                noPropertiesToOffer: "No properties to offer.",
                youRequest: "You Request:",
                theirProperties: "Their Properties:",
                noPropertiesToRequest: "No properties to request from this player.",
                sendOffer: "Send Offer",
                selectRecipient: "Please select a trade recipient.",
                specifyItems: "Please specify at least one item to offer or request.",
                insufficientMoneyOffer: "You do not have enough money to offer this amount.",
                onlyOwnProperties: "You can only offer properties that you own.",
                onlyRequestOwned: "You can only request properties owned by the selected player.",
                offerSent: (recipientName) => `Trade offer sent to ${recipientName}!`,
                incomingTradeOffer: "Incoming Trade Offer",
                from: "From:",
                theyOffer: "They Offer:",
                none: "None",
                theyRequest: "They Request:",
                accept: "Accept",
                decline: "Decline",
                tradeError: "Error: Sender or recipient not found for trade.",
                senderInsufficientMoney: (senderName) => `${senderName} does not have enough money to complete this trade.`,
                recipientInsufficientMoney: (recipientName) => `${recipientName} does not have enough money to complete this trade.`,
                senderMissingProps: (senderName) => `${senderName} no longer owns some of the properties they are offering.`,
                recipientMissingProps: (recipientName) => `${recipientName} no longer owns some of the properties requested from them.`,
                tradeAccepted: (senderName, recipientName) => `Trade between ${senderName} and ${recipientName} accepted!`,
                tradeDeclined: (senderName, recipientName) => `Trade offer from ${senderName} to ${recipientName} declined.`,
                tradeCancelled: (senderName, recipientName) => `Trade offer from ${senderName} to ${recipientName} cancelled.`,
                tradeNotFound: "Trade offer not found.",
                tradeDetails: "Trade Offer Details",
                to: "To:",
                offering: "Offering:",
                requesting: "Requesting:",
                modify: "Modify",
                cancel: "Cancel",
                currentLevel: "Current Level:",
                baseRent: "Base Rent",
                level: "Level",
                max: "Max",
                min: "Min",
                makeTrade: "Make trades with other players to exchange properties, money, bonus cards.",
                useCreate: "Use the \"Create\" button to initiate a new trade.",
                aiPlayer: (id) => `AI Player ${id}`,
                settings: "Settings",
                language: "Language",
                english: "English",
                arabic: "Arabic",
                apply: "Apply",
                close: "Close",
                kick: "Kick",
                confirmKick: (playerName) => `Are you sure you want to kick ${playerName} from the lobby?`,
                leader: "Leader",
                playerKicked: (playerName) => `${playerName} has been kicked from the lobby.`,
                onlyLeaderCanKick: "Only the party leader can kick players.",
                usernameModalTitle: "Choose Your Username",
                usernameModalDescription: "This will be your unique name in the game. Only lowercase letters, numbers, and underscores are allowed.",
                saveUsername: "Save Username",
                usernameInvalid: "Username must be lowercase, alphanumeric with underscores, and between 3-15 characters.",
                usernameTaken: "This username is already taken. Please choose another.",
                usernameSaved: (username) => `Username "${username}" saved successfully!`,
                noOtherPlayers: "No other players in the lobby to trade with.",
                chatUnavailable: "Chat is currently unavailable (No Database Connection).",
                prop_s_: "prop(s)",
                offer: "Offer",
                request: "Request",
                createJoinParty: "Create/Join",
                lobbyNotFound: "Lobby not found or game has started.",
                lobbyCreated: (code) => `Lobby created! Share code: ${code}`,
                lobbyJoined: (code) => `Joined lobby: ${code}`,
                playerJoinedLobby: (playerName) => `${playerName} joined the lobby.`,
                playerLeftLobby: (playerName) => `${playerName} left the lobby.`,
                gameStarted: "Game started!",
                gameEnded: "Game ended!",
                gameAlreadyStarted: "Game has already started.",
                gameNotStarted: "Game has not started yet.",
                notLeader: "Only the party leader can start the game.",
                playerMoney: (amount) => `Money: $${amount}`,
                timeLeft: "Time Left",
                modifyTradeOffer: "Modify Trade Offer",
                playerMoneyDisplay: "Money",
                playerCount: "Players"
            },
            ar: {
                back: "العودة",
                lobby: "الردهة",
                unrated: "غير مصنف",
                competitive: "تنافسي",
                closedParty: "حفلة مغلقة",
                partyCode: "رمز الحفلة",
                addPlayer: "إضافة لاعب",
                play: "العب",
                online: "متصل",
                money: "المال",
                ready: "جاهز",
                userId: "معرف المستخدم",
                shareGame: "مشاركة هذه اللعبة",
                copy: "نسخ",
                roomSettings: "إعدادات الغرفة",
                saySomething: "قل شيئًا...",
                send: "إرسال",
                players: "اللاعبون",
                trades: "الصفقات",
                create: "إنشاء",
                pendingTrades: "الصفقات المعلقة",
                myProperties: "ممتلكاتي",
                sellProperty: "بيع ممتلكات",
                noProperties: "لا توجد ممتلكات حاليًا.",
                noPendingTrades: "لا توجد صفقات معلقة.",
                start: "البداية",
                surprise: "مفاجأة",
                goToJail: "اذهب إلى السجن",
                vacation: "إجازة",
                water: "الماء",
                electricity: "الكهرباء",
                internet: "الإنترنت",
                airport: "المطار",
                timeExpired: (playerName) => `انتهى وقت دور ${playerName}! لقد تم إزالته من اللعبة.`,
                allPlayersRemoved: "تمت إزالة جميع اللاعبين. انتهت اللعبة!",
                playerPassedStart: (playerName, amount) => `مر اللاعب ${playerName} على البداية وجمع $${amount}!`,
                playerInDebt: (playerName, balance) => `أيها اللاعب ${playerName}، أنت مدين! لا يمكنك اللعب حتى يصبح رصيدك غير سالب. قم ببيع الممتلكات لتسوية دينك. رصيدك الحالي: $${balance}.`,
                landedOnUnowned: (propertyName) => `هبطت على عقار غير مملوك: ${propertyName}.`,
                landedOnOwned: (propertyName, ownerName, rent, playerName) => `هبط ${playerName} على ${propertyName}، المملوك لـ ${ownerName}. دفع إيجار $${rent}.`,
                landedOnOwn: (propertyName) => `لقد هبطت على عقارك الخاص: ${propertyName}.`,
                landedOnJail: (playerName) => `ذهب ${playerName} إلى السجن! (لم يتم تنفيذ منطق السجن بعد)`,
                landedOnSurprise: (playerName) => `هبط ${playerName} على مفاجأة! (لم يتم تنفيذ منطق المفاجأة بعد)`,
                landedOnVacation: (playerName) => ` ${playerName} في إجازة!`,
                landedOnMisc: (content) => `لقد هبطت على: ${content}`,
                buyPropertyQuestion: (propertyName) => `هل تريد شراء ${propertyName}؟`,
                price: "السعر",
                currentMoney: "المال الحالي",
                buy: "شراء",
                pass: "تخطي",
                playerBought: (playerName, propertyName, price) => `اشترى ${playerName} ${propertyName} مقابل $${price}!`,
                playerPassed: (playerName, propertyName) => `قرر ${playerName} تخطي ${propertyName}.`,
                notOwnedOrExists: "أنت لا تملك هذه المدينة أو أنها غير موجودة!",
                mustOwnAllCities: (country) => `يجب أن تمتلك جميع المدن في ${country} لترقية هذا العقار!`,
                maxLevel: "العقار بالفعل في أقصى مستوى ترقية!",
                notEnoughMoney: "ليس لديك ما يكفي من المال لترقية هذا العقار!",
                playerUpgraded: (playerName, propertyName, level) => `قام ${playerName} بترقية ${propertyName}! المستوى الحالي: ${level}`,
                minLevel: "العقار في المستوى الأساسي، لا يمكن تخفيض مستواه أكثر!",
                playerDowngraded: (playerName, propertyName, amount, level) => `قام ${playerName} بتخفيض مستوى ${propertyName} واستلم $${amount}! المستوى الحالي: ${level}`,
                sellProperties: "بيع الممتلكات",
                sellSelected: "بيع الممتلكات المحددة",
                noPropertiesToSell: "ليس لديك ممتلكات لبيعها.",
                selectAtLeastOne: "الرجاء تحديد عقار واحد على الأقل للبيع.",
                playerSold: (playerName, count, amount, balance) => `باع ${playerName} ${count} عقار(ات) واستلم $${amount}! رصيدك الحالي: $${balance}`,
                maxPlayersReached: "تم الوصول إلى الحد الأقصى لعدد اللاعبين!",
                addAtLeastOnePlayer: "الرجاء إضافة لاعب واحد على الأقل لبدء اللعبة.",
                turnEnded: (currentPlayerName, nextPlayerName) => `انتهى دور ${currentPlayerName}. الآن دور ${nextPlayerName}.`,
                createTradeOffer: "إنشاء عرض تبادل",
                tradeWith: "التبادل مع:",
                youOffer: "أنت تعرض:",
                money: "المال:",
                yourProperties: "ممتلكاتك:",
                noPropertiesToOffer: "لا توجد ممتلكات لعرضها.",
                youRequest: "أنت تطلب:",
                theirProperties: "ممتلكاتهم:",
                noPropertiesToRequest: "لا توجد ممتلكات لطلبها من هذا اللاعب.",
                sendOffer: "إرسال العرض",
                selectRecipient: "الرجاء تحديد مستلم للعرض.",
                specifyItems: "الرجاء تحديد عنصر واحد على الأقل للعرض أو الطلب.",
                insufficientMoneyOffer: "ليس لديك ما يكفي من المال لعرض هذا المبلغ.",
                onlyOwnProperties: "يمكنك فقط عرض الممتلكات التي تملكها.",
                onlyRequestOwned: "يمكنك فقط طلب الممتلكات التي يملكها اللاعب المحدد.",
                offerSent: (recipientName) => `تم إرسال عرض التبادل إلى ${recipientName}!`,
                incomingTradeOffer: "عرض تبادل وارد",
                from: "من:",
                theyOffer: "هم يعرضون:",
                none: "لا شيء",
                theyRequest: "هم يطلبون:",
                accept: "قبول",
                decline: "رفض",
                tradeError: "خطأ: لم يتم العثور على المرسل أو المستلم للصفقة.",
                senderInsufficientMoney: (senderName) => `ليس لدى ${senderName} ما يكفي من المال لإتمام هذه الصفقة.`,
                recipientInsufficientMoney: (recipientName) => `ليس لدى ${recipientName} ما يكفي من المال لإتمام هذه الصفقة.`,
                senderMissingProps: (senderName) => `لم يعد ${senderName} يملك بعض الممتلكات التي يعرضها.`,
                recipientMissingProps: (recipientName) => `لم يعد ${recipientName} يملك بعض الممتلكات المطلوبة منهم.`,
                tradeAccepted: (senderName, recipientName) => `تم قبول الصفقة بين ${senderName} و ${recipientName}!`,
                tradeDeclined: (senderName, recipientName) => `تم رفض عرض التبادل من ${senderName} إلى ${recipientName}.`,
                tradeCancelled: (senderName, recipientName) => `تم إلغاء عرض التبادل من ${senderName} إلى ${recipientName}.`,
                tradeNotFound: "لم يتم العثور على عرض التبادل.",
                tradeDetails: "تفاصيل عرض التبادل",
                to: "إلى:",
                offering: "يعرض:",
                requesting: "يطلب:",
                modify: "تعديل",
                cancel: "إلغاء",
                currentLevel: "المستوى الحالي:",
                baseRent: "الإيجار الأساسي",
                level: "المستوى",
                max: "الحد الأقصى",
                min: "الحد الأدنى",
                makeTrade: "قم بإجراء صفقات مع لاعبين آخرين لتبادل الممتلكات والمال وبطاقات المكافآت.",
                useCreate: "استخدم زر \"إنشاء\" لبدء صفقة جديدة.",
                aiPlayer: (id) => `اللاعب الآلي ${id}`,
                settings: "الإعدادات",
                language: "اللغة",
                english: "الإنجليزية",
                arabic: "العربية",
                apply: "تطبيق",
                close: "إغلاق",
                kick: "طرد",
                confirmKick: (playerName) => `هل أنت متأكد أنك تريد طرد ${playerName} من الردهة؟`,
                leader: "القائد",
                playerKicked: (playerName) => `${playerName} تم طرده من الردهة.`,
                onlyLeaderCanKick: "فقط قائد الحفلة يمكنه طرد اللاعبين.",
                usernameModalTitle: "اختر اسم المستخدم الخاص بك",
                usernameModalDescription: "سيكون هذا اسمك الفريد في اللعبة. يُسمح فقط بالأحرف الصغيرة والأرقام والشرطات السفلية.",
                saveUsername: "حفظ اسم المستخدم",
                usernameInvalid: "يجب أن يكون اسم المستخدم أحرفًا صغيرة وأرقامًا وشرطات سفلية، ويتراوح طوله بين 3-15 حرفًا.",
                usernameTaken: "اسم المستخدم هذا مستخدم بالفعل. الرجاء اختيار اسم آخر.",
                usernameSaved: (username) => `تم حفظ اسم المستخدم "${username}" بنجاح!`,
                noOtherPlayers: "لا يوجد لاعبون آخرون في الردهة للمقايضة معهم.",
                chatUnavailable: "الدردشة غير متاحة حاليًا (لا يوجد اتصال بقاعدة البيانات).",
                prop_s_: "عقار(ات)",
                offer: "عرض",
                request: "طلب",
                createJoinParty: "إنشاء/انضمام",
                lobbyNotFound: "لم يتم العثور على الردهة أو بدأت اللعبة.",
                lobbyCreated: (code) => `تم إنشاء الردهة! رمز المشاركة: ${code}`,
                lobbyJoined: (code) => `انضممت إلى الردهة: ${code}`,
                playerJoinedLobby: (playerName) => `انضم ${playerName} إلى الردهة.`,
                playerLeftLobby: (playerName) => `غادر ${playerName} الردهة.`,
                gameStarted: "بدأت اللعبة!",
                gameEnded: "انتهت اللعبة!",
                gameAlreadyStarted: "لقد بدأت اللعبة بالفعل.",
                gameNotStarted: "لم تبدأ اللعبة بعد.",
                notLeader: "فقط قائد الحفلة يمكنه بدء اللعبة.",
                playerMoney: (amount) => `المال: $${amount}`,
                timeLeft: "الوقت المتبقي",
                modifyTradeOffer: "تعديل عرض التبادل",
                playerMoneyDisplay: "المال",
                playerCount: "اللاعبون"
            }
        };

        function getTranslation(key, ...args) {
            const translation = translations[gameState.currentLanguage][key];
            if (typeof translation === 'function') {
                return translation(...args);
            }
            return translation || key; // Fallback to key if not found
        }

        function updateAllTextContent() {
            // Update header
            document.getElementById('backButtonText').textContent = getTranslation('back');
            document.getElementById('lobbyTitle').textContent = getTranslation('lobby');
            document.getElementById('unratedMode').textContent = getTranslation('unrated');
            document.getElementById('competitiveMode').textContent = getTranslation('competitive');

            // Update party section
            document.getElementById('closedPartyText').textContent = getTranslation('closedParty');
            document.getElementById('partyCodeInput').placeholder = getTranslation('partyCode');
            document.getElementById('createJoinPartyBtn').textContent = getTranslation('createJoinParty');


            // Update lobby player cards (re-render)
            updateLobbyPlayerCards();

            document.getElementById('lobbyPlayButton').textContent = getTranslation('play');

            // Update online players sidebar
            document.getElementById('onlinePlayersTitle').innerHTML = `${getTranslation('online')} <span class="text-green-400">(${gameState.players.length})</span>`;

            // Update game page elements
            document.getElementById('shareGameTitle').textContent = getTranslation('shareGame');
            document.getElementById('copyButtonText').textContent = getTranslation('copy');
            document.getElementById('roomSettingsButtonText').textContent = getTranslation('roomSettings');
            document.getElementById('userIdTitle').textContent = getTranslation('userId');
            document.getElementById('chatUnavailableText').textContent = getTranslation('chatUnavailable'); // Assuming chatUnavailable key
            document.getElementById('chatInput').placeholder = getTranslation('saySomething');
            document.getElementById('sendButtonText').textContent = getTranslation('send');

            document.getElementById('playersTitle').textContent = getTranslation('players');
            document.getElementById('tradesTitle').textContent = getTranslation('trades');
            document.getElementById('makeTradeText').textContent = getTranslation('makeTrade');
            document.getElementById('useCreateText').textContent = getTranslation('useCreate');
            document.getElementById('createButtonText').textContent = getTranslation('create');
            document.getElementById('pendingTradesTitle').innerHTML = `${getTranslation('pendingTrades')} (<span id="pendingTradesCount">${gameState.pendingTradeOffers.length}</span>)`;
            document.getElementById('noPendingTradesText').textContent = getTranslation('noPendingTrades');
            document.getElementById('myPropertiesTitle').innerHTML = `${getTranslation('myProperties')} (<span id="myPropertiesCount">0</span>)`;
            document.getElementById('noPropertiesText').textContent = getTranslation('noProperties');
            document.getElementById('sellPropertyButtonText').textContent = getTranslation('sellProperty');

            // Modals
            document.getElementById('propertyModalPriceLabel').childNodes[0].nodeValue = getTranslation('price') + ": ";
            document.getElementById('playerCurrentMoneyLabel').childNodes[0].nodeValue = getTranslation('currentMoney') + ": ";
            document.getElementById('buyButtonText').textContent = getTranslation('buy');
            document.getElementById('passButtonText').textContent = getTranslation('pass');

            document.getElementById('rentLevelsTitle').textContent = getTranslation('rentLevels');
            document.getElementById('currentUpgradeLevelDisplayLabel').childNodes[0].nodeValue = getTranslation('currentLevel') + ": ";

            document.getElementById('createTradeOfferTitle').textContent = getTranslation('createTradeOffer');
            document.getElementById('tradeWithLabel').textContent = getTranslation('tradeWith');
            document.getElementById('youOfferTitle').textContent = getTranslation('youOffer');
            document.getElementById('offerMoneyLabel').textContent = getTranslation('money') + ":";
            document.getElementById('yourPropertiesLabel').textContent = getTranslation('yourProperties');
            document.getElementById('noPropertiesToOfferText').textContent = getTranslation('noPropertiesToOffer');
            document.getElementById('youRequestTitle').textContent = getTranslation('youRequest');
            document.getElementById('requestMoneyLabel').textContent = getTranslation('money') + ":";
            document.getElementById('theirPropertiesLabel').textContent = getTranslation('theirProperties');
            document.getElementById('noPropertiesToRequestText').textContent = getTranslation('noPropertiesToRequest');
            document.getElementById('sendOfferButtonText').textContent = getTranslation('sendOffer');

            document.getElementById('incomingTradeOfferTitle').textContent = getTranslation('incomingTradeOffer');
            document.getElementById('offerFromLabel').childNodes[0].nodeValue = getTranslation('from') + ": ";
            document.getElementById('theyOfferTitle').textContent = getTranslation('theyOffer');
            document.getElementById('offerReceivedMoneyLabel').childNodes[0].nodeValue = getTranslation('money') + ": $";
            document.getElementById('offerReceivedPropertiesLabel').textContent = getTranslation('properties') + ":";
            document.getElementById('theyRequestTitle').textContent = getTranslation('theyRequest');
            document.getElementById('requestSentMoneyLabel').childNodes[0].nodeValue = getTranslation('money') + ": $";
            document.getElementById('requestSentPropertiesLabel').textContent = getTranslation('properties') + ":";
            document.getElementById('acceptButtonText').textContent = getTranslation('accept');
            document.getElementById('declineButtonText').textContent = getTranslation('decline');

            document.getElementById('tradeDetailsViewTitle').textContent = getTranslation('tradeDetails');
            document.getElementById('tradeDetailsHeader').childNodes[0].nodeValue = getTranslation('from') + ": ";
            document.getElementById('tradeDetailsToText').textContent = getTranslation('to');
            document.getElementById('offeringTitle').textContent = getTranslation('offering');
            document.getElementById('tradeDetailsOfferedMoneyLabel').childNodes[0].nodeValue = getTranslation('money') + ": $";
            document.getElementById('tradeDetailsOfferedPropertiesLabel').textContent = getTranslation('properties') + ":";
            document.getElementById('requestingTitle').textContent = getTranslation('requesting');
            document.getElementById('tradeDetailsRequestedMoneyLabel').childNodes[0].nodeValue = getTranslation('money') + ": $";
            document.getElementById('tradeDetailsRequestedPropertiesLabel').textContent = getTranslation('properties') + ":";

            document.getElementById('sellPropertiesTitle').textContent = getTranslation('sellProperties');
            document.getElementById('noPropertiesToSellText').textContent = getTranslation('noPropertiesToSell');
            document.getElementById('sellSelectedPropertiesButtonText').textContent = getTranslation('sellSelected');

            document.getElementById('settingsModalTitle').textContent = getTranslation('settings');
            document.getElementById('languageLabel').textContent = getTranslation('language') + ":";
            document.getElementById('langOptionEn').textContent = getTranslation('english');
            document.getElementById('langOptionAr').textContent = getTranslation('arabic');
            document.getElementById('applyButtonText').textContent = getTranslation('apply');
            document.getElementById('closeButtonText').textContent = getTranslation('close');

            // Username modal
            document.getElementById('usernameModalTitle').textContent = getTranslation('usernameModalTitle');
            document.getElementById('usernameModalDescription').textContent = getTranslation('usernameModalDescription');
            document.getElementById('saveUsernameBtn').textContent = getTranslation('saveUsername');
        }

        // Custom alert function (replaces window.alert)
        function alert(message) {
            const existingAlert = document.getElementById('custom-alert');
            if (existingAlert) {
                existingAlert.remove();
            }

            const alertDiv = document.createElement('div');
            alertDiv.id = 'custom-alert';
            // Increased vertical padding (py-10) and reduced horizontal padding (px-3)
            alertDiv.className = 'fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-gray-800 text-white py-10 px-3 rounded-lg shadow-lg z-50 flex flex-col items-center';
            alertDiv.style.minWidth = '250px';

            const messageP = document.createElement('p');
            messageP.textContent = message;
            // Increased text size for alert message
            messageP.className = 'text-xl mb-4 text-center';
            alertDiv.appendChild(messageP);

            const closeButton = document.createElement('button');
            closeButton.textContent = 'OK';
            closeButton.className = 'bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded-md focus:outline-none focus:ring-2 focus:ring-purple-500';
            closeButton.onclick = () => alertDiv.remove();
            alertDiv.appendChild(closeButton);

            document.body.appendChild(alertDiv);
        }

        // Function to show money gain/loss effect directly in the player list
        function showMoneyEffect(playerId, amount, type) {
            const moneyChangeSpan = document.getElementById(`player-money-change-${playerId}`);
            if (!moneyChangeSpan) return;

            moneyChangeSpan.textContent = `${type === 'gain' ? '+' : '-'}${amount}`;
            moneyChangeSpan.classList.remove('plus', 'minus'); // Clear previous classes
            moneyChangeSpan.classList.add(type); // Add 'gain' or 'loss'
            moneyChangeSpan.classList.add('active'); // Activate animation

            // Set a timeout to remove the 'active' class (trigger fade out)
            setTimeout(() => {
                moneyChangeSpan.classList.remove('active');
                // Clear text content after the transition finishes for cleanliness
                setTimeout(() => {
                    moneyChangeSpan.textContent = '';
                }, 700); // Match the transition duration in CSS
            }, 1500); // Show for 1.5 seconds before starting to fade
        }


        // Function to shuffle an array (Fisher-Yates algorithm) - No longer used for board generation
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        // Function to get the URL for a country flag image (still used for property details modal icon)
        function getCountryFlagImage(country) {
            const countryCodes = {
                "France": "fr",
                "Germany": "de",
                "USA": "us",
                "Canada": "ca",
                "Brazil": "br",
                "Argentina": "ar",
                "Egypt": "eg",
                "Nigeria": "ng",
                "Japan": "jp",
                "India": "in",
                "Mexico": "mx",
                "United Kingdom": "gb",
                "Australia": "au",
                "UAE": "ae",
                "Singapore": "sg",
                "South Africa": "za"
            };
            const code = countryCodes[country] ? countryCodes[country].toLowerCase() : 'xx'; // 'xx' for unknown
            const imageUrl = `https://flagcdn.com/w40/${code}.png`;
            // Fallback to a placeholder image if the actual flag image fails to load
            const fallbackImageUrl = `https://placehold.co/40x30/cccccc/000000?text=${encodeURIComponent(country.substring(0,2).toUpperCase())}`;
            return `<img src="${imageUrl}" alt="${country} Flag" class="w-6 h-auto" onerror="this.onerror=null;this.src='${fallbackImageUrl}';">`;
        }

        // Function to get a generic city emoji
        function getCityEmoji() {
            return "🏙️"; // A generic city emoji for city properties
        }

        // Function to get the emoji for a company property
        function getCompanyEmoji(companyName) {
            const companyEmojis = {
                "Water": "💧",
                "Electricity": "⚡",
                "Internet": "🌐",
                "Airport": "✈️"
            };
            return companyEmojis[companyName] || ''; // Return emoji or empty string if not found
        }

        // Define the board path in sequential order (used for player movement and cell ID mapping)
        const boardPath = [
            "cell-top-right-corner", // 0: Start
            "cell-top-1", // 1
            "cell-top-2", // 2
            "cell-top-3", // 3
            "cell-top-4", // 4
            "cell-top-5", // 5: Water
            "cell-top-6", // 6
            "cell-top-7", // 7
            "cell-top-8", // 8
            "cell-top-9", // 9
            "cell-top-left-corner", // 10: Surprise
            "cell-left-1", // 11
            "cell-left-2", // 12
            "cell-left-3", // 13
            "cell-left-4", // 14
            "cell-left-5", // 15: Electricity
            "cell-left-6", // 16
            "cell-left-7", // 17
            "cell-left-8", // 18
            "cell-left-9", // 19
            "cell-bottom-left-corner", // 20: Go to Jail
            "cell-bottom-1", // 21
            "cell-bottom-2", // 22
            "cell-bottom-3", // 23
            "cell-bottom-4", // 24
            "cell-bottom-5", // 25: Internet
            "cell-bottom-6", // 26
            "cell-bottom-7", // 27
            "cell-bottom-8", // 28
            "cell-bottom-9", // 29
            "cell-bottom-right-corner", // 30: Vacation
            "cell-right-1", // 31
            "cell-right-2", // 32
            "cell-right-3", // 33
            "cell-right-4", // 34
            "cell-right-5", // 35: Airport
            "cell-right-6", // 36
            "cell-right-7", // 37
            "cell-right-8", // 38
            "cell-right-9"  // 39
        ];

        // Helper to round to the nearest multiple of 5
        function roundToNearestFive(num) {
            return Math.round(num / 5) * 5;
        }

        // Define base prices for countries (richer countries have higher base prices)
        // Prices are now fixed, multiples of 5, and within 100-500 range
        const countryBasePrices = {
            "USA": 480, // Richer
            "Germany": 440, // Richer
            "Japan": 460, // Richer
            "France": 420, // Richer
            "Canada": 400, // Richer
            "Brazil": 205, // Poorer
            "Argentina": 185, // Poorer
            "Egypt": 165, // Poorer
            "India": 125, // Poorer
            "Mexico": 225 // Mid-low
        };

        // Function to generate rent levels based on base price
        function generateRentLevels(basePrice) {
            const rents = [];
            rents[0] = roundToNearestFive(basePrice * 0.10); // Base Rent
            rents[1] = roundToNearestFive(basePrice * 0.25); // Level 1
            rents[2] = roundToNearestFive(basePrice * 0.50); // Level 2
            rents[3] = roundToNearestFive(basePrice * 0.75); // Level 3
            rents[4] = roundToNearestFive(basePrice * 1.00); // Level 4
            return rents;
        }

        /**
         * Updates the visual display of a single board cell based on its current state.
         * This is called after a property is purchased, upgraded, or downgraded.
         * @param {HTMLElement} cellElement - The DOM element of the cell to update.
         * @param {object} cellInfo - The cell's information object from gameState.boardCellsInfo.
         */
        function updateBoardCellDisplay(cellElement, cellInfo) {
            if (!cellElement) {
                console.error("Cell element is null or undefined.");
                return;
            }
            if (!cellInfo) {
                console.error("Cell info is null or undefined for cell element:", cellElement);
                return;
            }

            // Preserve player tokens and existing color bar
            const playerTokens = Array.from(cellElement.querySelectorAll('.player-token'));
            const existingColorBar = cellElement.querySelector('.property-color-bar');

            cellElement.innerHTML = ''; // Clear everything else

            // Re-append the color bar or create a new one
            let colorBar;
            if (existingColorBar) {
                colorBar = existingColorBar;
            } else {
                colorBar = document.createElement('div');
                colorBar.classList.add('w-full', 'h-2', 'absolute', 'top-0', 'left-0', 'property-color-bar');
            }

            const ownerPlayer = cellInfo.owner !== null ? gameState.players.find(p => p.userId === cellInfo.owner) : null;

            // Logic for color bar visibility and color
            if (cellInfo.type === 'city' || cellInfo.type === 'company') {
                colorBar.classList.remove('hidden'); // Always show for city/company
                colorBar.style.backgroundColor = ownerPlayer ? ownerPlayer.color : '#FFFFFF'; // White if unowned, player color if owned
            } else {
                colorBar.classList.add('hidden'); // Hide for other cell types (corners)
            }
            cellElement.appendChild(colorBar);

            // Create a container for the main content to control its z-index and layout
            const contentContainer = document.createElement('div');
            contentContainer.className = 'flex flex-col items-center justify-center h-full w-full relative z-2'; // z-index 2 for content

            // Create content elements dynamically
            if (cellInfo.type === 'city' && cellInfo.country) {
                const displayName = gameState.currentLanguage === 'ar' ? cellInfo.displayName_ar : cellInfo.displayName_en;

                // City Name (under the color bar)
                const nameDiv = document.createElement('div');
                nameDiv.className = 'text-xs font-bold leading-tight mt-1'; // Added mt-1 to move down slightly
                nameDiv.textContent = displayName;
                contentContainer.appendChild(nameDiv);

                // Country Flag
                const countryFlagDiv = document.createElement('div');
                countryFlagDiv.className = 'flex-shrink-0 mb-1'; // Added mb-1 to move up slightly
                countryFlagDiv.innerHTML = getCountryFlagImage(cellInfo.country);
                contentContainer.appendChild(countryFlagDiv);

                // Price
                const priceDiv = document.createElement('div');
                priceDiv.className = 'text-xs font-bold text-green-400 leading-tight';
                priceDiv.textContent = `$${cellInfo.price}`;
                contentContainer.appendChild(priceDiv);

                // Level
                const levelDiv = document.createElement('div');
                levelDiv.className = 'text-xs text-gray-400 leading-tight';
                levelDiv.textContent = `${getTranslation('level')}: ${cellInfo.currentUpgradeLevel}`; // Abbreviated "Level"
                contentContainer.appendChild(levelDiv);

            } else if (cellInfo.type === 'company') {
                const displayName = gameState.currentLanguage === 'ar' ? cellInfo.displayName_ar : cellInfo.displayName_en;
                const nameDiv = document.createElement('div');
                nameDiv.className = 'text-xs font-bold leading-tight';
                nameDiv.textContent = displayName;
                contentContainer.appendChild(nameDiv);

                const priceDiv = document.createElement('div');
                priceDiv.className = 'text-xs font-bold text-green-400 leading-tight';
                priceDiv.textContent = `$${cellInfo.price}`;
                contentContainer.appendChild(priceDiv);

                const emojiDiv = document.createElement('div');
                emojiDiv.className = 'text-lg';
                emojiDiv.innerHTML = getCompanyEmoji(cellInfo.content);
                contentContainer.appendChild(emojiDiv);

            } else if (cellInfo.type === 'corner') {
                const emojiDiv = document.createElement('div');
                emojiDiv.className = 'text-3xl';
                emojiDiv.innerHTML = cellInfo.emoji;
                contentContainer.appendChild(emojiDiv);
            }

            // Append the content container to the cell
            cellElement.appendChild(contentContainer);

            // Re-append player tokens
            playerTokens.forEach(token => cellElement.appendChild(token));

            console.log(`Updated cell ${cellInfo.id}. InnerHTML:`, cellElement.innerHTML); // Debug log
        }


        // Function to populate the board with cities and special cells dynamically
        function populateBoard() {
            // Assign the static board layout for "World 1"
            // This ensures the board is always the same and cities of the same country are adjacent.
            gameState.boardCellsInfo = [
                // Index 0: Start
                { id: "cell-top-right-corner", type: "corner", content: "Start", displayName_en: "Start", displayName_ar: "البداية", emoji: "➡️", boardIndex: 0, owner: null },

                // Top Row Cities (USA)
                { id: "cell-top-1", type: "city", content: "New York", displayName_en: "New York", displayName_ar: "نيويورك", country: "USA", price: countryBasePrices["USA"], currentUpgradeLevel: 0, rentLevels: generateRentLevels(countryBasePrices["USA"]), owner: null },
                { id: "cell-top-2", type: "city", content: "Los Angeles", displayName_en: "L.A.", displayName_ar: "لوس أنجلوس", country: "USA", price: countryBasePrices["USA"], currentUpgradeLevel: 0, rentLevels: generateRentLevels(countryBasePrices["USA"]), owner: null },
                { id: "cell-top-3", type: "city", content: "Chicago", displayName_en: "Chicago", displayName_ar: "شيكاغو", country: "USA", price: countryBasePrices["USA"], currentUpgradeLevel: 0, rentLevels: generateRentLevels(countryBasePrices["USA"]), owner: null },
                { id: "cell-top-4", type: "city", content: "Houston", displayName_en: "Houston", displayName_ar: "هيوستن", country: "USA", price: countryBasePrices["USA"], currentUpgradeLevel: 0, rentLevels: generateRentLevels(countryBasePrices["USA"]), owner: null },

                // Index 5: Water Company
                { id: "cell-top-5", type: "company", content: "Water", displayName_en: "Water", displayName_ar: "الماء", price: 150, emoji: "💧", rentLevels: [15], boardIndex: 5, owner: null },

                // Top Row Cities (Germany)
                { id: "cell-top-6", type: "city", content: "Berlin", displayName_en: "Berlin", displayName_ar: "برلين", country: "Germany", price: countryBasePrices["Germany"], currentUpgradeLevel: 0, rentLevels: generateRentLevels(countryBasePrices["Germany"]), owner: null },
                { id: "cell-top-7", type: "city", content: "Munich", displayName_en: "Munich", displayName_ar: "ميونخ", country: "Germany", price: countryBasePrices["Germany"], currentUpgradeLevel: 0, rentLevels: generateRentLevels(countryBasePrices["Germany"]), owner: null },
                { id: "cell-top-8", type: "city", content: "Hamburg", displayName_en: "Hamburg", displayName_ar: "هامبورغ", country: "Germany", price: countryBasePrices["Germany"], currentUpgradeLevel: 0, rentLevels: generateRentLevels(countryBasePrices["Germany"]), owner: null },
                { id: "cell-top-9", type: "city", content: "Frankfurt", displayName_en: "Frankfurt", displayName_ar: "فرانكفورت", country: "Germany", price: countryBasePrices["Germany"], currentUpgradeLevel: 0, rentLevels: generateRentLevels(countryBasePrices["Germany"]), owner: null },

                // Index 10: Surprise
                { id: "cell-top-left-corner", type: "corner", content: "Surprise", displayName_en: "Surprise", displayName_ar: "مفاجأة", emoji: "📦", boardIndex: 10, owner: null },

                // Left Column Cities (Japan)
                { id: "cell-left-1", type: "city", content: "Tokyo", displayName_en: "Tokyo", displayName_ar: "طوكيو", country: "Japan", price: countryBasePrices["Japan"], currentUpgradeLevel: 0, rentLevels: generateRentLevels(countryBasePrices["Japan"]), owner: null },
                { id: "cell-left-2", type: "city", content: "Osaka", displayName_en: "Osaka", displayName_ar: "أوساكا", country: "Japan", price: countryBasePrices["Japan"], currentUpgradeLevel: 0, rentLevels: generateRentLevels(countryBasePrices["Japan"]), owner: null },
                { id: "cell-left-3", type: "city", content: "Kyoto", displayName_en: "Kyoto", displayName_ar: "كيوتو", country: "Japan", price: countryBasePrices["Japan"], currentUpgradeLevel: 0, rentLevels: generateRentLevels(countryBasePrices["Japan"]), owner: null },
                { id: "cell-left-4", type: "city", content: "Sapporo", displayName_en: "Sapporo", displayName_ar: "سابورو", country: "Japan", price: countryBasePrices["Japan"], currentUpgradeLevel: 0, rentLevels: generateRentLevels(countryBasePrices["Japan"]), owner: null },

                // Index 15: Electricity Company
                { id: "cell-left-5", type: "company", content: "Electricity", displayName_en: "Electricity", displayName_ar: "الكهرباء", price: 150, emoji: "⚡", rentLevels: [15], boardIndex: 15, owner: null },

                // Left Column Cities (France)
                { id: "cell-left-6", type: "city", content: "Paris", displayName_en: "Paris", displayName_ar: "باريس", country: "France", price: countryBasePrices["France"], currentUpgradeLevel: 0, rentLevels: generateRentLevels(countryBasePrices["France"]), owner: null },
                { id: "cell-left-7", type: "city", content: "Marseille", displayName_en: "Marseille", displayName_ar: "مرسيليا", country: "France", price: countryBasePrices["France"], currentUpgradeLevel: 0, rentLevels: generateRentLevels(countryBasePrices["France"]), owner: null },
                { id: "cell-left-8", type: "city", content: "Lyon", displayName_en: "Lyon", displayName_ar: "ليون", country: "France", price: countryBasePrices["France"], currentUpgradeLevel: 0, rentLevels: generateRentLevels(countryBasePrices["France"]), owner: null },
                { id: "cell-left-9", type: "city", content: "Nice", displayName_en: "Nice", displayName_ar: "نيس", country: "France", price: countryBasePrices["France"], currentUpgradeLevel: 0, rentLevels: generateRentLevels(countryBasePrices["France"]), owner: null },

                // Index 20: Go to Jail
                { id: "cell-bottom-left-corner", type: "corner", content: "Go to Jail", displayName_en: "Go to Jail", displayName_ar: "اذهب إلى السجن", emoji: "🚓", boardIndex: 20, owner: null },

                // Bottom Row Cities (Canada, Brazil, Argentina)
                { id: "cell-bottom-1", type: "city", content: "Toronto", displayName_en: "Toronto", displayName_ar: "تورونتو", country: "Canada", price: countryBasePrices["Canada"], currentUpgradeLevel: 0, rentLevels: generateRentLevels(countryBasePrices["Canada"]), owner: null },
                { id: "cell-bottom-2", type: "city", content: "Montreal", displayName_en: "Montreal", displayName_ar: "مونتريال", country: "Canada", price: countryBasePrices["Canada"], currentUpgradeLevel: 0, rentLevels: generateRentLevels(countryBasePrices["Canada"]), owner: null },
                { id: "cell-bottom-3", type: "city", content: "Vancouver", displayName_en: "Vancouver", displayName_ar: "فانكوفر", country: "Canada", price: countryBasePrices["Canada"], currentUpgradeLevel: 0, rentLevels: generateRentLevels(countryBasePrices["Canada"]), owner: null },
                { id: "cell-bottom-4", type: "city", content: "Rio de Janeiro", displayName_en: "Rio", displayName_ar: "ريو دي جانيرو", country: "Brazil", price: countryBasePrices["Brazil"], currentUpgradeLevel: 0, rentLevels: generateRentLevels(countryBasePrices["Brazil"]), owner: null },

                // Index 25: Internet Company
                { id: "cell-bottom-5", type: "company", content: "Internet", displayName_en: "Internet", displayName_ar: "الإنترنت", price: 150, emoji: "🌐", rentLevels: [15], boardIndex: 25, owner: null },

                // Bottom Row Cities (Brazil, Argentina)
                { id: "cell-bottom-6", type: "city", content: "Sao Paulo", displayName_en: "Sao Paulo", displayName_ar: "ساو باولو", country: "Brazil", price: countryBasePrices["Brazil"], currentUpgradeLevel: 0, rentLevels: generateRentLevels(countryBasePrices["Brazil"]), owner: null },
                { id: "cell-bottom-7", type: "city", content: "Brasilia", displayName_en: "Brasilia", displayName_ar: "برازيليا", country: "Brazil", price: countryBasePrices["Brazil"], currentUpgradeLevel: 0, rentLevels: generateRentLevels(countryBasePrices["Brazil"]), owner: null },
                { id: "cell-bottom-8", type: "city", content: "Buenos Aires", displayName_en: "B.A.", displayName_ar: "بوينس آيرس", country: "Argentina", price: countryBasePrices["Argentina"], currentUpgradeLevel: 0, rentLevels: generateRentLevels(countryBasePrices["Argentina"]), owner: null },
                { id: "cell-bottom-9", type: "city", content: "Cordoba", displayName_en: "Cordoba", displayName_ar: "قرطبة", country: "Argentina", price: countryBasePrices["Argentina"], currentUpgradeLevel: 0, rentLevels: generateRentLevels(countryBasePrices["Argentina"]), owner: null },

                // Index 30: Vacation
                { id: "cell-bottom-right-corner", type: "corner", content: "Vacation", displayName_en: "Vacation", displayName_ar: "إجازة", emoji: "🏖️", boardIndex: 30, owner: null },

                // Right Column Cities (Egypt, India, Mexico)
                { id: "cell-right-1", type: "city", content: "Cairo", displayName_en: "Cairo", displayName_ar: "القاهرة", country: "Egypt", price: countryBasePrices["Egypt"], currentUpgradeLevel: 0, rentLevels: generateRentLevels(countryBasePrices["Egypt"]), owner: null },
                { id: "cell-right-2", type: "city", content: "Alexandria", displayName_en: "Alexandria", displayName_ar: "الإسكندرية", country: "Egypt", price: countryBasePrices["Egypt"], currentUpgradeLevel: 0, rentLevels: generateRentLevels(countryBasePrices["Egypt"]), owner: null },
                { id: "cell-right-3", type: "city", content: "Giza", displayName_en: "Giza", displayName_ar: "الجيزة", country: "Egypt", price: countryBasePrices["Egypt"], currentUpgradeLevel: 0, rentLevels: generateRentLevels(countryBasePrices["Egypt"]), owner: null },
                { id: "cell-right-4", type: "city", content: "Mumbai", displayName_en: "Mumbai", displayName_ar: "مومباي", country: "India", price: countryBasePrices["India"], currentUpgradeLevel: 0, rentLevels: generateRentLevels(countryBasePrices["India"]), owner: null },

                // Index 35: Airport Company
                { id: "cell-right-5", type: "company", content: "Airport", displayName_en: "Airport", displayName_ar: "المطار", price: 2000, emoji: "✈️", rentLevels: [15], boardIndex: 35, owner: null },

                // Right Column Cities (India, Mexico)
                { id: "cell-right-6", type: "city", content: "Delhi", displayName_en: "Delhi", displayName_ar: "دلهي", country: "India", price: countryBasePrices["India"], currentUpgradeLevel: 0, rentLevels: generateRentLevels(countryBasePrices["India"]), owner: null },
                { id: "cell-right-7", type: "city", content: "Bangalore", displayName_en: "Bangalore", displayName_ar: "بنغالور", country: "India", price: countryBasePrices["India"], currentUpgradeLevel: 0, rentLevels: generateRentLevels(countryBasePrices["India"]), owner: null },
                { id: "cell-right-8", type: "city", content: "Mexico City", displayName_en: "Mexico City", displayName_ar: "مدينة مكسيكو", country: "Mexico", price: countryBasePrices["Mexico"], currentUpgradeLevel: 0, rentLevels: generateRentLevels(countryBasePrices["Mexico"]), owner: null },
                { id: "cell-right-9", type: "city", content: "Guadalajara", displayName_en: "Guadalajara", displayName_ar: "غوادالاخارا", country: "Mexico", price: countryBasePrices["Mexico"], currentUpgradeLevel: 0, rentLevels: generateRentLevels(countryBasePrices["Mexico"]), owner: null }
            ];


            const gameBoardGrid = document.querySelector('.game-board-grid');
            if (!gameBoardGrid) {
                console.error("Game board grid element not found!");
                return;
            }
            gameBoardGrid.innerHTML = ''; // Clear existing cells

            gameState.boardCellsInfo.forEach((cell, index) => {
                const cellElement = document.createElement('div');
                cellElement.classList.add('board-cell');
                cellElement.classList.add(boardPath[index]); // Add the specific class for grid positioning
                if (cell.type === 'corner') {
                    cellElement.classList.add('corner-cell');
                }

                // Add click listener for property details modal
                if (cell.type === 'city' || cell.type === 'company') {
                    cellElement.addEventListener('click', () => displayPropertyDetails(cell.id));
                }

                gameBoardGrid.appendChild(cellElement); // Append the element first

                // Then, update its display content
                updateBoardCellDisplay(cellElement, cell);
            });

            // Re-append the center area after all cells are added
            const boardCenter = document.createElement('div');
            boardCenter.classList.add('board-center');
            boardCenter.innerHTML = `
                <div id="randomNumberDisplay" class="text-white text-5xl font-bold mb-4"></div>
                <div id="turnTimerDisplay" class="text-red-400 text-3xl font-bold mb-4 hidden"></div>
                <button
                    id="rollDiceButton"
                    class="btn-primary flex items-center justify-center text-white text-2xl font-bold py-4 px-12 rounded-xl focus:outline-none focus:ring-4 focus->ring-purple-500 focus:ring-opacity-50"
                >
                    ${getTranslation('play')}
                </button>
            `;
            gameBoardGrid.appendChild(boardCenter);

            // Re-attach event listener for the new rollDiceButton
            const newRollDiceButton = document.getElementById('rollDiceButton');
            const newRandomNumberDisplay = document.getElementById('randomNumberDisplay');
            if (newRollDiceButton) {
                newRollDiceButton.addEventListener('click', handleRollDice);
            }
        }

        // Function to create and add player tokens to the board
        function addPlayerTokens() {
            gameState.players.forEach(player => {
                const playerToken = document.createElement('div');
                playerToken.id = `player-token-${player.userId}`; // Use userId for token ID
                playerToken.classList.add('player-token', `player-color-${player.id}`); // player.id is 1,2,3 for color
                playerToken.textContent = player.name.substring(0, 1).toUpperCase(); // Display first letter of username
                // Set initial position to "Start" cell
                const startCell = document.querySelector(`.${boardPath[player.positionIndex]}`);
                if (startCell) {
                    startCell.appendChild(playerToken);
                }
            });
            updatePlayersList(); // Initial highlight for current player
        }

        // Function to update players list in sidebar
        function updatePlayersList() {
            const playersListElem = document.getElementById('playersList');
            playersListElem.innerHTML = ''; // Clear current list

            gameState.players.forEach((player, index) => {
                const listItem = document.createElement('li');
                listItem.classList.add('flex', 'justify-between', 'items-center', 'py-1');
                if (index === gameState.currentPlayerIndex) {
                    listItem.classList.add('current-player-highlight'); // Highlight current player in sidebar
                }
                // Updated innerHTML to include the money-change span
                listItem.innerHTML = `
                    <span>
                        <i class="fas fa-user-circle mr-2" style="color: ${player.color};"></i> ${player.name}
                        <span id="player-money-change-${player.userId}" class="money-change"></span>
                    </span>
                    <span class="flex items-center gap-2">
                        <span class="text-green-400">$<span id="player-money-${player.userId}">${player.money}</span></span>
                        <button class="text-blue-400 hover:text-blue-200 text-sm" onclick="openTradeCreationModal('${currentUserId}')">
                            <i class="fas fa-handshake"></i>
                        </button>
                    </span>
                `;
                playersListElem.appendChild(listItem);
            });

            // Update player token highlight on the board
            gameState.players.forEach((player, index) => {
                const playerToken = document.getElementById(`player-token-${player.userId}`);
                if (playerToken) {
                    if (index === gameState.currentPlayerIndex) {
                        playerToken.classList.add('current-player-highlight');
                    } else {
                        playerToken.classList.remove('current-player-highlight');
                    }
                }
            });
        }

        // Function to update player's properties list
        function updateMyPropertiesList() {
            const myPropertiesListElem = document.getElementById('myPropertiesList');
            const myPropertiesCountElem = document.getElementById('myPropertiesCount');
            const currentPlayer = gameState.players.find(p => p.userId === currentUserId); // Get the actual current user

            if (!currentPlayer) {
                myPropertiesListElem.innerHTML = `<li class="text-sm text-gray-400">${getTranslation('noProperties')}</li>`;
                myPropertiesCountElem.textContent = 0;
                return;
            }

            // Filter properties that belong to the current player
            const playerProperties = Object.values(gameState.boardProperties).filter(
                prop => prop.ownerId === currentPlayer.userId
            );

            myPropertiesListElem.innerHTML = ''; // Clear current list
            myPropertiesCountElem.textContent = playerProperties.length;

            if (playerProperties.length === 0) {
                const listItem = document.createElement('li');
                listItem.classList.add('text-sm', 'text-gray-400');
                listItem.textContent = getTranslation('noProperties');
                myPropertiesListElem.appendChild(listItem);
            } else {
                playerProperties.forEach(prop => {
                    const listItem = document.createElement('li');
                    listItem.classList.add('text-sm', 'text-gray-300', 'py-0.5', 'flex', 'items-center', 'gap-2'); // Added flex for alignment

                    // Find the original cell info to get type, country, and emoji
                    const originalCell = gameState.boardCellsInfo.find(cell => cell.id === prop.id);

                    let iconHtml = '';
                    let displayName = '';
                    if (originalCell) {
                        displayName = gameState.currentLanguage === 'ar' ? originalCell.displayName_ar : originalCell.displayName_en;
                        if (originalCell.type === 'city') {
                            // Display country flag then city name
                            iconHtml = `${getCountryFlagImage(originalCell.country)} `;
                        } else if (originalCell.type === 'company') {
                            iconHtml = `<span class="text-lg">${getCompanyEmoji(originalCell.content)}</span>`;
                        }
                    }


                    listItem.innerHTML = `
                        ${iconHtml}
                        <span>${displayName} ($${prop.price})</span>
                    `; // Use originalCell.content for full name in list
                    myPropertiesListElem.appendChild(listItem);
                });
            }
        }

        // Function to check and update button state based on debt
        function checkPlayerDebtStatus() {
            const rollDiceButton = document.getElementById('rollDiceButton');
            const currentPlayer = gameState.players.find(p => p.userId === currentUserId);

            if (!currentPlayer) { // If no current player (e.g., game just ended)
                rollDiceButton.disabled = true;
                return;
            }

            // If the current player is indebted, disable the button
            if (currentPlayer.money < 0) {
                rollDiceButton.disabled = true;
                resetTurnTimer(); // Pause the timer if indebted
                // If the button text is "PLAY", it means they haven't rolled yet.
                // If it's "END", they already rolled and are now indebted.
                // In both cases, they cannot proceed until debt is cleared.
            } else {
                // If money is non-negative, enable the button if it's currently disabled
                // and the game is ready for a roll or an end turn.
                if (rollDiceButton.disabled) {
                    // Only re-enable if the button is supposed to be active for the current player's turn
                    // This prevents enabling it prematurely if it's disabled for other reasons (e.g., during movement)
                    if (rollDiceButton.textContent === getTranslation('play') || rollDiceButton.textContent === 'END') { // 'END' is not translated
                         rollDiceButton.disabled = false;
                    }
                }
                // If the player was indebted and cleared it, restart the timer if it was paused
                if (turnTimer === null && rollDiceButton.textContent === 'END') {
                    startTurnTimer();
                }
            }
        }

        // --- Timer Functions ---
        function startTurnTimer() {
            // Clear any existing timer to prevent multiple intervals running
            if (turnTimer) {
                clearInterval(turnTimer);
                console.log(`[Timer Debug] ${Date.now()}: Cleared existing timer ID ${turnTimer} before starting new one.`);
                turnTimer = null; // Ensure it's nullified
            }

            const turnTimerDisplay = document.getElementById('turnTimerDisplay');
            turnTimerDisplay.classList.remove('hidden'); // Show timer display
            timeLeft = TURN_DURATION_SECONDS;
            updateTimerDisplay(); // Initial display update

            const currentPlayer = gameState.players[gameState.currentPlayerIndex];
            console.log(`[Timer Debug] ${Date.now()}: Starting timer for ${currentPlayer?.name || 'unknown player'} (ID: ${currentPlayer?.userId}). Initial time left: ${timeLeft}s. Current player index: ${gameState.currentPlayerIndex}. Total players: ${gameState.players.length}.`);

            turnTimer = setInterval(() => {
                const currentCheckPlayer = gameState.players[gameState.currentPlayerIndex]; // Get player inside interval for current check
                if (!currentCheckPlayer) {
                    console.log(`[Timer Debug] ${Date.now()}: No current player found in interval (player might have been kicked or game ended). Stopping timer.`);
                    resetTurnTimer();
                    return;
                }

                if (currentCheckPlayer.money < 0) {
                    console.log(`[Timer Debug] ${Date.now()}: Timer paused for ${currentCheckPlayer.name} (ID: ${currentCheckPlayer.userId}). Money: ${currentCheckPlayer.money}. Time left: ${timeLeft}s. Timer ID: ${turnTimer}.`);
                    updateTimerDisplay(); // Still update to show current time, but it won't decrement
                    return;
                }

                timeLeft--;
                updateTimerDisplay();
                console.log(`[Timer Debug] ${Date.now()}: Timer ticked for ${currentCheckPlayer.name} (ID: ${currentCheckPlayer.userId}). Time left: ${timeLeft}s. Timer ID: ${turnTimer}.`);

                if (timeLeft <= 0) {
                    console.log(`[Timer Debug] ${Date.now()}: Time ran out for ${currentCheckPlayer.name} (ID: ${currentCheckPlayer.userId}). Kicking player. Timer ID: ${turnTimer}.`);
                    clearInterval(turnTimer); // Stop the interval immediately
                    turnTimer = null; // Nullify the timer ID
                    kickPlayer(); // Trigger kick logic
                }
            }, 1000);
            console.log(`[Timer Debug] ${Date.now()}: New timer set with ID: ${turnTimer}`);
        }

        function resetTurnTimer() {
            console.log(`[Timer Debug] ${Date.now()}: resetTurnTimer called. Attempting to clear timer ID: ${turnTimer}.`);
            if (turnTimer) {
                clearInterval(turnTimer);
                console.log(`[Timer Debug] ${Date.now()}: Successfully cleared timer ID: ${turnTimer}.`);
                turnTimer = null; // Explicitly set to null
            }
            timeLeft = 0;
            updateTimerDisplay();
            document.getElementById('turnTimerDisplay').classList.add('hidden'); // Hide timer display
        }

        function updateTimerDisplay() {
            const minutes = Math.floor(timeLeft / 60);
            const seconds = timeLeft % 60;
            document.getElementById('turnTimerDisplay').textContent =
                `${getTranslation('timeLeft')}: ${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        // Function to kick a player from the game (due to timer)
        async function kickPlayer() {
            console.log(`[Player Kick Debug] ${Date.now()}: kickPlayer called. Before kick - Current player index: ${gameState.currentPlayerIndex}. Total players: ${gameState.players.length}. Players array:`, gameState.players.map(p => p.name));
            const kickedPlayer = gameState.players[gameState.currentPlayerIndex];
            if (!kickedPlayer) {
                console.error(`[Player Kick Error] ${Date.now()}: No player to kick at current index ${gameState.currentPlayerIndex}. This should not happen if called from timer.`);
                return;
            }

            // Ensure timer is fully stopped before modifying player state
            // This is already called by the interval when timeLeft <= 0, but calling it again here is safe.
            resetTurnTimer();

            alert(getTranslation('timeExpired', kickedPlayer.name));
            console.log(`[Player Kick Debug] ${Date.now()}: Alert shown for ${kickedPlayer.name}.`);

            // Revert properties owned by the kicked player
            Object.keys(gameState.boardProperties).forEach(propId => {
                if (gameState.boardProperties[propId].ownerId === kickedPlayer.userId) {
                    const propertyInCellsInfo = gameState.boardCellsInfo.find(cell => cell.id === propId);
                    if (propertyInCellsInfo) {
                        propertyInCellsInfo.owner = null;
                        propertyInCellsInfo.currentUpgradeLevel = 0;
                        updateBoardCellDisplay(document.querySelector(`.${propId}`), propertyInCellsInfo);
                    }
                    delete gameState.boardProperties[propId];
                }
            });
            console.log(`[Player Kick Debug] ${Date.now()}: Properties reverted for ${kickedPlayer.name}.`);

            // Remove player token from the board
            const playerToken = document.getElementById(`player-token-${kickedPlayer.userId}`);
            if (playerToken) {
                playerToken.remove();
                console.log(`[Player Kick Debug] ${Date.now()}: Token removed for ${kickedPlayer.name}.`);
            }

            // Remove player from the game state
            gameState.players = gameState.players.filter(p => p.userId !== kickedPlayer.userId);
            console.log(`[Player Kick Debug] ${Date.now()}: Player ${kickedPlayer.name} removed from array. Remaining players: ${gameState.players.length}. Players array after filter:`, gameState.players.map(p => p.name));

            // If the kicked player was the leader, reassign leaderId
            if (kickedPlayer.userId === gameState.leaderId && gameState.players.length > 0) {
                gameState.leaderId = gameState.players[0].userId;
                console.log(`[Player Kick Debug] ${Date.now()}: Leader ${kickedPlayer.name} was kicked. New leader: ${gameState.players[0].name}.`);
            } else if (gameState.players.length === 0) {
                gameState.leaderId = null; // No leader if no players
            }

            if (gameState.players.length === 0) {
                alert(getTranslation('allPlayersRemoved'));
                console.log(`[Game Over] ${Date.now()}: No players left. Game Over.`);
                gameState.gameStatus = 'ended';
                await updateGameInFirestore(); // Update Firestore
                document.getElementById('gamePage').classList.add('hidden');
                document.getElementById('lobbyPage').classList.remove('hidden');
                return;
            }

            // Adjust currentPlayerIndex if necessary
            if (gameState.currentPlayerIndex >= gameState.players.length) {
                gameState.currentPlayerIndex = 0;
                console.log(`[Player Kick Debug] ${Date.now()}: Current player index adjusted to 0 (was out of bounds).`);
            }
            console.log(`[Player Kick Debug] ${Date.now()}: After kick - New current player index: ${gameState.currentPlayerIndex}. Next player: ${gameState.players[gameState.currentPlayerIndex]?.name}.`);

            // Update UI for the new current player
            updatePlayersList();
            updateMyPropertiesList();
            updatePendingTradesList(); // This will filter out trades involving the kicked player
            checkPlayerDebtStatus(); // Check next player's debt status to disable button if needed

            // Start the timer for the next player's turn, ONLY IF there are players left
            if (gameState.players.length > 0) {
                startTurnTimer();
            }
            updateLobbyPlayerCards(); // Update lobby cards to reflect removal and potential new leader
            await updateGameInFirestore(); // Update Firestore
        }


        // Function to handle dice roll and player movement
        async function handleRollDice() {
            const randomNumberDisplay = document.getElementById('randomNumberDisplay');
            const rollDiceButton = document.getElementById('rollDiceButton');
            const currentPlayer = gameState.players[gameState.currentPlayerIndex];

            // Check if the current player is indebted before allowing them to roll
            if (currentPlayer.money < 0) {
                alert(getTranslation('playerInDebt', currentPlayer.name, currentPlayer.money));
                rollDiceButton.disabled = true; // Ensure the button is disabled
                return; // Prevent rolling the dice
            }

            rollDiceButton.disabled = true; // Disable roll button immediately
            resetTurnTimer(); // Stop the timer while dice are rolling and moving
            console.log(`[Roll Dice Debug] ${Date.now()}: Player ${currentPlayer.name} (ID: ${currentPlayer.userId}) rolling dice. Timer reset.`);

            const roll = Math.floor(Math.random() * 6) + 1;
            randomNumberDisplay.textContent = roll;
            console.log(`[Roll Dice Debug] ${Date.now()}: Player ${currentPlayer.name} rolled: ${roll}`);

            const playerToken = document.getElementById(`player-token-${currentPlayer.userId}`);
            playerToken.classList.add('moving'); // Add moving class for visual effect

            const oldPositionIndex = currentPlayer.positionIndex;
            const targetPositionRaw = oldPositionIndex + roll; // Calculate raw position before modulo

            // Check if player passes or lands on Start (index 0)
            // This logic ensures money is added if they pass the start point (index 0)
            if (targetPositionRaw >= boardPath.length && oldPositionIndex !== 0) {
                currentPlayer.money += gameState.PASS_GO_MONEY;
                alert(getTranslation('playerPassedStart', currentPlayer.name, gameState.PASS_GO_MONEY));
                showMoneyEffect(currentPlayer.userId, gameState.PASS_GO_MONEY, 'gain'); // Visual effect for money gain
                updatePlayersList(); // Update player's money display
                console.log(`[Roll Dice Debug] ${Date.now()}: Player ${currentPlayer.name} passed Start. Money: ${currentPlayer.money}`);
            }

            // Animate player token movement step by step
            for (let i = 1; i <= roll; i++) {
                const intermediatePositionIndex = (oldPositionIndex + i) % boardPath.length;
                const nextCellId = boardPath[intermediatePositionIndex];
                const nextCell = document.querySelector(`.${nextCellId}`);
                if (nextCell) {
                    // Temporarily move token to the next cell
                    nextCell.appendChild(playerToken);
                    await new Promise(resolve => setTimeout(resolve, 300)); // Short delay for animation
                }
            }

            playerToken.classList.remove('moving'); // Remove moving class after animation
            currentPlayer.positionIndex = targetPositionRaw % boardPath.length; // Update final position

            console.log(`[Roll Dice Debug] ${Date.now()}: Player ${currentPlayer.name} moved to cell: ${boardPath[currentPlayer.positionIndex]} (Index: ${currentPlayer.positionIndex}).`);

            // Handle landing on the cell
            await handleLandingOnCell(currentPlayer, boardPath[currentPlayer.positionIndex]); // Await this

            // Change button text to "END" after movement and cell action
            rollDiceButton.textContent = 'END';
            rollDiceButton.removeEventListener('click', handleRollDice); // Remove old listener
            rollDiceButton.addEventListener('click', endTurn); // Add new listener for ending turn
            checkPlayerDebtStatus(); // Check debt status after landing and potentially going into debt
            if (currentPlayer.money >= 0) { // Only start timer if not indebted
                startTurnTimer(); // Start the timer after the player has finished their action
            }
            await updateGameInFirestore(); // Update Firestore after player action
            console.log(`[Roll Dice Debug] ${Date.now()}: Roll dice sequence for ${currentPlayer.name} completed. Button changed to 'END'.`);
        }

        // Function to handle actions when a player lands on a cell
        async function handleLandingOnCell(player, cellId) {
            console.log(`[Cell Land Debug] ${Date.now()}: Player ${player.name} (ID: ${player.userId}) landed on cell: ${cellId}.`);

            const landedCellInfo = gameState.boardCellsInfo.find(cell => cell.id === cellId);

            if (!landedCellInfo) {
                console.error(`[Cell Land Error] ${Date.now()}: Landed on unknown cell: ${cellId}`);
                return; // Do not call endTurn here, rely on the "END" button
            }

            if (landedCellInfo.type === 'city' || landedCellInfo.type === 'company') {
                // Check if property is owned
                if (landedCellInfo.owner === null) {
                    // Show buy option
                    console.log(`[Cell Land Debug] ${Date.now()}: Landed on unowned property: ${landedCellInfo.content}. Displaying buy option.`);
                    await displayBuyOption(player, landedCellInfo); // Await buy option resolution
                } else if (landedCellInfo.owner !== player.userId) { // Use userId for owner comparison
                    // Property is owned by another player - handle rent
                    const ownerPlayer = gameState.players.find(p => p.userId === landedCellInfo.owner);
                    const rentAmount = landedCellInfo.rentLevels[landedCellInfo.currentUpgradeLevel]; // Use rent from current upgrade level

                    player.money -= rentAmount;
                    ownerPlayer.money += rentAmount;
                    updatePlayersList();
                    showMoneyEffect(player.userId, rentAmount, 'loss'); // Visual effect for money loss
                    showMoneyEffect(ownerPlayer.userId, rentAmount, 'gain'); // Visual effect for money gain

                    if (player.money < 0) {
                        alert(getTranslation('playerInDebt', player.name, player.money));
                        console.log(`[Cell Land Debug] ${Date.now()}: Player ${player.name} in debt. Money: ${player.money}.`);
                    } else {
                        const displayName = gameState.currentLanguage === 'ar' ? landedCellInfo.displayName_ar : landedCellInfo.displayName_en;
                        alert(getTranslation('landedOnOwned', displayName, ownerPlayer.name, rentAmount, player.name));
                        console.log(`[Cell Land Debug] ${Date.now()}: Player ${player.name} paid rent. Money: ${player.money}.`);
                    }
                    checkPlayerDebtStatus(); // Check debt status after rent payment
                } else {
                    // Landed on own property
                    const displayName = gameState.currentLanguage === 'ar' ? landedCellInfo.displayName_ar : landedCellInfo.displayName_en;
                    alert(getTranslation('landedOnOwn', displayName));
                    console.log(`[Cell Land Debug] ${Date.now()}: Player ${player.name} landed on own property.`);
                }
            } else if (landedCellInfo.type === 'corner') {
                // Handle corner actions
                if (landedCellInfo.content === "Go to Jail") {
                    alert(getTranslation('landedOnJail', player.name));
                    console.log(`[Cell Land Debug] ${Date.now()}: Player ${player.name} landed on Go to Jail.`);
                } else if (landedCellInfo.content === "Surprise") {
                    alert(getTranslation('landedOnSurprise', player.name));
                    console.log(`[Cell Land Debug] ${Date.now()}: Player ${player.name} landed on Surprise.`);
                } else if (landedCellInfo.content === "Vacation") {
                    alert(getTranslation('landedOnVacation', player.name));
                    console.log(`[Cell Land Debug] ${Date.now()}: Player ${player.name} landed on Vacation.`);
                } else if (landedCellInfo.content === "Start") {
                    // Player already gets money for passing/landing on start
                    console.log(`[Cell Land Debug] ${Date.now()}: Player ${player.name} landed on Start.`);
                }
            } else {
                // Other types of cells (e.g., tax, bonus cards - future expansion)
                alert(getTranslation('landedOnMisc', gameState.currentLanguage === 'ar' ? landedCellInfo.displayName_ar : landedCellInfo.displayName_en));
                console.log(`[Cell Land Debug] ${Date.now()}: Player ${player.name} landed on miscellaneous cell: ${landedCellInfo.content}.`);
            }
            // IMPORTANT: Do NOT call endTurn() here. The "END" button handles turn progression.
        }

        // Function to display the buy property modal
        async function displayBuyOption(player, property) {
            const buyModal = document.getElementById('buyPropertyModal');
            const modalTitle = document.getElementById('propertyModalTitle');
            const modalPrice = document.getElementById('propertyModalPrice');
            const playerMoneyDisplay = document.getElementById('playerCurrentMoney');
            const buyButton = document.getElementById('buyPropertyBtn');
            const cancelButton = document.getElementById('cancelBuyBtn');

            const displayName = gameState.currentLanguage === 'ar' ? property.displayName_ar : property.displayName_en;
            modalTitle.textContent = getTranslation('buyPropertyQuestion', displayName);
            modalPrice.textContent = `$${property.price}`;
            playerMoneyDisplay.textContent = `$${player.money}`;

            buyModal.classList.remove('hidden');
            console.log(`[Buy Option Debug] ${Date.now()}: Buy property modal displayed for: ${displayName}. Player: ${player.name}.`);

            return new Promise(resolve => {
                // Clear previous listeners to prevent multiple bindings
                buyButton.onclick = null;
                cancelButton.onclick = null;

                buyButton.onclick = async () => {
                    if (player.money >= property.price) {
                        player.money -= property.price;
                        property.owner = player.userId; // Assign owner userId
                        gameState.boardProperties[property.id] = { // Store ownership in gameState
                            id: property.id,
                            content: property.content, // Use content for property name
                            price: property.price, // Store original purchase price
                            ownerId: player.userId,
                            currentUpgradeLevel: property.currentUpgradeLevel // Store initial upgrade level
                        };

                        // Find the cell element to update its color bar
                        const cellElement = document.querySelector(`.${property.id}`);
                        if (cellElement) {
                            updateBoardCellDisplay(cellElement, property); // Update the cell display after purchase
                        }


                        updatePlayersList();
                        updateMyPropertiesList();
                        alert(getTranslation('playerBought', player.name, displayName, property.price));
                        showMoneyEffect(player.userId, property.price, 'loss'); // Visual effect for money loss
                        buyModal.classList.add('hidden');
                        console.log(`[Buy Option Debug] ${Date.now()}: Player ${player.name} bought ${property.content}. Money: ${player.money}.`);
                    } else {
                        // Allow buying with negative money, but player becomes indebted
                        player.money -= property.price;
                        property.owner = player.userId;
                        gameState.boardProperties[property.id] = {
                            id: property.id,
                            content: property.content,
                            price: property.price,
                            ownerId: player.userId,
                            currentUpgradeLevel: property.currentUpgradeLevel
                        };

                        const cellElement = document.querySelector(`.${property.id}`);
                        if (cellElement) {
                            updateBoardCellDisplay(cellElement, property);
                        }

                        updatePlayersList();
                        updateMyPropertiesList();
                        alert(getTranslation('playerInDebt', player.name, player.money));
                        showMoneyEffect(player.userId, property.price, 'loss');
                        buyModal.classList.add('hidden');
                        console.log(`[Buy Option Debug] ${Date.now()}: Player ${player.name} bought ${property.content} and went into debt. Money: ${player.money}.`);
                    }
                    checkPlayerDebtStatus(); // Check debt status after purchase
                    await updateGameInFirestore(); // Update Firestore
                    resolve(); // Resolve the promise
                };

                cancelButton.onclick = async () => {
                    buyModal.classList.add('hidden');
                    alert(getTranslation('playerPassed', player.name, displayName));
                    console.log(`[Buy Option Debug] ${Date.now()}: Player ${player.name} passed on ${property.content}.`);
                    checkPlayerDebtStatus(); // Check debt status (in case they were already indebted)
                    await updateGameInFirestore(); // Update Firestore
                    resolve(); // Resolve the promise
                };
            });
        }

        // Function to check if a player owns all cities of a specific country
        function checkCountryOwnership(player, country) {
            const countryCities = gameState.boardCellsInfo.filter(cell => cell.type === 'city' && cell.country === country);
            if (countryCities.length === 0) {
                return false; // No cities for this country defined
            }
            return countryCities.every(city => gameState.boardProperties[city.id] && gameState.boardProperties[city.id].ownerId === player.userId);
        }

        // Function to display property details modal
        function displayPropertyDetails(cellId) {
            const propertyDetailsModal = document.getElementById('propertyDetailsModal');
            const propertyDetailIcon = document.getElementById('propertyDetailIcon');
            const propertyDetailName = document.getElementById('propertyDetailName');
            const propertyDetailPrice = document.getElementById('propertyDetailPrice');
            const propertyRentLevelsList = document.getElementById('propertyRentLevels');
            const currentUpgradeLevelDisplay = document.getElementById('currentUpgradeLevelDisplay');
            const upgradePropertyBtn = document.getElementById('upgradePropertyBtn');
            const downgradePropertyBtn = document.getElementById('downgradePropertyBtn');
            const upgradeCostText = document.getElementById('upgradeCostText'); // New span for upgrade cost
            const downgradeRefundText = document.getElementById('downgradeRefundText'); // New span for downgrade refund
            const upgradeSection = document.getElementById('upgradeSection');

            const property = gameState.boardCellsInfo.find(cell => cell.id === cellId);
            const currentPlayer = gameState.players.find(p => p.userId === currentUserId);

            if (!property) {
                console.error("Property not found for details:", cellId);
                return;
            }

            // Populate modal content
            const displayName = gameState.currentLanguage === 'ar' ? property.displayName_ar : property.displayName_en;
            propertyDetailName.textContent = displayName; // Use displayName for modal title
            propertyDetailPrice.textContent = `$${property.price}`;

            // Set icon (flag or emoji)
            if (property.type === 'city') {
                propertyDetailIcon.innerHTML = getCountryFlagImage(property.country); // Still use country flag for property details modal
            } else if (property.type === 'company') {
                propertyDetailIcon.innerHTML = `<span class="text-3xl">${getCompanyEmoji(property.content)}</span>`;
            }

            // Populate rent levels
            propertyRentLevelsList.innerHTML = '';
            let rentLevelLabels;
            if (property.type === 'city') {
                rentLevelLabels = [getTranslation("baseRent"), `${getTranslation("level")} 1`, `${getTranslation("level")} 2`, `${getTranslation("level")} 3`, `${getTranslation("level")} 4`];
            } else if (property.type === 'company') {
                rentLevelLabels = [getTranslation("baseRent")]; // Only base rent for companies
            } else {
                rentLevelLabels = [getTranslation("baseRent"), `${getTranslation("level")} 1`, `${getTranslation("level")} 2`, `${getTranslation("level")} 3`, `${getTranslation("level")} 4`]; // Fallback
            }

            property.rentLevels.forEach((rent, index) => {
                const listItem = document.createElement('li');
                listItem.classList.add('rent-level-item');
                if (index === property.currentUpgradeLevel) {
                    listItem.classList.add('current-rent');
                }
                listItem.innerHTML = `<span>${rentLevelLabels[index]}:</span> <span>$${rent}</span>`;
                propertyRentLevelsList.appendChild(listItem);
            });

            // Show upgrade section only if owned by current player and it's a city
            if (property.owner === currentPlayer.userId && property.type === 'city') {
                upgradeSection.classList.remove('hidden');
                currentUpgradeLevelDisplay.textContent = `${getTranslation('level')} ${property.currentUpgradeLevel}`; // Display "Level X"

                const ownsAllCountryCities = checkCountryOwnership(currentPlayer, property.country);

                // Calculate and display next upgrade cost
                if (property.currentUpgradeLevel < property.rentLevels.length - 1 && ownsAllCountryCities) {
                    const nextRentLevelValue = property.rentLevels[property.currentUpgradeLevel + 1];
                    const upgradeCost = roundToNearestFive(nextRentLevelValue * 0.5); // 50% of the next rent price, rounded to nearest 5
                    upgradeCostText.textContent = `$${upgradeCost}`;
                    upgradePropertyBtn.disabled = currentPlayer.money < upgradeCost;
                } else {
                    upgradeCostText.textContent = getTranslation("max"); // Indicate max level
                    upgradePropertyBtn.disabled = true;
                }

                // Calculate and display downgrade refund amount
                if (property.currentUpgradeLevel > 0) {
                    const currentRentLevelValue = property.rentLevels[property.currentUpgradeLevel];
                    const refundedAmount = roundToNearestFive(currentRentLevelValue * 0.5); // Refund 50% of current level rent, rounded to nearest 5
                    downgradeRefundText.textContent = `$${refundedAmount}`;
                    downgradePropertyBtn.disabled = false;
                } else {
                    downgradeRefundText.textContent = getTranslation("min"); // Indicate min level
                    downgradePropertyBtn.disabled = true;
                }

                // Re-attach listeners to prevent multiple bindings
                upgradePropertyBtn.onclick = () => handleUpgradeProperty(property.id);
                downgradePropertyBtn.onclick = () => handleDowngradeProperty(property.id);

            } else {
                upgradeSection.classList.add('hidden'); // Hide upgrade section if not owned by current player or if it's a company
            }

            propertyDetailsModal.classList.remove('hidden');
            console.log(`[Property Details Debug] ${Date.now()}: Property details modal displayed for: ${displayName}.`);
        }

        // Handle property upgrade
        async function handleUpgradeProperty(propertyId) {
            const property = gameState.boardCellsInfo.find(cell => cell.id === propertyId);
            const currentPlayer = gameState.players.find(p => p.userId === currentUserId);

            if (!property || property.owner !== currentPlayer.userId || property.type !== 'city') { // Ensure it's a city owned by current player
                alert(getTranslation("notOwnedOrExists"));
                console.warn(`[Upgrade Debug] ${Date.now()}: Upgrade failed. Not owned by current player or not a city.`);
                return;
            }

            const ownsAllCountryCities = checkCountryOwnership(currentPlayer, property.country);
            if (!ownsAllCountryCities) {
                alert(getTranslation('mustOwnAllCities', property.country));
                console.warn(`[Upgrade Debug] ${Date.now()}: Upgrade failed. Does not own all cities in country.`);
                return;
            }

            if (property.currentUpgradeLevel >= property.rentLevels.length - 1) { // Check against rentLevels length
                alert(getTranslation("maxLevel"));
                console.warn(`[Upgrade Debug] ${Date.now()}: Upgrade failed. Max level reached.`);
                return;
            }

            const nextRentLevelValue = property.rentLevels[property.currentUpgradeLevel + 1];
            const upgradeCost = roundToNearestFive(nextRentLevelValue * 0.5); // 50% of the next rent price, rounded to nearest 5

            if (currentPlayer.money < upgradeCost) {
                alert(getTranslation("notEnoughMoney"));
                console.warn(`[Upgrade Debug] ${Date.now()}: Upgrade failed. Insufficient money.`);
                return;
            }

            currentPlayer.money -= upgradeCost;
            property.currentUpgradeLevel++;

            // Update the property in gameState.boardProperties as well
            if (gameState.boardProperties[property.id]) {
                gameState.boardProperties[property.id].currentUpgradeLevel = property.currentUpgradeLevel;
            }

            updatePlayersList();
            updateMyPropertiesList(); // This might not show upgrade level, but good to call
            displayPropertyDetails(propertyId); // Re-display modal to update info

            const cellElement = document.querySelector(`.${property.id}`);
            if (cellElement) {
                updateBoardCellDisplay(cellElement, property); // Update the cell display after upgrade
            }

            const displayName = gameState.currentLanguage === 'ar' ? property.displayName_ar : property.displayName_en;
            alert(getTranslation('playerUpgraded', currentPlayer.name, displayName, property.currentUpgradeLevel));
            showMoneyEffect(currentPlayer.userId, upgradeCost, 'loss'); // Visual effect for money loss
            checkPlayerDebtStatus(); // Check debt status after upgrade
            await updateGameInFirestore(); // Update Firestore
            console.log(`[Upgrade Debug] ${Date.now()}: Player ${currentPlayer.name} upgraded ${property.content} to level ${property.currentUpgradeLevel}. Cost: $${upgradeCost}. Money: ${currentPlayer.money}.`);
        }

        // Handle property downgrade
        async function handleDowngradeProperty(propertyId) {
            const property = gameState.boardCellsInfo.find(cell => cell.id === propertyId);
            const currentPlayer = gameState.players.find(p => p.userId === currentUserId);

            if (!property || property.owner !== currentPlayer.userId || property.type !== 'city') { // Ensure it's a city owned by current player
                alert(getTranslation("notOwnedOrExists"));
                console.warn(`[Downgrade Debug] ${Date.now()}: Downgrade failed. Not owned by current player or not a city.`);
                return;
            }

            if (property.currentUpgradeLevel <= 0) {
                alert(getTranslation("minLevel"));
                console.warn(`[Downgrade Debug] ${Date.now()}: Downgrade failed. Already at min level.`);
                return;
            }

            // Refund half the cost of the last upgrade (which was 50% of the rent of the level it's downgrading *from*)
            const currentRentLevelValue = property.rentLevels[property.currentUpgradeLevel];
            const refundedAmount = roundToNearestFive(currentRentLevelValue * 0.5); // Refund 50% of current level rent, rounded to nearest 5

            currentPlayer.money += refundedAmount;
            property.currentUpgradeLevel--;

            // Update the property in gameState.boardProperties as well
            if (gameState.boardProperties[property.id]) {
                gameState.boardProperties[property.id].currentUpgradeLevel = property.currentUpgradeLevel;
            }

            updatePlayersList();
            updateMyPropertiesList();
            displayPropertyDetails(propertyId); // Re-display modal to update info

            const cellElement = document.querySelector(`.${property.id}`);
            if (cellElement) {
                updateBoardCellDisplay(cellElement, property); // Update the cell display after downgrade
            }

            const displayName = gameState.currentLanguage === 'ar' ? property.displayName_ar : property.displayName_en;
            alert(getTranslation('playerDowngraded', currentPlayer.name, displayName, refundedAmount, property.currentUpgradeLevel));
            showMoneyEffect(currentPlayer.userId, refundedAmount, 'gain'); // Visual effect for money gain
            checkPlayerDebtStatus(); // Check debt status after downgrade
            await updateGameInFirestore(); // Update Firestore
            console.log(`[Downgrade Debug] ${Date.now()}: Player ${currentPlayer.name} downgraded ${property.content} to level ${property.currentUpgradeLevel}. Refunded: $${refundedAmount}. Money: ${currentPlayer.money}.`);
        }


        // Function to end the current player's turn and switch to the next
        async function endTurn() {
            const rollDiceButton = document.getElementById('rollDiceButton');
            const currentPlayer = gameState.players.find(p => p.userId === currentUserId); // Ensure current player is the one whose turn it is

            console.log(`[End Turn Debug] ${Date.now()}: endTurn called for ${currentPlayer?.name || 'unknown player'} (ID: ${currentPlayer?.userId}). Money: ${currentPlayer?.money}.`);

            // Check if the current player is indebted (money is negative)
            if (currentPlayer.money < 0) {
                alert(getTranslation('playerInDebt', currentPlayer.name, currentPlayer.money));
                // Keep the button as "END" and disabled
                rollDiceButton.textContent = 'END';
                rollDiceButton.disabled = true;
                // Re-attach the endTurn listener to itself so it remains in the 'END' state
                rollDiceButton.removeEventListener('click', handleRollDice); // Ensure handleRollDice is removed
                rollDiceButton.removeEventListener('click', endTurn); // Remove existing endTurn listener
                rollDiceButton.addEventListener('click', endTurn); // Re-add endTurn listener
                console.log(`[End Turn Debug] ${Date.now()}: Player ${currentPlayer.name} is in debt. Cannot end turn.`);
                return; // Prevent ending the turn
            }

            // If not indebted, proceed with ending the turn
            resetTurnTimer(); // Stop the timer for the current player
            rollDiceButton.textContent = getTranslation('play');
            rollDiceButton.removeEventListener('click', endTurn);
            rollDiceButton.addEventListener('click', handleRollDice);
            rollDiceButton.disabled = false;

            gameState.currentPlayerIndex = (gameState.currentPlayerIndex + 1) % gameState.players.length;
            const nextPlayer = gameState.players[gameState.currentPlayerIndex];
            alert(getTranslation('turnEnded', currentPlayer.name, nextPlayer.name));
            console.log(`[End Turn Debug] ${Date.now()}: Turn ended for ${currentPlayer.name}. It's now ${nextPlayer.name}'s turn (ID: ${nextPlayer.userId}). New current player index: ${gameState.currentPlayerIndex}.`);
            updatePlayersList(); // Re-render to update money display and highlight
            updateMyPropertiesList(); // Update properties for the new current player
            checkPlayerDebtStatus(); // Check next player's debt status to disable button if needed

            // Start the timer for the next player
            startTurnTimer();
            await updateGameInFirestore(); // Update Firestore
        }

        // --- Trade System Functions ---

        /**
         * Populates the requested properties list based on the selected recipient.
         * @param {string} recipientUserId - The userId of the player whose properties are to be listed.
         */
        function updateRequestedPropertiesForRecipient(recipientUserId) {
            const requestedPropertiesList = document.getElementById('requestedPropertiesList');
            requestedPropertiesList.innerHTML = ''; // Clear current list

            const recipientProperties = Object.values(gameState.boardProperties).filter(prop => prop.ownerId === recipientUserId);

            if (recipientProperties.length > 0) {
                recipientProperties.forEach(prop => {
                    const listItem = document.createElement('div');
                    listItem.className = 'flex items-center gap-2';
                    const originalCell = gameState.boardCellsInfo.find(cell => cell.id === prop.id);
                    let iconHtml = '';
                    let displayName = '';
                    if (originalCell) {
                        displayName = gameState.currentLanguage === 'ar' ? originalCell.displayName_ar : originalCell.displayName_en;
                        if (originalCell.type === 'city') {
                            iconHtml = `${getCountryFlagImage(originalCell.country)}`;
                        } else if (originalCell.type === 'company') {
                            iconHtml = `<span class="text-lg">${getCompanyEmoji(originalCell.content)}</span>`;
                        }
                    }

                    // Modified: Wrap icon and text in a flex div within the label
                    listItem.innerHTML = `
                        <input type="checkbox" id="request-prop-${prop.id}" value="${prop.id}" class="form-checkbox h-4 w-4 text-purple-600">
                        <label for="request-prop-${prop.id}" class="text-gray-300 text-sm flex items-center gap-1">
                            ${iconHtml} <span>${displayName}</span>
                        </label>
                    `;
                    requestedPropertiesList.appendChild(listItem);
                });
            } else {
                const p = document.createElement('p');
                p.classList.add('text-gray-400');
                p.textContent = getTranslation('noPropertiesToRequest');
                requestedPropertiesList.appendChild(p);
            }
        }

        /**
         * Opens the trade creation modal, populating it with available options.
         * @param {string} senderPlayerUserId - The userId of the player initiating the trade.
         * @param {object} [existingOffer=null] - Optional: An existing trade offer object to pre-fill the modal for modification.
         */
        function openTradeCreationModal(senderPlayerUserId, existingOffer = null) {
            const tradeCreationModal = document.getElementById('tradeCreationModal');
            const tradeRecipientSelect = document.getElementById('tradeRecipient');
            const offeredPropertiesList = document.getElementById('offeredPropertiesList');
            const offerMoneyInput = document.getElementById('offerMoney');
            const requestMoneyInput = document.getElementById('requestMoney');
            const tradeOfferIdToModify = document.getElementById('tradeOfferIdToModify');

            const currentPlayer = gameState.players.find(p => p.userId === senderPlayerUserId);

            if (!currentPlayer) {
                console.error("Sender player not found for trade:", senderPlayerUserId);
                return;
            }

            // Clear previous selections/inputs
            offerMoneyInput.value = 0;
            requestMoneyInput.value = 0;
            offeredPropertiesList.innerHTML = '';
            tradeRecipientSelect.innerHTML = '';
            tradeOfferIdToModify.value = ''; // Clear ID for new offers

            // Populate trade recipient dropdown (all players except the sender)
            const otherPlayers = gameState.players.filter(p => p.userId !== senderPlayerUserId);
            if (otherPlayers.length === 0) {
                alert(getTranslation("noOtherPlayers")); // Assuming a translation key for this
                tradeCreationModal.classList.add('hidden');
                return;
            }

            otherPlayers.forEach(player => {
                const option = document.createElement('option');
                option.value = player.userId;
                option.textContent = player.name;
                tradeRecipientSelect.appendChild(option);
            });

            // Set up the change listener for the recipient dropdown
            tradeRecipientSelect.onchange = (event) => {
                const selectedRecipientId = event.target.value;
                updateRequestedPropertiesForRecipient(selectedRecipientId);
            };

            // Populate offered properties (current player's properties)
            const senderProperties = Object.values(gameState.boardProperties).filter(prop => prop.ownerId === senderPlayerUserId);
            if (senderProperties.length > 0) {
                senderProperties.forEach(prop => {
                    const listItem = document.createElement('div');
                    listItem.className = 'flex items-center gap-2';
                    const originalCell = gameState.boardCellsInfo.find(cell => cell.id === prop.id);
                    let iconHtml = '';
                    let displayName = '';
                    if (originalCell) {
                        displayName = gameState.currentLanguage === 'ar' ? originalCell.displayName_ar : originalCell.displayName_en;
                        if (originalCell.type === 'city') {
                            iconHtml = `${getCountryFlagImage(originalCell.country)}`;
                        } else if (originalCell.type === 'company') {
                            iconHtml = `<span class="text-lg">${getCompanyEmoji(originalCell.content)}</span>`;
                        }
                    }

                    // Modified: Wrap icon and text in a flex div within the label
                    listItem.innerHTML = `
                        <input type="checkbox" id="offer-prop-${prop.id}" value="${prop.id}" class="form-checkbox h-4 w-4 text-purple-600">
                        <label for="offer-prop-${prop.id}" class="text-gray-300 text-sm flex items-center gap-1">
                            ${iconHtml} <span>${displayName}</span>
                        </label>
                    `;
                    offeredPropertiesList.appendChild(listItem);
                });
            } else {
                const p = document.createElement('p');
                p.classList.add('text-gray-400');
                p.textContent = getTranslation('noPropertiesToOffer');
                offeredPropertiesList.appendChild(p);
            }

            // If an existing offer is provided, pre-fill the modal
            if (existingOffer) {
                tradeCreationModal.querySelector('h3').textContent = getTranslation('modifyTradeOffer'); // Assuming this key
                tradeOfferIdToModify.value = existingOffer.offerId;
                offerMoneyInput.value = existingOffer.offeredMoney;
                requestMoneyInput.value = existingOffer.requestedMoney;

                // Select recipient
                tradeRecipientSelect.value = existingOffer.recipientId;

                // Check offered properties
                existingOffer.offeredProperties.forEach(propId => {
                    const checkbox = document.getElementById(`offer-prop-${propId}`);
                    if (checkbox) checkbox.checked = true;
                });

                // Update requested properties for the selected recipient and then check them
                updateRequestedPropertiesForRecipient(existingOffer.recipientId);
                setTimeout(() => { // Small delay to ensure properties are rendered
                    existingOffer.requestedProperties.forEach(propId => {
                        const checkbox = document.getElementById(`request-prop-${propId}`);
                        if (checkbox) checkbox.checked = true;
                    });
                }, 50);

            } else {
                tradeCreationModal.querySelector('h3').textContent = getTranslation('createTradeOffer');
                // Populate requested properties for the initially selected recipient (only for new offers)
                if (tradeRecipientSelect.value) {
                    updateRequestedPropertiesForRecipient(tradeRecipientSelect.value);
                }
            }

            tradeCreationModal.classList.remove('hidden');
            console.log(`[Trade Debug] ${Date.now()}: Trade creation modal opened for sender ${senderPlayerUserId}. Existing offer: ${existingOffer ? 'yes' : 'no'}.`);
        }

        /**
         * Sends the trade offer based on the values in the trade creation modal.
         */
        async function sendTradeOffer() {
            const senderPlayer = gameState.players.find(p => p.userId === currentUserId); // The current user is the sender
            const recipientId = document.getElementById('tradeRecipient').value;
            const offeredMoney = parseInt(document.getElementById('offerMoney').value);
            const requestedMoney = parseInt(document.getElementById('requestMoney').value);
            const tradeOfferId = document.getElementById('tradeOfferIdToModify').value; // Get ID if modifying

            const offeredProperties = Array.from(document.querySelectorAll('#offeredPropertiesList input:checked')).map(cb => cb.value);
            const requestedProperties = Array.from(document.querySelectorAll('#requestedPropertiesList input:checked')).map(cb => cb.value);

            if (!recipientId) {
                alert(getTranslation("selectRecipient"));
                console.warn(`[Trade Debug] ${Date.now()}: Send trade failed: No recipient selected.`);
                return;
            }

            if (offeredMoney <= 0 && requestedMoney <= 0 && offeredProperties.length === 0 && requestedProperties.length === 0) {
                alert(getTranslation("specifyItems"));
                console.warn(`[Trade Debug] ${Date.now()}: Send trade failed: No items specified.`);
                return;
            }

            // Validate offered money
            if (offeredMoney > senderPlayer.money) {
                alert(getTranslation("insufficientMoneyOffer"));
                console.warn(`[Trade Debug] ${Date.now()}: Send trade failed: Insufficient money offered by sender.`);
                return;
            }

            // Validate offered properties are actually owned by sender
            const invalidOfferedProps = offeredProperties.filter(propId =>
                !gameState.boardProperties[propId] || gameState.boardProperties[propId].ownerId !== senderPlayer.userId
            );
            if (invalidOfferedProps.length > 0) {
                alert(getTranslation("onlyOwnProperties"));
                console.warn(`[Trade Debug] ${Date.now()}: Send trade failed: Invalid offered properties.`);
                return;
            }

            // Validate requested properties are actually owned by recipient
            const invalidRequestedProps = requestedProperties.filter(propId =>
                !gameState.boardProperties[propId] || gameState.boardProperties[propId].ownerId !== recipientId
            );
            if (invalidRequestedProps.length > 0) {
                alert(getTranslation("onlyRequestOwned"));
                console.warn(`[Trade Debug] ${Date.now()}: Send trade failed: Invalid requested properties.`);
                return;
            }

            const newTradeOffer = {
                offerId: tradeOfferId ? tradeOfferId : Date.now().toString(), // Reuse ID if modifying, otherwise new ID
                senderId: senderPlayer.userId,
                recipientId: recipientId,
                offeredMoney: offeredMoney,
                offeredProperties: offeredProperties,
                requestedMoney: requestedMoney,
                requestedProperties: requestedProperties,
                status: "pending"
            };

            // If modifying, remove the old offer before adding the new one
            if (tradeOfferId) {
                gameState.pendingTradeOffers = gameState.pendingTradeOffers.filter(o => o.offerId !== tradeOfferId);
                console.log(`[Trade Debug] ${Date.now()}: Modifying existing trade offer ID: ${tradeOfferId}.`);
            }

            gameState.pendingTradeOffers.push(newTradeOffer);
            document.getElementById('tradeCreationModal').classList.add('hidden');
            alert(getTranslation('offerSent', gameState.players.find(p => p.userId === recipientId).name));
            console.log(`[Trade Debug] ${Date.now()}: Trade offer sent. Offer details:`, newTradeOffer);

            await updateGameInFirestore(); // Update Firestore
            updatePendingTradesList(); // Update the public list

            // Immediately display the offer to the recipient if it's their turn or they are the current player
            if (gameState.players[gameState.currentPlayerIndex].userId === recipientId) {
                displayIncomingTradeOffer(newTradeOffer);
            }
        }

        /**
         * Displays an incoming trade offer to the recipient.
         * @param {object} offer - The trade offer object.
         */
        function displayIncomingTradeOffer(offer) {
            const incomingTradeOfferModal = document.getElementById('incomingTradeOfferModal');
            const offerSenderName = document.getElementById('offerSenderName');
            const offerReceivedMoney = document.getElementById('offerReceivedMoney');
            const offerReceivedProperties = document.getElementById('offerReceivedProperties');
            const requestSentMoney = document.getElementById('requestSentMoney');
            const requestSentProperties = document.getElementById('requestSentProperties');

            const sender = gameState.players.find(p => p.userId === offer.senderId);
            if (!sender) {
                console.error(`[Trade Debug] ${Date.now()}: Sender not found for incoming trade offer.`);
                return;
            }

            gameState.currentActiveTradeOffer = offer; // Store the active offer
            console.log(`[Trade Debug] ${Date.now()}: Displaying incoming trade offer from ${sender.name} (ID: ${sender.userId}). Offer ID: ${offer.offerId}.`);

            // Remove flag from sender name in incoming trade modal
            offerSenderName.textContent = sender.name;
            offerReceivedMoney.textContent = offer.offeredMoney;
            requestSentMoney.textContent = offer.requestedMoney;

            offerReceivedProperties.innerHTML = '';
            if (offer.offeredProperties.length > 0) {
                offer.offeredProperties.forEach(propId => {
                    const prop = gameState.boardCellsInfo.find(cell => cell.id === propId);
                    if (prop) {
                        const listItem = document.createElement('li');
                        listItem.classList.add('flex', 'items-center', 'gap-1'); // Added flex for horizontal alignment
                        let iconHtml = '';
                        let displayName = '';
                        if (prop.type === 'city') {
                            iconHtml = `${getCountryFlagImage(prop.country)}`;
                            displayName = gameState.currentLanguage === 'ar' ? prop.displayName_ar : prop.displayName_en;
                        } else if (prop.type === 'company') {
                            iconHtml = `<span class="text-lg">${getCompanyEmoji(prop.content)}</span>`;
                            displayName = gameState.currentLanguage === 'ar' ? prop.displayName_ar : prop.displayName_en;
                        }
                        listItem.innerHTML = `${iconHtml} <span>${displayName}</span>`; // Wrapped text in span
                        offerReceivedProperties.appendChild(listItem);
                    }
                });
            } else {
                offerReceivedProperties.innerHTML = `<li>${getTranslation('none')}</li>`;
            }

            requestSentProperties.innerHTML = '';
            if (offer.requestedProperties.length > 0) {
                offer.requestedProperties.forEach(propId => {
                    const prop = gameState.boardCellsInfo.find(cell => cell.id === propId);
                    if (prop) {
                        const listItem = document.createElement('li');
                        listItem.classList.add('flex', 'items-center', 'gap-1'); // Added flex for horizontal alignment
                        let iconHtml = '';
                        let displayName = '';
                        if (prop.type === 'city') {
                            iconHtml = `${getCountryFlagImage(prop.country)}`;
                            displayName = gameState.currentLanguage === 'ar' ? prop.displayName_ar : prop.displayName_en;
                        } else if (prop.type === 'company') {
                            iconHtml = `<span class="text-lg">${getCompanyEmoji(prop.content)}</span>`;
                            displayName = gameState.currentLanguage === 'ar' ? prop.displayName_ar : prop.displayName_en;
                        }
                        listItem.innerHTML = `${iconHtml} <span>${displayName}</span>`; // Wrapped text in span
                        requestSentProperties.appendChild(listItem);
                    }
                });
            } else {
                requestSentProperties.innerHTML = `<li>${getTranslation('none')}</li>`;
            }

            incomingTradeOfferModal.classList.remove('hidden');
        }

        /**
         * Handles the acceptance of the current active trade offer.
         */
        async function acceptTrade() {
            const offer = gameState.currentActiveTradeOffer;
            if (!offer) {
                console.error(`[Trade Debug] ${Date.now()}: No active trade offer to accept.`);
                return;
            }

            const sender = gameState.players.find(p => p.userId === offer.senderId);
            const recipient = gameState.players.find(p => p.userId === offer.recipientId);

            if (!sender || !recipient) {
                alert(getTranslation("tradeError"));
                console.error(`[Trade Debug] ${Date.now()}: Accept trade failed: Sender or recipient not found.`);
                return;
            }

            // Check if sender has enough money to offer
            if (sender.money < offer.offeredMoney) {
                alert(getTranslation('senderInsufficientMoney', sender.name));
                console.warn(`[Trade Debug] ${Date.now()}: Accept trade failed: Sender (${sender.name}) insufficient money.`);
                declineTrade(); // Automatically decline if sender can't pay
                return;
            }

            // Check if recipient has enough money to pay what's requested
            if (recipient.money < offer.requestedMoney) {
                alert(getTranslation('recipientInsufficientMoney', recipient.name));
                console.warn(`[Trade Debug] ${Date.now()}: Accept trade failed: Recipient (${recipient.name}) insufficient money.`);
                return; // Recipient can't accept if they don't have enough money
            }

            // Check if sender still owns the properties they are offering
            const senderMissingProps = offer.offeredProperties.filter(propId =>
                !gameState.boardProperties[propId] || gameState.boardProperties[propId].ownerId !== sender.userId
            );
            if (senderMissingProps.length > 0) {
                alert(getTranslation('senderMissingProps', sender.name));
                console.warn(`[Trade Debug] ${Date.now()}: Accept trade failed: Sender (${sender.name}) missing offered properties.`);
                declineTrade();
                return;
            }

            // Check if recipient still owns the properties being requested from them
            const recipientMissingProps = offer.requestedProperties.filter(propId =>
                !gameState.boardProperties[propId] || gameState.boardProperties[propId].ownerId !== recipient.userId
            );
            if (recipientMissingProps.length > 0) {
                alert(getTranslation('recipientMissingProps', recipient.name));
                console.warn(`[Trade Debug] ${Date.now()}: Accept trade failed: Recipient (${recipient.name}) missing requested properties.`);
                return; // Recipient can't accept if they don't own requested properties
            }


            // Perform money transfer
            sender.money -= offer.offeredMoney;
            recipient.money += offer.offeredMoney;
            showMoneyEffect(sender.userId, offer.offeredMoney, 'loss');
            showMoneyEffect(recipient.userId, offer.offeredMoney, 'gain');
            console.log(`[Trade Debug] ${Date.now()}: Money transfer: ${sender.name} paid $${offer.offeredMoney} to ${recipient.name}.`);


            sender.money += offer.requestedMoney;
            recipient.money -= offer.requestedMoney;
            showMoneyEffect(sender.userId, offer.requestedMoney, 'gain');
            showMoneyEffect(recipient.userId, offer.requestedMoney, 'loss');
            console.log(`[Trade Debug] ${Date.now()}: Money transfer: ${recipient.name} paid $${offer.requestedMoney} to ${sender.name}.`);


            // Perform property transfer
            offer.offeredProperties.forEach(propId => {
                const prop = gameState.boardCellsInfo.find(cell => cell.id === propId);
                if (prop) {
                    prop.owner = recipient.userId;
                    gameState.boardProperties[propId].ownerId = recipient.userId;
                    // Update property color bar on the board
                    const cellElement = document.querySelector(`.${prop.id}`);
                    if (cellElement) {
                        updateBoardCellDisplay(cellElement, prop);
                    }
                    console.log(`[Trade Debug] ${Date.now()}: Property ${prop.content} transferred from ${sender.name} to ${recipient.name}.`);
                }
            });

            offer.requestedProperties.forEach(propId => {
                const prop = gameState.boardCellsInfo.find(cell => cell.id === propId);
                if (prop) {
                    prop.owner = sender.userId;
                    gameState.boardProperties[propId].ownerId = sender.userId;
                    // Update property color bar on the board
                    const cellElement = document.querySelector(`.${prop.id}`);
                    if (cellElement) {
                        updateBoardCellDisplay(cellElement, prop);
                    }
                    console.log(`[Trade Debug] ${Date.now()}: Property ${prop.content} transferred from ${recipient.name} to ${sender.name}.`);
                }
            });

            // Remove the offer from pending offers
            gameState.pendingTradeOffers = gameState.pendingTradeOffers.filter(o => o.offerId !== offer.offerId);
            gameState.currentActiveTradeOffer = null; // Clear active offer

            document.getElementById('incomingTradeOfferModal').classList.add('hidden');
            document.getElementById('tradeDetailsViewModal').classList.add('hidden'); // Hide if open
            alert(getTranslation('tradeAccepted', sender.name, recipient.name));
            console.log(`[Trade Debug] ${Date.now()}: Trade offer ID ${offer.offerId} accepted.`);
            updatePlayersList();
            updateMyPropertiesList(); // Update properties list for both players
            updatePendingTradesList(); // Update the public list
            checkPlayerDebtStatus(); // Check debt status after trade
            await updateGameInFirestore(); // Update Firestore
        }

        /**
         * Handles the decline of the current active trade offer.
         */
        async function declineTrade() {
            const offer = gameState.currentActiveTradeOffer;
            if (!offer) {
                console.error(`[Trade Debug] ${Date.now()}: No active trade offer to decline.`);
                return;
            }

            const sender = gameState.players.find(p => p.userId === offer.senderId);
            const recipient = gameState.players.find(p => p.userId === offer.recipientId);

            gameState.pendingTradeOffers = gameState.pendingTradeOffers.filter(o => o.offerId !== offer.offerId);
            gameState.currentActiveTradeOffer = null; // Clear active offer

            document.getElementById('incomingTradeOfferModal').classList.add('hidden');
            document.getElementById('tradeDetailsViewModal').classList.add('hidden'); // Hide if open
            alert(getTranslation('tradeDeclined', sender.name, recipient.name));
            console.log(`[Trade Debug] ${Date.now()}: Trade offer ID ${offer.offerId} declined.`);
            await updateGameInFirestore(); // Update Firestore
            updatePendingTradesList(); // Update the public list
            checkPlayerDebtStatus(); // Check debt status after trade
        }

        /**
         * Handles the cancellation of a trade offer by the sender.
         * @param {string} offerId - The ID of the trade offer to cancel.
         */
        async function cancelTrade(offerId) {
            const offerIndex = gameState.pendingTradeOffers.findIndex(o => o.offerId === offerId);
            if (offerIndex > -1) {
                const cancelledOffer = gameState.pendingTradeOffers.splice(offerIndex, 1)[0];
                const sender = gameState.players.find(p => p.userId === cancelledOffer.senderId);
                const recipient = gameState.players.find(p => p.userId === cancelledOffer.recipientId);
                alert(getTranslation('tradeCancelled', sender.name, recipient.name));
                gameState.currentActiveTradeOffer = null; // Clear active offer if it was the one cancelled
                document.getElementById('tradeDetailsViewModal').classList.add('hidden'); // Hide if open
                console.log(`[Trade Debug] ${Date.now()}: Trade offer ID ${offerId} cancelled by sender.`);
                await updateGameInFirestore(); // Update Firestore
                updatePendingTradesList(); // Update the public list
                checkPlayerDebtStatus(); // Check debt status after cancellation
            } else {
                console.warn(`[Trade Debug] ${Date.now()}: Attempted to cancel non-existent trade offer ID: ${offerId}.`);
            }
        }

        /**
         * Displays the details of a trade offer in a view-only modal, with conditional action buttons.
         * @param {string} offerId - The ID of the trade offer to display.
         */
        function displayTradeDetailsView(offerId) {
            const offer = gameState.pendingTradeOffers.find(o => o.offerId === offerId);
            if (!offer) {
                alert(getTranslation("tradeNotFound"));
                console.warn(`[Trade Debug] ${Date.now()}: Trade offer not found for details view: ${offerId}.`);
                return;
            }

            const tradeDetailsViewModal = document.getElementById('tradeDetailsViewModal');
            const tradeDetailsSenderName = document.getElementById('tradeDetailsSenderName');
            const tradeDetailsRecipientName = document.getElementById('tradeDetailsRecipientName');
            const tradeDetailsOfferedMoney = document.getElementById('tradeDetailsOfferedMoney');
            const tradeDetailsOfferedProperties = document.getElementById('tradeDetailsOfferedProperties');
            const tradeDetailsRequestedMoney = document.getElementById('tradeDetailsRequestedMoney');
            const tradeDetailsRequestedProperties = document.getElementById('tradeDetailsRequestedProperties');
            const tradeDetailsActionButtons = document.getElementById('tradeDetailsActionButtons');

            const sender = gameState.players.find(p => p.userId === offer.senderId);
            const recipient = gameState.players.find(p => p.userId === offer.recipientId);
            const currentPlayer = gameState.players.find(p => p.userId === currentUserId);

            // Display only names in the details view, without flags
            tradeDetailsSenderName.textContent = sender ? sender.name : 'Unknown';
            tradeDetailsRecipientName.textContent = recipient ? recipient.name : 'Unknown';
            tradeDetailsOfferedMoney.textContent = offer.offeredMoney;
            tradeDetailsRequestedMoney.textContent = offer.requestedMoney;

            // Populate offered properties with flags/emojis
            tradeDetailsOfferedProperties.innerHTML = '';
            if (offer.offeredProperties.length > 0) {
                offer.offeredProperties.forEach(propId => {
                    const prop = gameState.boardCellsInfo.find(cell => cell.id === propId);
                    if (prop) {
                        const listItem = document.createElement('li');
                        listItem.classList.add('flex', 'items-center', 'gap-1'); // Added flex for horizontal alignment
                        let iconHtml = '';
                        let displayName = '';
                        if (prop.type === 'city') {
                            iconHtml = `${getCountryFlagImage(prop.country)}`;
                            displayName = gameState.currentLanguage === 'ar' ? prop.displayName_ar : prop.displayName_en;
                        } else if (prop.type === 'company') {
                            iconHtml = `<span class="text-lg">${getCompanyEmoji(prop.content)}</span>`;
                            displayName = gameState.currentLanguage === 'ar' ? prop.displayName_ar : prop.displayName_en;
                        }
                        listItem.innerHTML = `${iconHtml} <span>${displayName}</span>`; // Wrapped text in span
                        tradeDetailsOfferedProperties.appendChild(listItem);
                    }
                });
            } else {
                tradeDetailsOfferedProperties.innerHTML = `<li>${getTranslation('none')}</li>`;
            }

            // Populate requested properties with flags/emojis
            tradeDetailsRequestedProperties.innerHTML = '';
            if (offer.requestedProperties.length > 0) {
                offer.requestedProperties.forEach(propId => {
                    const prop = gameState.boardCellsInfo.find(cell => cell.id === propId);
                    if (prop) {
                        const listItem = document.createElement('li');
                        listItem.classList.add('flex', 'items-center', 'gap-1'); // Added flex for horizontal alignment
                        let iconHtml = '';
                        let displayName = '';
                        if (prop.type === 'city') {
                            iconHtml = `${getCountryFlagImage(prop.country)}`;
                            displayName = gameState.currentLanguage === 'ar' ? prop.displayName_ar : prop.displayName_en;
                        } else if (prop.type === 'company') {
                            iconHtml = `<span class="text-lg">${getCompanyEmoji(prop.content)}</span>`;
                            displayName = gameState.currentLanguage === 'ar' ? prop.displayName_ar : prop.displayName_en;
                        }
                        listItem.innerHTML = `${iconHtml} <span>${displayName}</span>`; // Wrapped text in span
                        tradeDetailsRequestedProperties.appendChild(listItem);
                    }
                });
            } else {
                tradeDetailsRequestedProperties.innerHTML = `<li>${getTranslation('none')}</li>`;
            }

            // Clear and add action buttons based on current player's role
            tradeDetailsActionButtons.innerHTML = '';
            gameState.currentActiveTradeOffer = offer; // Set the active offer for accept/decline logic

            if (currentPlayer.userId === offer.recipientId) {
                // Recipient actions
                const acceptBtn = document.createElement('button');
                acceptBtn.className = 'btn-primary py-2 px-6 rounded-md';
                acceptBtn.textContent = getTranslation('accept');
                acceptBtn.onclick = acceptTrade;
                tradeDetailsActionButtons.appendChild(acceptBtn);

                const declineBtn = document.createElement('button');
                declineBtn.className = 'btn-secondary py-2 px-6 rounded-md';
                declineBtn.textContent = getTranslation('decline');
                declineBtn.onclick = declineTrade;
                tradeDetailsActionButtons.appendChild(declineBtn);

                const modifyBtn = document.createElement('button');
                modifyBtn.className = 'btn-secondary py-2 px-6 rounded-md';
                modifyBtn.textContent = getTranslation('modify');
                modifyBtn.onclick = () => {
                    document.getElementById('tradeDetailsViewModal').classList.add('hidden');
                    // When recipient modifies, it's a counter-offer from recipient to sender
                    openTradeCreationModal(currentPlayer.userId, {
                        offerId: offer.offerId, // Keep original offerId for tracking purposes if needed, or generate new
                        senderId: currentPlayer.userId,
                        recipientId: offer.senderId,
                        offeredMoney: offer.requestedMoney, // What recipient was asked for, they now offer
                        offeredProperties: offer.requestedProperties, // What recipient was asked for, they now offer
                        requestedMoney: offer.offeredMoney, // What sender offered, recipient now requests
                        requestedProperties: offer.offeredProperties, // What sender offered, recipient now requests
                    });
                };
                tradeDetailsActionButtons.appendChild(modifyBtn);

            } else if (currentPlayer.userId === offer.senderId) {
                // Sender actions
                const modifyBtn = document.createElement('button');
                modifyBtn.className = 'btn-secondary py-2 px-6 rounded-md';
                modifyBtn.textContent = getTranslation('modify');
                modifyBtn.onclick = () => {
                    document.getElementById('tradeDetailsViewModal').classList.add('hidden');
                    openTradeCreationModal(currentPlayer.userId, offer); // Pass the existing offer to pre-fill
                };
                tradeDetailsActionButtons.appendChild(modifyBtn);

                const cancelBtn = document.createElement('button');
                cancelBtn.className = 'btn-secondary py-2 px-6 rounded-md bg-red-600 hover:bg-red-700';
                cancelBtn.textContent = getTranslation('cancel');
                cancelBtn.onclick = () => cancelTrade(offer.offerId);
                tradeDetailsActionButtons.appendChild(cancelBtn);
            }

            tradeDetailsViewModal.classList.remove('hidden');
            console.log(`[Trade Debug] ${Date.now()}: Trade details view modal displayed for offer ID: ${offer.offerId}. Current player role: ${currentPlayer.userId === offer.recipientId ? 'Recipient' : currentPlayer.userId === offer.senderId ? 'Sender' : 'Viewer'}.`);
        }

        /**
         * Updates the list of pending trade offers displayed in the sidebar.
         */
        function updatePendingTradesList() {
            const pendingTradesListElem = document.getElementById('pendingTradesList');
            const pendingTradesCountElem = document.getElementById('pendingTradesCount');
            pendingTradesListElem.innerHTML = ''; // Clear current list

            // Filter out trades involving players who are no longer in the game
            gameState.pendingTradeOffers = gameState.pendingTradeOffers.filter(offer =>
                gameState.players.some(p => p.userId === offer.senderId) &&
                gameState.players.some(p => p.userId === offer.recipientId)
            );

            pendingTradesCountElem.textContent = gameState.pendingTradeOffers.length;
            console.log(`[Trade Debug] ${Date.now()}: Updating pending trades list. Count: ${gameState.pendingTradeOffers.length}.`);

            if (gameState.pendingTradeOffers.length === 0) {
                const noTradesMessage = document.createElement('p');
                noTradesMessage.classList.add('text-gray-400');
                noTradesMessage.textContent = getTranslation('noPendingTrades');
                pendingTradesListElem.appendChild(noTradesMessage);
            } else {
                gameState.pendingTradeOffers.forEach(offer => {
                    const sender = gameState.players.find(p => p.userId === offer.senderId);
                    const recipient = gameState.players.find(p => p.userId === offer.recipientId);

                    const senderName = sender ? sender.name : 'Unknown';
                    const recipientName = recipient ? recipient.name : 'Unknown';

                    const tradeItem = document.createElement('div');
                    tradeItem.classList.add('pending-trade-item');
                    tradeItem.innerHTML = `
                        <span class="trade-summary">${senderName} ↔ ${recipientName}</span>
                        <span class="trade-details">${getTranslation('offer')}: $${offer.offeredMoney} + ${offer.offeredProperties.length} ${getTranslation('prop_s_')}</span>
                        <span class="trade-details">${getTranslation('request')}: $${offer.requestedMoney} + ${offer.requestedProperties.length} ${getTranslation('prop_s_')}</span>
                    `;
                    tradeItem.onclick = () => displayTradeDetailsView(offer.offerId);
                    pendingTradesListElem.appendChild(tradeItem);
                });
            }
        }

        /**
         * Opens the sell property modal, populating it with the current player's properties.
         */
        function openSellPropertyModal() {
            const sellPropertyModal = document.getElementById('sellPropertyModal');
            const propertiesToSellList = document.getElementById('propertiesToSellList');
            const currentPlayer = gameState.players.find(p => p.userId === currentUserId);

            propertiesToSellList.innerHTML = ''; // Clear current list

            const playerProperties = Object.values(gameState.boardProperties).filter(
                prop => prop.ownerId === currentPlayer.userId
            );
            console.log(`[Sell Property Debug] ${Date.now()}: Opening sell property modal for ${currentPlayer.name}. Properties owned: ${playerProperties.length}.`);

            if (playerProperties.length === 0) {
                const p = document.createElement('p');
                p.classList.add('text-gray-400');
                p.textContent = getTranslation('noPropertiesToSell');
                propertiesToSellList.appendChild(p);
                document.getElementById('confirmSellPropertiesBtn').disabled = true;
            } else {
                document.getElementById('confirmSellPropertiesBtn').disabled = false;
                playerProperties.forEach(prop => {
                    const originalCell = gameState.boardCellsInfo.find(cell => cell.id === prop.id);
                    const sellPrice = roundToNearestFive(originalCell.price / 2); // Sell for half the original price

                    const listItem = document.createElement('div');
                    listItem.className = 'flex items-center gap-2 py-1';
                    let iconHtml = '';
                    let displayName = '';
                    if (originalCell) {
                        displayName = gameState.currentLanguage === 'ar' ? originalCell.displayName_ar : originalCell.displayName_en;
                        if (originalCell.type === 'city') {
                            iconHtml = `${getCountryFlagImage(originalCell.country)}`;
                        } else if (originalCell.type === 'company') {
                            iconHtml = `<span class="text-lg">${getCompanyEmoji(originalCell.content)}</span>`;
                        }
                    }

                    listItem.innerHTML = `
                        <input type="checkbox" id="sell-prop-${prop.id}" value="${prop.id}" data-sell-price="${sellPrice}" class="form-checkbox h-4 w-4 text-purple-600">
                        <label for="sell-prop-${prop.id}" class="text-gray-300 text-sm flex items-center gap-1">
                            ${iconHtml} <span>${displayName} ($${sellPrice})</span>
                        </label>
                    `;
                    propertiesToSellList.appendChild(listItem);
                });
            }
            sellPropertyModal.classList.remove('hidden');
        }

        /**
         * Handles the selling of selected properties.
         */
        async function sellSelectedProperties() {
            const propertiesToSellCheckboxes = document.querySelectorAll('#propertiesToSellList input[type="checkbox"]:checked');
            const currentPlayer = gameState.players.find(p => p.userId === currentUserId);
            let totalRefund = 0;
            const soldPropertyIds = [];

            if (propertiesToSellCheckboxes.length === 0) {
                alert(getTranslation("selectAtLeastOne"));
                console.warn(`[Sell Property Debug] ${Date.now()}: No properties selected for selling.`);
                return;
            }

            propertiesToSellCheckboxes.forEach(checkbox => {
                const propId = checkbox.value;
                const sellPrice = parseInt(checkbox.dataset.sellPrice);

                totalRefund += sellPrice;
                soldPropertyIds.push(propId);

                // Update the property in gameState.boardCellsInfo and gameState.boardProperties
                const propertyInCellsInfo = gameState.boardCellsInfo.find(cell => cell.id === propId);
                if (propertyInCellsInfo) {
                    propertyInCellsInfo.owner = null; // No owner
                    propertyInCellsInfo.currentUpgradeLevel = 0; // Reset level
                    updateBoardCellDisplay(document.querySelector(`.${propId}`), propertyInCellsInfo);
                }
                delete gameState.boardProperties[propId]; // Remove from owned properties map
                console.log(`[Sell Property Debug] ${Date.now()}: Property ${propertyInCellsInfo?.content} (ID: ${propId}) sold for $${sellPrice}.`);
            });

            currentPlayer.money += totalRefund;
            updatePlayersList();
            updateMyPropertiesList();
            document.getElementById('sellPropertyModal').classList.add('hidden');
            alert(getTranslation('playerSold', currentPlayer.name, soldPropertyIds.length, totalRefund, currentPlayer.money));
            showMoneyEffect(currentPlayer.userId, totalRefund, 'gain');
            checkPlayerDebtStatus(); // Check debt status after selling properties
            await updateGameInFirestore(); // Update Firestore
            console.log(`[Sell Property Debug] ${Date.now()}: Player ${currentPlayer.name} completed selling properties. Total refund: $${totalRefund}. New money: ${currentPlayer.money}.`);
        }

        /**
         * Adds a new AI player to the lobby.
         */
        async function addAIPlayerToLobby() {
            if (gameState.players.length >= MAX_PLAYERS) {
                alert(getTranslation("maxPlayersReached"));
                console.warn(`[Lobby] ${Date.now()}: Cannot add player, max players reached.`);
                return;
            }
            if (!db) {
                console.error("[Lobby] Firestore DB not initialized. Cannot add AI player.");
                alert("Database not ready. Please try again.");
                return;
            }


            const newPlayerId = gameState.players.length + 1;
            const playerColors = ['#FF0000', '#0000FF', '#00FF00', '#FFFF00', '#FF4500']; // Red, Blue, Green, Yellow, OrangeRed
            const newPlayerColor = playerColors[newPlayerId - 1]; // Assign color based on ID

            const newPlayer = {
                userId: `ai_${Date.now()}_${newPlayerId}`, // Unique ID for AI
                name: getTranslation('aiPlayer', newPlayerId),
                money: gameState.STARTING_MONEY,
                positionIndex: 0,
                color: newPlayerColor,
                isAI: true
            };

            gameState.players.push(newPlayer);
            if (gameState.leaderId === null) {
                gameState.leaderId = currentUserId; // Human player is always the leader if they are the first
                console.log(`[Lobby] ${Date.now()}: New leader set: ${currentUsername} (ID: ${currentUserId}).`);
            }
            await updateGameInFirestore(); // Update Firestore
            updateLobbyPlayerCards(); // Re-render lobby cards
            document.getElementById('lobbyPlayButton').disabled = false; // Enable play button
            console.log(`[Lobby] ${Date.now()}: Added new AI Player ${newPlayerId}. Total players: ${gameState.players.length}.`);
        }

        /**
         * Kicks a player from the lobby by the leader.
         * @param {string} playerUserIdToKick - The userId of the player to be kicked.
         */
        function kickPlayerFromLobby(playerUserIdToKick) {
            const leaderPlayer = gameState.players.find(p => p.userId === gameState.leaderId);
            if (!leaderPlayer || leaderPlayer.userId !== currentUserId) { // Check if current user is the leader
                alert(getTranslation('onlyLeaderCanKick'));
                console.warn(`[Lobby Kick] ${Date.now()}: Kick attempt failed. Current user is not the leader.`);
                return;
            }

            const playerToKick = gameState.players.find(p => p.userId === playerUserIdToKick);
            if (!playerToKick) {
                console.warn(`[Lobby Kick] ${Date.now()}: Attempted to kick non-existent player ID: ${playerUserIdToKick}.`);
                return;
            }

            // Confirmation dialog (using custom alert)
            alert(getTranslation('confirmKick', playerToKick.name));
            const customAlert = document.getElementById('custom-alert');
            const okButton = customAlert.querySelector('button');

            // Replace OK button with Confirm/Cancel for kick
            const confirmButton = document.createElement('button');
            confirmButton.textContent = 'Confirm'; // Not translated, as it's a temporary dialog
            confirmButton.className = 'bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-md focus:outline-none focus:ring-2 focus:ring-red-500 mr-2';
            confirmButton.onclick = async () => {
                gameState.players = gameState.players.filter(p => p.userId !== playerUserIdToKick);
                if (playerToKick.userId === gameState.leaderId && gameState.players.length > 0) {
                    gameState.leaderId = gameState.players[0].userId; // Assign new leader
                } else if (gameState.players.length === 0) {
                    gameState.leaderId = null;
                }
                await updateGameInFirestore(); // Update Firestore
                document.getElementById('custom-alert').remove();
                alert(getTranslation('playerKicked', playerToKick.name));
                console.log(`[Lobby Kick] ${Date.now()}: Player ${playerToKick.name} (ID: ${playerToKick.userId}) kicked from lobby.`);
                // Disable play button if no players left (should be handled by Firestore update)
            };

            const cancelButton = document.createElement('button');
            cancelButton.textContent = 'Cancel'; // Not translated
            cancelButton.className = 'bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-md focus:outline-none focus:ring-2 focus:ring-gray-500';
            cancelButton.onclick = () => {
                document.getElementById('custom-alert').remove();
                console.log(`[Lobby Kick] ${Date.now()}: Kick action cancelled for player ID: ${playerUserIdToKick}.`);
            };

            okButton.replaceWith(confirmButton, cancelButton);
        }

        /**
         * Dynamically updates the player cards shown in the lobby.
         * This function will create a player card for each player in gameState.players.
         */
        function updateLobbyPlayerCards() {
            const lobbyPlayerCardsContainer = document.getElementById('lobbyPlayerCardsContainer');
            lobbyPlayerCardsContainer.innerHTML = ''; // Clear existing cards

            // Render existing players
            gameState.players.forEach(player => {
                const playerCard = document.createElement('div');
                playerCard.className = 'player-card';

                let crownHtml = '';
                if (player.userId === gameState.leaderId) {
                    crownHtml = `<i class="fas fa-crown leader-crown"></i>`;
                }

                let kickButtonHtml = '';
                // Only show kick button if current user is leader and it's not their own card and not an AI
                if (currentUserId === gameState.leaderId && player.userId !== currentUserId && !player.isAI) {
                    kickButtonHtml = `<button class="kick-button" onclick="kickPlayerFromLobby('${player.userId}')">${getTranslation('kick')}</button>`;
                } else if (currentUserId === gameState.leaderId && player.isAI) {
                     kickButtonHtml = `<button class="kick-button" onclick="kickPlayerFromLobby('${player.userId}')">${getTranslation('kick')}</button>`;
                }

                playerCard.innerHTML = `
                    ${crownHtml}
                    <div class="player-icon" style="color: ${player.color};"><i class="fas fa-user-circle"></i></div>
                    <h4 class="text-lg font-bold text-white">${player.name}</h4>
                    <p class="text-gray-400">${getTranslation('playerMoney', player.money)}</p>
                    <span class="status-badge">${getTranslation('ready')}</span>
                    ${kickButtonHtml}
                `;
                lobbyPlayerCardsContainer.appendChild(playerCard);
            });

            // Add "Add Player" cards for remaining slots, only if current user is leader
            if (currentUserId === gameState.leaderId) {
                for (let i = gameState.players.length; i < MAX_PLAYERS; i++) {
                    const addPlayerCard = document.createElement('div');
                    addPlayerCard.className = 'player-card flex flex-col items-center justify-center cursor-pointer hover:bg-gray-700 transition-colors duration-200';
                    addPlayerCard.style.border = '2px dashed #555577'; // Dashed border for empty slot
                    addPlayerCard.innerHTML = `
                        <div class="text-6xl text-gray-400 mb-2"><i class="fas fa-plus-circle"></i></div>
                        <h4 class="text-lg font-bold text-gray-400">${getTranslation('addPlayer')}</h4>
                    `;
                    addPlayerCard.addEventListener('click', addAIPlayerToLobby); // Attach event listener
                    lobbyPlayerCardsContainer.appendChild(addPlayerCard);
                }
            }


            // Update the lobby player count display
            document.getElementById('lobbyPlayerCount').textContent = `${gameState.players.length}/${MAX_PLAYERS}`;
            document.getElementById('onlinePlayersTitle').innerHTML = `${getTranslation('online')} <span class="text-green-400">(${gameState.players.length})</span>`;
            console.log(`[Lobby] ${Date.now()}: Lobby player cards updated. Current count: ${gameState.players.length}/${MAX_PLAYERS}.`);

            // Enable/disable play button based on player count and leader status
            const lobbyPlayButton = document.getElementById('lobbyPlayButton');
            if (gameState.players.length > 0 && currentUserId === gameState.leaderId) {
                lobbyPlayButton.disabled = false;
            } else {
                lobbyPlayButton.disabled = true;
            }
        }

        // --- Settings Modal Functions ---
        function openSettingsModal() {
            const settingsModal = document.getElementById('settingsModal');
            const languageSelect = document.getElementById('languageSelect');
            languageSelect.value = gameState.currentLanguage; // Set dropdown to current language
            settingsModal.classList.remove('hidden');
            console.log(`[Settings] ${Date.now()}: Settings modal opened. Current language: ${gameState.currentLanguage}.`);
        }

        async function applySettings() {
            const languageSelect = document.getElementById('languageSelect');
            const selectedLanguage = languageSelect.value;
            if (gameState.currentLanguage !== selectedLanguage) {
                gameState.currentLanguage = selectedLanguage;
                document.body.dir = (gameState.currentLanguage === 'ar') ? 'rtl' : 'ltr'; // Set direction immediately
                updateAllTextContent(); // Re-render all text content with new language
                populateBoard(); // Re-populate board to update city names
                console.log(`[Settings] ${Date.now()}: Language set to: ${selectedLanguage}.`);

                // Update user's language preference in Firestore
                if (currentUserId && db) {
                    try {
                        const userDocRef = doc(db, `artifacts/${appId}/users/${currentUserId}/profile/data`);
                        await setDoc(userDocRef, { language: selectedLanguage }, { merge: true });
                        console.log(`[Firestore] User language preference updated to ${selectedLanguage}.`);
                    } catch (error) {
                        console.error("Error updating user language preference:", error);
                    }
                }
            }
            closeSettingsModal();
        }

        function closeSettingsModal() {
            const settingsModal = document.getElementById('settingsModal');
            settingsModal.classList.add('hidden');
            console.log(`[Settings] ${Date.now()}: Settings modal closed.`);
        }

        // --- Firebase Integration ---
        async function setupFirebase() {
            console.log("[Firebase] Initializing Firebase...");
            try {
                // Check if firebaseConfig is valid
                if (!firebaseConfig || Object.keys(firebaseConfig).length === 0) {
                    console.error("[Firebase] firebaseConfig is missing or empty. Please ensure __firebase_config is provided.");
                    alert("Firebase configuration is missing. The app cannot connect to the database.");
                    return; // Stop initialization
                }
                console.log("[Firebase] firebaseConfig:", firebaseConfig); // Log firebaseConfig for debugging

                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
                console.log("[Firebase] Firebase app, db, and auth initialized.");

                // Sign in with custom token if available, otherwise anonymously
                if (initialAuthToken) {
                    await signInWithCustomToken(auth, initialAuthToken);
                    console.log("[Firebase] Signed in with custom token.");
                } else {
                    await signInAnonymously(auth);
                    console.log("[Firebase] Signed in anonymously.");
                }

                // Listen for auth state changes
                onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        currentUserId = user.uid;
                        document.getElementById('currentUserIdDisplay').textContent = currentUserId;
                        console.log(`[Firebase] User authenticated: ${currentUserId}`);
                        await checkAndSetUsername();
                    } else {
                        currentUserId = null;
                        currentUsername = null;
                        document.getElementById('currentUserIdDisplay').textContent = "Not Authenticated";
                        console.log("[Firebase] User logged out or not authenticated.");
                        // Handle UI changes for logged out state if necessary
                    }
                });
            } catch (error) {
                console.error("Error setting up Firebase:", error);
                document.getElementById('currentUserIdDisplay').textContent = `Error: ${error.message}`;
                alert(`Failed to connect to Firebase: ${error.message}. Check your Firebase project setup.`);
            }
        }

        // --- Username Management ---
        async function checkAndSetUsername() {
            if (!currentUserId || !db) {
                console.warn("[Username] Firebase DB not ready or user not authenticated. Cannot check username.");
                return;
            }

            const userDocRef = doc(db, `artifacts/${appId}/users/${currentUserId}/profile/data`);
            try {
                const userDocSnap = await getDoc(userDocRef);
                if (userDocSnap.exists() && userDocSnap.data().username) {
                    currentUsername = userDocSnap.data().username;
                    gameState.currentLanguage = userDocSnap.data().language || 'en'; // Load language preference
                    console.log(`[Username] User profile found. Username: ${currentUsername}, Language: ${gameState.currentLanguage}.`);
                    document.body.dir = (gameState.currentLanguage === 'ar') ? 'rtl' : 'ltr'; // Set initial direction
                    updateAllTextContent(); // Update UI with loaded language
                    document.getElementById('lobbyPage').classList.remove('hidden'); // Show lobby if username exists

                    // If a party code is already set (e.g., from URL), try to join
                    if (gameState.partyCode) {
                        await joinLobby(gameState.partyCode);
                    } else {
                        // If no party code, and user has username, create a default lobby
                        await createLobby();
                    }

                } else {
                    console.log("[Username] User profile not found or username not set. Showing username modal.");
                    document.getElementById('usernameModal').classList.remove('hidden');
                }
            } catch (error) {
                console.error("Error fetching user profile:", error);
                document.getElementById('usernameModal').classList.remove('hidden'); // Show modal on error
            }
        }

        async function saveUsername() {
            const usernameInput = document.getElementById('usernameInput');
            const usernameError = document.getElementById('usernameError');
            const username = usernameInput.value.trim();

            usernameError.textContent = ''; // Clear previous errors

            // Validate username format
            const usernameRegex = /^[a-z0-9_]{3,15}$/;
            if (!usernameRegex.test(username)) {
                usernameError.textContent = getTranslation('usernameInvalid');
                return;
            }

            if (!db) {
                console.error("[Username] Firestore DB not initialized. Cannot save username.");
                alert("Database not ready. Please try again.");
                return;
            }

            // Check if username is unique
            try {
                const usersCollectionRef = collection(db, `artifacts/${appId}/users`);
                const q = query(usersCollectionRef, where("profile.data.username", "==", username));
                const querySnapshot = await getDocs(q);

                if (!querySnapshot.empty) {
                    usernameError.textContent = getTranslation('usernameTaken');
                    return;
                }

                // Save username to Firestore
                const userDocRef = doc(db, `artifacts/${appId}/users/${currentUserId}/profile/data`);
                await setDoc(userDocRef, { username: username, language: gameState.currentLanguage }, { merge: true });
                currentUsername = username;
                alert(getTranslation('usernameSaved', username));
                document.getElementById('usernameModal').classList.add('hidden');
                document.getElementById('lobbyPage').classList.remove('hidden'); // Show lobby after saving username
                updateAllTextContent(); // Update UI with new username
                console.log(`[Username] Username "${username}" saved for user ${currentUserId}.`);

                // If no game is active, create a default lobby for the user
                if (!gameState.partyCode) {
                    await createLobby();
                } else {
                    // If a party code is already set (e.g., from URL), try to join
                    await joinLobby(gameState.partyCode);
                }

            } catch (error) {
                console.error("Error saving username:", error);
                usernameError.textContent = `Error: ${error.message}`;
            }
        }

        // --- Lobby Management with Firestore ---
        async function createLobby() {
            if (!db || !currentUserId || !currentUsername) {
                console.error("[Lobby] Firebase not ready or user not authenticated for lobby creation. DB:", db, "User ID:", currentUserId, "Username:", currentUsername);
                alert("Cannot create lobby: Database not ready or user not authenticated.");
                return;
            }

            const partyCodeInput = document.getElementById('partyCodeInput');
            const partyCode = partyCodeInput.value.trim().toLowerCase(); // Use user-entered code or generate

            let finalPartyCode = partyCode;
            if (!finalPartyCode) {
                // Generate a random 6-character alphanumeric code if not provided
                finalPartyCode = Math.random().toString(36).substring(2, 8);
            }

            const gameRef = doc(db, `artifacts/${appId}/public/data/games/${finalPartyCode}`);
            try {
                const gameSnap = await getDoc(gameRef);
                if (gameSnap.exists()) {
                    if (gameSnap.data().gameStatus === 'in-game') {
                        alert(getTranslation('gameAlreadyStarted'));
                        return;
                    }
                    // Lobby exists, try to join it
                    console.log(`[Lobby] Lobby ${finalPartyCode} already exists. Attempting to join.`);
                    await joinLobby(finalPartyCode);
                    return;
                }

                // Create new lobby
                const playerColors = ['#FF0000', '#0000FF', '#00FF00', '#FFFF00', '#FF4500'];
                const playerColor = playerColors[0]; // First player gets first color

                const initialPlayer = {
                    userId: currentUserId,
                    name: currentUsername,
                    money: gameState.STARTING_MONEY,
                    positionIndex: 0,
                    color: playerColor,
                    isAI: false
                };

                const initialGameState = {
                    players: [initialPlayer],
                    currentPlayerIndex: 0,
                    boardProperties: {},
                    pendingTradeOffers: [],
                    leaderId: currentUserId,
                    gameStatus: 'lobby',
                    partyCode: finalPartyCode,
                    createdAt: Date.now()
                };

                await setDoc(gameRef, initialGameState);
                gameState.partyCode = finalPartyCode;
                gameDocRef = gameRef; // Set global gameDocRef
                alert(getTranslation('lobbyCreated', finalPartyCode));
                console.log(`[Lobby] Lobby ${finalPartyCode} created by ${currentUsername}.`);
                partyCodeInput.value = finalPartyCode; // Display the code

                setupGameListener(finalPartyCode); // Start listening for updates
                document.getElementById('gameShareLink').value = `https://game-1-b46e1.web.app/?partyCode=${finalPartyCode}`; // Updated share link

            } catch (error) {
                console.error("Error creating lobby:", error);
                alert(`Error creating/joining lobby: ${error.message}`);
            }
        }

        async function joinLobby(code) {
            if (!db || !currentUserId || !currentUsername) {
                console.error("[Lobby] Firebase not ready or user not authenticated for lobby join. DB:", db, "User ID:", currentUserId, "Username:", currentUsername);
                alert("Cannot join lobby: Database not ready or user not authenticated.");
                return;
            }

            const partyCode = code.trim().toLowerCase();
            const gameRef = doc(db, `artifacts/${appId}/public/data/games/${partyCode}`);

            try {
                const gameSnap = await getDoc(gameRef);
                if (!gameSnap.exists()) {
                    alert(getTranslation('lobbyNotFound'));
                    console.warn(`[Lobby] Lobby ${partyCode} not found.`);
                    return;
                }

                const currentLobbyState = gameSnap.data();
                if (currentLobbyState.gameStatus === 'in-game') {
                    alert(getTranslation('gameAlreadyStarted'));
                    return;
                }

                if (currentLobbyState.players.length >= MAX_PLAYERS) {
                    alert(getTranslation('maxPlayersReached'));
                    console.warn(`[Lobby] Lobby ${partyCode} is full.`);
                    return;
                }

                // Check if player is already in this lobby
                const isAlreadyInLobby = currentLobbyState.players.some(p => p.userId === currentUserId);
                if (isAlreadyInLobby) {
                    console.log(`[Lobby] User ${currentUsername} already in lobby ${partyCode}. Rejoining.`);
                    gameState.partyCode = partyCode;
                    gameDocRef = gameRef;
                    setupGameListener(partyCode);
                    document.getElementById('partyCodeInput').value = partyCode;
                    document.getElementById('gameShareLink').value = `https://game-1-b46e1.web.app/?partyCode=${partyCode}`; // Updated share link
                    return;
                }

                const playerColors = ['#FF0000', '#0000FF', '#00FF00', '#FFFF00', '#FF4500'];
                const existingPlayerIds = currentLobbyState.players.map(p => p.id); // Assuming p.id is 1,2,3...
                let newPlayerId = 1;
                while (existingPlayerIds.includes(newPlayerId)) {
                    newPlayerId++;
                }
                const playerColor = playerColors[newPlayerId - 1]; // Assign color based on ID

                const newPlayer = {
                    userId: currentUserId,
                    name: currentUsername,
                    money: gameState.STARTING_MONEY,
                    positionIndex: 0,
                    color: playerColor,
                    isAI: false,
                    id: newPlayerId // Assign a simple ID for color mapping
                };

                currentLobbyState.players.push(newPlayer);
                await updateDoc(gameRef, { players: currentLobbyState.players });

                gameState.partyCode = partyCode;
                gameDocRef = gameRef; // Set global gameDocRef
                alert(getTranslation('lobbyJoined', partyCode));
                console.log(`[Lobby] User ${currentUsername} joined lobby ${partyCode}.`);
                document.getElementById('partyCodeInput').value = partyCode;
                document.getElementById('gameShareLink').value = `https://game-1-b46e1.web.app/?partyCode=${partyCode}`; // Updated share link

                setupGameListener(partyCode); // Start listening for updates

            } catch (error) {
                console.error("Error joining lobby:", error);
                alert(`Error joining lobby: ${error.message}`);
            }
        }

        async function leaveLobby() {
            if (!gameDocRef || !currentUserId) return;

            try {
                const gameSnap = await getDoc(gameDocRef);
                if (gameSnap.exists()) {
                    const currentLobbyState = gameSnap.data();
                    const updatedPlayers = currentLobbyState.players.filter(p => p.userId !== currentUserId);

                    // If the leaving player was the leader, reassign leader
                    let newLeaderId = currentLobbyState.leaderId;
                    if (currentUserId === currentLobbyState.leaderId && updatedPlayers.length > 0) {
                        newLeaderId = updatedPlayers[0].userId;
                    } else if (updatedPlayers.length === 0) {
                        newLeaderId = null;
                    }

                    await updateDoc(gameDocRef, {
                        players: updatedPlayers,
                        leaderId: newLeaderId
                    });
                    console.log(`[Lobby] User ${currentUsername} left lobby ${gameState.partyCode}.`);
                }
            } catch (error) {
                console.error("Error leaving lobby:", error);
            } finally {
                if (gameUnsubscribe) {
                    gameUnsubscribe();
                    gameUnsubscribe = null;
                }
                gameState.partyCode = null;
                gameDocRef = null;
                // Reset UI to initial lobby state
                document.getElementById('lobbyPage').classList.remove('hidden');
                document.getElementById('gamePage').classList.add('hidden');
                document.getElementById('partyCodeInput').value = '';
                gameState.players = []; // Clear local players array
                gameState.leaderId = null; // Clear local leader
                updateLobbyPlayerCards(); // Re-render empty lobby cards
            }
        }

        function setupGameListener(partyCode) {
            if (gameUnsubscribe) {
                gameUnsubscribe(); // Unsubscribe from previous game if any
            }
            if (!db) {
                console.error("[Firestore] Firestore DB not initialized. Cannot set up game listener.");
                return;
            }
            gameDocRef = doc(db, `artifacts/${appId}/public/data/games/${partyCode}`);
            gameUnsubscribe = onSnapshot(gameDocRef, (docSnap) => {
                if (docSnap.exists()) {
                    const latestGameState = docSnap.data();
                    console.log("[Firestore] Game state updated:", latestGameState);

                    // Deep merge or replace gameState with latest from Firestore
                    Object.assign(gameState, latestGameState);

                    // Ensure player.id is correctly assigned for color mapping
                    // This is a workaround if Firestore doesn't preserve `id` correctly or if players join out of order
                    gameState.players.forEach((player, index) => {
                        player.id = index + 1; // Assign sequential ID for color
                    });

                    // Update UI based on current game status
                    if (gameState.gameStatus === 'lobby') {
                        document.getElementById('lobbyPage').classList.remove('hidden');
                        document.getElementById('gamePage').classList.add('hidden');
                        updateLobbyPlayerCards();
                        // Update current player's money display in lobby header
                        const currentPlayerInLobby = gameState.players.find(p => p.userId === currentUserId);
                        if (currentPlayerInLobby) {
                            document.getElementById('playerMoneyDisplay').textContent = currentPlayerInLobby.money;
                        }
                    } else if (gameState.gameStatus === 'in-game') {
                        document.getElementById('lobbyPage').classList.add('hidden');
                        document.getElementById('gamePage').classList.remove('hidden');
                        populateBoard(); // Re-render board with latest property owners/levels
                        addPlayerTokens(); // Re-add tokens to ensure correct positions
                        updatePlayersList();
                        updateMyPropertiesList();
                        updatePendingTradesList();
                        checkPlayerDebtStatus();
                        // If it's my turn and timer isn't running, start it
                        const currentPlayerTurn = gameState.players[gameState.currentPlayerIndex];
                        if (currentPlayerTurn && currentPlayerTurn.userId === currentUserId && turnTimer === null) {
                             startTurnTimer();
                        }
                    } else if (gameState.gameStatus === 'ended') {
                        alert(getTranslation('gameEnded'));
                        document.getElementById('gamePage').classList.add('hidden');
                        document.getElementById('lobbyPage').classList.remove('hidden');
                        // Optionally clean up game document from Firestore here or let it persist
                        // deleteDoc(gameDocRef); // Uncomment if games should be deleted after ending
                        if (gameUnsubscribe) {
                            gameUnsubscribe();
                            gameUnsubscribe = null;
                        }
                        gameState.partyCode = null;
                        gameDocRef = null;
                        gameState.players = [];
                        gameState.leaderId = null;
                        updateLobbyPlayerCards();
                    }

                    // Check for incoming trade offers for the current user
                    const incomingOffer = gameState.pendingTradeOffers.find(
                        offer => offer.recipientId === currentUserId && offer.status === 'pending'
                    );
                    if (incomingOffer && !document.getElementById('incomingTradeOfferModal').classList.contains('hidden')) {
                        // If modal is already open for another offer, or this offer, update it
                        // This prevents re-opening if it's already visible
                        if (gameState.currentActiveTradeOffer?.offerId !== incomingOffer.offerId) {
                            displayIncomingTradeOffer(incomingOffer);
                        }
                    } else if (!incomingOffer && gameState.currentActiveTradeOffer?.recipientId === currentUserId) {
                        // If there was an active incoming offer for me, but it's no longer pending, close modal
                        document.getElementById('incomingTradeOfferModal').classList.add('hidden');
                        gameState.currentActiveTradeOffer = null;
                    }


                } else {
                    console.log("[Firestore] Game document does not exist. Lobby might have been deleted.");
                    alert(getTranslation('lobbyNotFound'));
                    leaveLobby(); // Go back to lobby creation if game doc disappears
                }
            }, (error) => {
                console.error("Error listening to game state:", error);
                alert(`Error syncing game: ${error.message}`);
                leaveLobby(); // Attempt to leave if there's a listener error
            });
            console.log(`[Firestore] Listening to game state for party code: ${partyCode}`);
        }

        async function updateGameInFirestore() {
            if (!gameDocRef) {
                console.error("[Firestore] No active game document reference to update.");
                return;
            }
            if (!db) {
                console.error("[Firestore] Firestore DB not initialized. Cannot update game state.");
                return;
            }
            try {
                // Remove functions before sending to Firestore
                const stateToSave = { ...gameState };
                // Firestore cannot store functions, so ensure they are not in the object being saved
                // (e.g., if you had functions directly in player objects, remove them)
                await setDoc(gameDocRef, stateToSave);
                console.log("[Firestore] Game state updated in Firestore.");
            } catch (error) {
                console.error("Error updating game state in Firestore:", error);
                alert(`Error saving game state: ${error.message}`);
            }
        }

        // DOM Content Loaded event listener
        document.addEventListener('DOMContentLoaded', async () => {
            console.log("DOMContentLoaded event fired."); // Debug log
            try {
                const lobbyPage = document.getElementById('lobbyPage');
                const gamePage = document.getElementById('gamePage');
                const lobbyPlayButton = document.getElementById('lobbyPlayButton');
                const toggleOnlinePlayersButton = document.getElementById('toggleOnlinePlayers');
                const onlinePlayersSidebar = document.getElementById('onlinePlayersSidebar');
                const settingsBtn = document.getElementById('settingsBtn');
                const applySettingsBtn = document.getElementById('applySettingsBtn');
                const closeSettingsBtn = document.getElementById('closeSettingsBtn');
                const saveUsernameBtn = document.getElementById('saveUsernameBtn');
                const usernameInput = document.getElementById('usernameInput');
                const createJoinPartyBtn = document.getElementById('createJoinPartyBtn');
                const partyCodeInput = document.getElementById('partyCodeInput');
                const backButton = document.querySelector('.lobby-header .left-section button'); // Back button in lobby

                // Initialize players as empty
                gameState.players = [];
                gameState.currentPlayerIndex = 0; // Start with the first player (will be 0 if no players)
                gameState.leaderId = null; // No leader initially

                // Hide both pages initially, show username modal or lobby after Firebase setup
                lobbyPage.classList.add('hidden');
                gamePage.classList.add('hidden');

                await setupFirebase(); // Initialize Firebase and handle auth/username

                // Handle partyCode from URL if present (for joining directly)
                const urlParams = new URLSearchParams(window.location.search);
                const initialPartyCode = urlParams.get('partyCode');
                if (initialPartyCode) {
                    partyCodeInput.value = initialPartyCode;
                    gameState.partyCode = initialPartyCode; // Store it temporarily
                }

                // The lobby page is now the initial view
                updateLobbyPlayerCards(); // Populate lobby player cards on load (will show "Add Player" initially)
                updateAllTextContent(); // Apply initial language

                // Initially disable the play button
                if (lobbyPlayButton) {
                    lobbyPlayButton.disabled = true;
                    lobbyPlayButton.addEventListener('click', async () => {
                        if (gameState.players.length === 0) {
                            alert(getTranslation("addAtLeastOnePlayer"));
                            console.warn(`[Lobby] ${Date.now()}: Play button clicked, but no players added.`);
                            return;
                        }
                        if (currentUserId !== gameState.leaderId) {
                            alert(getTranslation('notLeader'));
                            return;
                        }
                        if (gameState.gameStatus === 'in-game') {
                            alert(getTranslation('gameAlreadyStarted'));
                            return;
                        }

                        // Update game status in Firestore to 'in-game'
                        gameState.gameStatus = 'in-game';
                        await updateGameInFirestore();

                        console.log(`[Lobby] ${Date.now()}: Lobby Play button clicked. Transitioning to game page with ${gameState.players.length} players.`);
                        // UI transition and game start logic will be handled by the Firestore listener
                    });
                    console.log("Lobby Play button event listener attached."); // Debug log
                } else {
                    console.error("Lobby Play button element not found!"); // Debug log
                }

                // Create/Join Party Button
                if (createJoinPartyBtn) {
                    createJoinPartyBtn.addEventListener('click', async () => {
                        const code = partyCodeInput.value.trim();
                        if (code) {
                            await joinLobby(code);
                        } else {
                            await createLobby();
                        }
                    });
                }

                // Back button in lobby header (to leave lobby)
                if (backButton) {
                    backButton.addEventListener('click', leaveLobby);
                }


                // Toggle switch functionality for "CLOSED PARTY" on the lobby page
                const toggleCheckbox = document.getElementById('closedPartyToggle');
                if (toggleCheckbox) {
                    toggleCheckbox.addEventListener('change', function() {
                        const toggleDot = this.nextElementSibling.querySelector('.toggle-dot');
                        if (this.checked) {
                            toggleDot.style.left = 'calc(100% - 17px)'; /* Move to right */
                            this.nextElementSibling.style.backgroundColor = '#8a2be2'; /* Purple when active */
                        } else {
                            toggleDot.style.left = '3px'; /* Move to left */
                            this.nextElementSibling.style.backgroundColor = '#6b7280'; /* Gray when inactive */
                        }
                        console.log(`[Lobby] ${Date.now()}: Closed Party toggle changed to: ${this.checked}.`);
                    });
                }

                // Toggle button for Online Players sidebar
                if (toggleOnlinePlayersButton && onlinePlayersSidebar) {
                    // Ensure it starts hidden by default by adding the class
                    onlinePlayersSidebar.classList.add('hidden-content');
                    const icon = toggleOnlinePlayersButton.querySelector('i');
                    // Set initial icon to 'eye-slash' since it's hidden
                    icon.classList.remove('fa-eye');
                    icon.classList.add('fa-eye-slash');

                    toggleOnlinePlayersButton.addEventListener('click', () => {
                        onlinePlayersSidebar.classList.toggle('hidden-content');
                        if (onlinePlayersSidebar.classList.contains('hidden-content')) {
                            icon.classList.remove('fa-eye');
                            icon.classList.add('fa-eye-slash'); // Corrected icon for hidden state
                            console.log(`[Lobby] ${Date.now()}: Online Players sidebar hidden.`);
                        } else {
                            icon.classList.remove('fa-eye-slash');
                            icon.classList.add('fa-eye');
                            console.log(`[Lobby] ${Date.now()}: Online Players sidebar shown.`);
                        }
                    });
                }

                // Settings button listeners
                if (settingsBtn) {
                    settingsBtn.addEventListener('click', openSettingsModal);
                }
                if (applySettingsBtn) {
                    applySettingsBtn.addEventListener('click', applySettings);
                }
                if (closeSettingsBtn) {
                    closeSettingsBtn.addEventListener('click', closeSettingsModal);
                }

                // Username modal listeners
                if (saveUsernameBtn) {
                    saveUsernameBtn.addEventListener('click', saveUsername);
                    usernameInput.addEventListener('keypress', (event) => {
                        if (event.key === 'Enter') {
                            saveUsername();
                        }
                    });
                }

                // Attach event listener for sending trade offer
                document.getElementById('sendTradeOfferBtn').addEventListener('click', sendTradeOffer);
                document.getElementById('acceptTradeBtn').addEventListener('click', acceptTrade);
                document.getElementById('declineTradeBtn').addEventListener('click', declineTrade);
                document.getElementById('confirmSellPropertiesBtn').addEventListener('click', sellSelectedProperties); // Attach sell properties listener


                // Chat elements are disabled, so no need for listeners
                const chatSendBtn = document.getElementById('chatSendBtn');
                const chatInput = document.getElementById('chatInput');
                if (chatSendBtn) {
                    chatSendBtn.disabled = true;
                }
                if (chatInput) {
                    chatInput.disabled = true;
                }

            } catch (error) {
                console.error("Error during DOMContentLoaded setup:", error); // Catch any errors during setup
            }
        });
    </script>
</body>
</html>
