<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TRUWPi - Rule the Economy</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        /* Custom styles for background and font */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a1a2e; /* Dark purple/blue background */
            color: #e0e0e0; /* Light grey text */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            overflow: hidden; /* Hide overflow for background elements */
            position: relative;
        }

        /* Custom button styles */
        .btn-primary {
            background: linear-gradient(135deg, #8a2be2, #4b0082); /* Purple gradient */
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }
        .btn-primary:disabled {
            background: #4a4a5a; /* Darker grey for disabled */
            cursor: not-allowed;
            box-shadow: none;
        }
        .btn-secondary {
            background-color: #33334d; /* Darker grey */
            transition: all 0.3s ease;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        .btn-secondary:hover {
            background-color: #444466;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }
        .input-field {
            background-color: #33334d;
            border: 1px solid #555577;
            color: #e0e0e0;
            padding: 0.75rem 1rem;
            border-radius: 0.5rem;
            outline: none;
            transition: border-color 0.3s ease;
        }
        .input-field:focus {
            border-color: #8a2be2;
        }

        /* Main container styling for Lobby Page */
        .main-container {
            width: 100%;
            height: 100vh;
            display: flex;
            flex-direction: column;
            background-color: #1a1a2e; /* Match body background */
        }

        /* Header styling for Lobby Page */
        .lobby-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 2rem;
            background-color: #22223b; /* Darker header background */
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            border-bottom-left-radius: 0.5rem;
            border-bottom-right-radius: 0.5rem;
        }

        .lobby-header .left-section {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .lobby-header .right-section {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        /* Game modes navigation for Lobby Page */
        .game-modes-nav {
            display: flex;
            justify-content: center;
            gap: 1.5rem;
            padding: 1rem 0;
            background-color: #2a2a47; /* Slightly lighter background for nav */
            box-shadow: inset 0 -2px 5px rgba(0, 0, 0, 0.1);
            overflow-x: auto; /* Allow horizontal scrolling on small screens */
            -webkit-overflow-scrolling: touch; /* Smooth scrolling on iOS */
            white-space: nowrap; /* Prevent wrapping */
            padding-left: 2rem;
            padding-right: 2rem;
        }

        .game-modes-nav a {
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            color: #b0b0b0;
            font-weight: 500;
            transition: all 0.2s ease;
            white-space: nowrap; /* Keep text on one line */
        }

        .game-modes-nav a:hover {
            background-color: #3e3e60;
            color: #e0e0e0;
        }

        .game-modes-nav a.active {
            background-color: #8a2be2;
            color: white;
            font-weight: bold;
        }

        /* Main content area for Lobby Page */
        .content-area {
            flex-grow: 1;
            display: flex;
            flex-direction: column; /* Stack items vertically */
            align-items: center; /* Center items horizontally */
            justify-content: center; /* Center items vertically if space allows */
            padding: 2rem;
            gap: 2rem;
            overflow-y: auto;
            position: relative; /* For absolute positioning of sidebar */
        }

        /* Party section for Lobby Page */
        .party-section {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            align-items: center; /* Center children horizontally within party-section */
            justify-content: center; /* Center children vertically if space allows */
            height: 100%; /* Take full height of content-area */
            width: 100%; /* Take full width of content-area */
            max-width: 900px; /* Increased max width for better card layout */
            margin: 0 auto; /* Center party-section itself within content-area */
        }

        .party-controls {
            display: flex;
            align-items: center;
            gap: 1rem;
            background-color: #22223b;
            padding: 1rem 1.5rem;
            border-radius: 0.75rem;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            justify-content: center; /* Center content horizontally within party-controls */
            width: fit-content; /* Shrink to fit content */
            margin-left: auto; /* Auto margins for horizontal centering */
            margin-right: auto; /* Auto margins for horizontal centering */
            max-width: 90%; /* Prevent it from becoming too wide on smaller screens */
        }

        .party-code-input {
            background-color: #33334d;
            border: 1px solid #555577;
            color: #e0e0e0;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            outline: none;
            text-align: center;
        }

        .player-cards-container {
            display: flex;
            flex-wrap: wrap; /* Allow wrapping */
            justify-content: center; /* Center cards horizontally */
            gap: 1.5rem;
            width: 100%; /* Ensure it takes full width to allow centering of cards */
        }

        .player-card {
            background-color: #22223b;
            border-radius: 0.75rem;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            padding: 1rem; /* Reduced padding */
            text-align: center;
            width: 160px; /* Smaller width for cards */
            min-height: 200px; /* Smaller consistent height */
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            border: 2px solid transparent; /* Default border */
            transition: border-color 0.3s ease;
            position: relative; /* For crown positioning */
        }

        .player-card.active-player {
            border-color: #8a2be2; /* Highlight active player */
        }

        .player-card .player-icon {
            font-size: 3rem; /* Smaller icon size */
            margin-bottom: 0.5rem; /* Reduced margin */
            color: #e0e0e0; /* Default icon color */
        }

        .player-card h4 {
            font-size: 1.125rem; /* Equivalent to text-lg in Tailwind, smaller than text-xl */
            font-weight: bold;
            color: white;
        }

        .player-card .status-badge {
            background-color: #6ee7b7; /* Green for READY */
            color: #1a1a2e;
            padding: 0.25rem 0.75rem;
            border-radius: 9999px; /* Pill shape */
            font-size: 0.75rem;
            font-weight: bold;
            margin-top: 0.5rem;
        }
        .player-card .status-badge.not-ready {
            background-color: #fca5a5; /* Red for not ready */
        }

        /* Leader crown icon */
        .leader-crown {
            position: absolute;
            top: 5px;
            right: 5px;
            color: gold;
            font-size: 1.5rem;
            text-shadow: 0 0 5px rgba(0,0,0,0.5);
        }

        /* Kick button styling */
        .kick-button {
            background-color: #dc2626; /* Red color */
            color: white;
            padding: 0.3rem 0.6rem;
            border-radius: 0.375rem;
            font-size: 0.8rem;
            margin-top: 0.5rem;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        .kick-button:hover {
            background-color: #b91c1c;
        }
        .kick-button:disabled {
            background-color: #4a4a5a;
            cursor: not-allowed;
        }


        #lobbyPlayButton {
            background: linear-gradient(135deg, #8a2be2, #4b0082); /* Purple gradient */
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            color: white;
            font-size: 1.5rem; /* Reduced font size */
            padding: 0.75rem 3rem; /* Reduced padding */
            border-radius: 0.75rem;
            font-weight: bold;
            letter-spacing: 0.1em; /* Spacing between letters */
            margin-top: 1.5rem; /* Reduced margin top */
            cursor: pointer;
            border: none;
            outline: none;
            display: flex;
            align-items: center;
            justify-content: center;
            text-transform: uppercase;
        }

        #lobbyPlayButton:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }
        #lobbyPlayButton:disabled {
            background: #4a4a5a; /* Darker grey for disabled */
            cursor: not-allowed;
            box-shadow: none;
        }

        /* Online players sidebar for Lobby Page */
        .online-players-sidebar {
            position: absolute; /* Take out of normal flow */
            top: 2rem; /* Adjust as needed */
            right: 2rem; /* Adjust as needed */
            width: 300px; /* Fixed width */
            background-color: #22223b;
            border-radius: 0.75rem;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            padding: 1.5rem;
            overflow-y: auto;
            transition: visibility 0s, opacity 0.3s ease;
            opacity: 1;
            z-index: 20; /* Ensure it's on top */
        }
        .online-players-sidebar.hidden-content {
            visibility: hidden;
            opacity: 0;
        }

        .online-players-sidebar h3 {
            font-size: 1.25rem;
            font-weight: bold;
            margin-bottom: 1rem;
            border-bottom: 1px solid #444466;
            padding-bottom: 0.5rem;
            display: flex; /* Added flex for toggle button alignment */
            justify-content: space-between; /* Space between title and button */
            align-items: center;
        }

        .online-players-sidebar ul li {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 0;
            border-bottom: 1px dashed #33334d;
            font-size: 0.9rem;
        }
        .online-players-sidebar ul li:last-child {
            border-bottom: none;
        }

        .online-players-sidebar .player-status {
            color: #b0b0b0;
            font-size: 0.8rem;
        }

        /* Footer styling for Lobby Page */
        .lobby-footer {
            background-color: #22223b;
            padding: 1rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-top-left-radius: 0.5rem;
            border-top-right-radius: 0.5rem;
            box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.2);
            margin-top: auto; /* Push to bottom */
        }

        /* Game board specific styles */
        .game-board-grid {
            display: grid;
            grid-template-columns: repeat(11, 1fr); /* 11 columns */
            grid-template-rows: repeat(11, 1fr); /* 11 rows */
            width: 850px; /* Fixed size for the board */
            height: 850px; /* Fixed size for the board */
            background-color: #33334d; /* Board background */
            overflow: hidden;
            border: 2px solid #555577;
            margin: auto; /* Center the board */
        }

        .board-cell {
            background-color: #444466; /* Changed back to original color */
            border: 1px solid #555577; /* Changed back to original color */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 0.75rem; /* Kept original size */
            text-align: center;
            padding: 0.25rem; /* Kept original padding */
            position: relative;
            min-width: 0;
            min-height: 0;
            transition: background-color 0.2s ease-in-out;
        }

        /* Hover effect for board cells: change background color */
        .board-cell:hover {
            background-color: #555580; /* Slightly lighter shade on hover */
        }

        /* Player token styling */
        .player-token {
            position: absolute;
            width: 25px;
            height: 25px;
            border-radius: 50%;
            border: 2px solid #fff;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.7rem;
            font-weight: bold;
            color: white;
            z-index: 10;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            transition: all 0.5s ease-in-out;
        }

        /* Different colors for players (you can add more) */
        .player-color-1 { background-color: #FF0000; } /* Red */
        .player-color-2 { background-color: #0000FF; } /* Blue */
        .player-color-3 { background-color: #00FF00; } /* Green */
        .player-color-4 { background-color: #FFFF00; } /* Yellow */
        .player-color-5 { background-color: #FF4500; } /* OrangeRed */

        /* Player token movement animation */
        .player-token.moving {
            transform: scale(1.2);
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.7);
        }

        /* Current player highlight */
        .player-card.current-player-highlight {
            border-color: #6ee7b7;
            box-shadow: 0 0 20px rgba(110, 231, 183, 0.5);
        }
        .player-token.current-player-highlight {
            border-color: #6ee7b7;
            box-shadow: 0 0 10px rgba(110, 231, 183, 0.8);
        }

        /* Corner cells */
        .corner-cell {
            background-color: #555577;
            font-weight: bold;
            font-size: 1rem;
        }

        /* Explicit grid positioning for each cell type */
        /* Top Row (from right to left in RTL layout) */
        .cell-top-right-corner { grid-column: 11; grid-row: 1; }
        .cell-top-1 { grid-column: 10; grid-row: 1; }
        .cell-top-2 { grid-column: 9; grid-row: 1; }
        .cell-top-3 { grid-column: 8; grid-row: 1; }
        .cell-top-4 { grid-column: 7; grid-row: 1; }
        .cell-top-5 { grid-column: 6; grid-row: 1; } /* Water */
        .cell-top-6 { grid-column: 5; grid-row: 1; }
        .cell-top-7 { grid-column: 4; grid-row: 1; }
        .cell-top-8 { grid-column: 3; grid-row: 1; }
        .cell-top-9 { grid-column: 2; grid-row: 1; }
        .cell-top-left-corner { grid-column: 1; grid-row: 1; }

        /* Left Column (from top to bottom) */
        .cell-left-1 { grid-column: 1; grid-row: 2; }
        .cell-left-2 { grid-column: 1; grid-row: 3; }
        .cell-left-3 { grid-column: 1; grid-row: 4; }
        .cell-left-4 { grid-column: 1; grid-row: 5; }
        .cell-left-5 { grid-column: 1; grid-row: 6; } /* Electricity */
        .cell-left-6 { grid-column: 1; grid-row: 7; }
        .cell-left-7 { grid-column: 1; grid-row: 8; }
        .cell-left-8 { grid-column: 1; grid-row: 9; }
        .cell-left-9 { grid-column: 1; grid-row: 10; }

        /* Bottom Row (from left to right in RTL layout) */
        .cell-bottom-left-corner { grid-column: 1; grid-row: 11; }
        .cell-bottom-1 { grid-column: 2; grid-row: 11; }
        .cell-bottom-2 { grid-column: 3; grid-row: 11; }
        .cell-bottom-3 { grid-column: 4; grid-row: 11; }
        .cell-bottom-4 { grid-column: 5; grid-row: 11; }
        .cell-bottom-5 { grid-column: 6; grid-row: 11; } /* Internet */
        .cell-bottom-6 { grid-column: 7; grid-row: 11; }
        .cell-bottom-7 { grid-column: 8; grid-row: 11; }
        .cell-bottom-8 { grid-column: 9; grid-row: 11; }
        .cell-bottom-9 { grid-column: 10; grid-row: 11; }
        .cell-bottom-right-corner { grid-column: 11; grid-row: 11; }

        /* Right Column (from bottom to top) */
        .cell-right-1 { grid-column: 11; grid-row: 10; }
        .cell-right-2 { grid-column: 11; grid-row: 9; }
        .cell-right-3 { grid-column: 11; grid-row: 8; }
        .cell-right-4 { grid-column: 11; grid-row: 7; }
        .cell-right-5 { grid-column: 11; grid-row: 6; } /* Airport */
        .cell-right-6 { grid-column: 11; grid-row: 5; }
        .cell-right-7 { grid-column: 11; grid-row: 4; }
        .cell-right-8 { grid-column: 11; grid-row: 3; }
        .cell-right-9 { grid-column: 11; grid-row: 2; }

        /* Center area for play button and random number */
        .board-center {
            grid-column: 2 / span 9; /* Spans 9 columns from 2 to 10 */
            grid-row: 2 / span 9;    /* Spans 9 rows from 2 to 10 */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: #22223b; /* Darker center background */
            border-radius: 0.5rem;
            padding: 1rem;
        }

        .chat-window {
            height: 300px;
            background-color: #22223b;
            border-radius: 0.5rem;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .chat-messages {
            flex-grow: 1;
            padding: 1rem;
            overflow-y: auto;
            border-bottom: 1px solid #444466;
            display: flex;
            flex-direction: column; /* Ensure messages stack vertically */
        }

        .chat-input-container {
            display: flex;
            padding: 0.5rem;
            background-color: #33334d;
        }

        .chat-input {
            flex-grow: 1;
            background-color: #444466;
            border: none;
            border-radius: 0.25rem;
            padding: 0.5rem 1rem;
            color: #e0e0e0;
            outline: none;
        }
        .chat-input::placeholder {
            color: #b0b0b0;
        }

        .chat-send-btn {
            background-color: #8a2be2;
            color: white;
            border-radius: 0.25rem;
            padding: 0.5rem 1rem;
            margin-right: 0.5rem;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        .chat-send-btn:hover {
            background-color: #6a1bbd;
        }

        /* Property Details Modal Styles */
        .property-details-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #22223b;
            border-radius: 0.75rem;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
            padding: 1.5rem;
            z-index: 30;
            width: 90%;
            max-width: 450px;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            border: 2px solid #8a2be2;
        }
        .property-details-modal .close-btn {
            position: absolute;
            top: 0.75rem;
            right: 0.75rem;
            background: none;
            border: none;
            font-size: 1.5rem;
            color: #e0e0e0;
            cursor: pointer;
            transition: color 0.2s ease;
        }
        .property-details-modal .close-btn:hover {
            color: #ff0000;
        }
        .property-details-modal .rent-level-item {
            display: flex;
            justify-content: space-between;
            padding: 0.25rem 0;
            border-bottom: 1px dashed #444466;
        }
        .property-details-modal .rent-level-item:last-child {
            border-bottom: none;
        }
        .property-details-modal .rent-level-item.current-rent {
            font-weight: bold;
            color: #6ee7b7;
        }
        .property-details-modal .upgrade-controls button {
            background-color: #8a2be2;
            color: white;
            border-radius: 0.5rem;
            padding: 0.5rem 1rem;
            font-size: 1.25rem;
            transition: background-color 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.25rem;
        }
        .property-details-modal .upgrade-controls button:hover {
            background-color: #6a1bbd;
        }

        /* Money change effect in player list */
        .money-change {
            font-size: 0.8rem;
            font-weight: bold;
            margin-left: 5px;
            opacity: 0;
            transition: opacity 0.7s ease-out, transform 0.7s ease-out;
            position: relative;
            display: inline-block;
            min-width: 30px;
            text-align: right;
        }
        .money-change.plus {
            color: #6ee7b7;
        }
        .money-change.minus {
            color: #fca5a5;
        }
        .money-change.active {
            opacity: 1;
            transform: translateY(-3px);
        }

        .property-color-bar {
            width: 100%;
            height: 5px;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        /* Ensure content is above the color bar but below tokens */
        .board-cell > div:not(.property-color-bar):not(.player-token) {
            position: relative; /* Ensure z-index works */
            z-index: 2;
        }

        /* Responsive adjustments */
        @media (max-width: 1024px) {
            .game-board-grid {
                width: 800px;
                height: 800px;
            }
            .online-players-sidebar {
                position: relative;
                top: unset;
                right: unset;
                width: 100%;
                max-width: 100%;
                margin-top: 2rem;
            }
            .content-area {
                flex-direction: column;
                align-items: center;
                padding: 1rem;
            }
            .party-section {
                max-width: 100%; /* Allow it to take full width on smaller screens */
            }
            .player-cards-container {
                flex-direction: row;
                justify-content: center;
                flex-wrap: wrap;
            }
            .player-card {
                width: 140px; /* Adjusted for smaller screens */
                min-height: 180px; /* Adjusted for smaller screens */
                flex-shrink: 0;
            }
            .lobby-footer {
                flex-direction: column;
                gap: 1rem;
                text-align: center;
            }
            .game-modes-nav {
                justify-content: flex-start;
            }
        }

        @media (max-width: 768px) {
            .game-board-grid {
                width: 95vw;
                height: 95vw;
                max-width: 650px;
                max-height: 650px;
                font-size: 0.6rem;
            }
            .board-cell {
                padding: 0.1rem;
            }
            .corner-cell {
                font-size: 0.8rem;
            }
            .main-game-container {
                flex-direction: column;
            }
            .left-sidebar, .right-sidebar {
                width: 100%;
                margin-top: 1rem;
            }
            .property-details-modal {
                width: 95%;
                padding: 1rem;
            }
        }

        @media (max-width: 640px) {
            .lobby-header {
                padding: 0.75rem 1rem;
            }
            .lobby-header .play-button {
                padding: 0.5rem 1rem;
                font-size: 1rem;
            }
            .game-modes-nav {
                padding-left: 1rem;
                padding-right: 1rem;
            }
            .game-modes-nav a {
                padding: 0.4rem 0.8rem;
                font-size: 0.8rem;
            }
            .content-area {
                padding: 0.75rem;
            }
            .party-controls {
                flex-direction: column;
                gap: 0.75rem;
                width: 100%;
                max-width: 350px;
            }
            .party-code-input {
                width: 100%;
            }
        }

        /* New styles for horizontal pending trades */
        .pending-trades-container {
            display: flex;
            flex-wrap: wrap; /* Allow wrapping onto multiple lines if needed */
            gap: 0.5rem; /* Smaller gap between trade offers */
            overflow-x: auto; /* Enable horizontal scrolling if content overflows */
            -webkit-overflow-scrolling: touch; /* Smooth scrolling on iOS */
            padding-bottom: 0.5rem; /* Add some padding for scrollbar */
        }

        .pending-trade-item {
            background-color: #33334d;
            border-radius: 0.375rem; /* Smaller rounded corners */
            padding: 0.5rem 0.75rem; /* Smaller padding */
            font-size: 0.75rem; /* Smaller font size */
            color: #b0b0b0;
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.1s ease;
            white-space: nowrap; /* Keep text on one line */
            flex-shrink: 0; /* Prevent items from shrinking */
            min-width: 120px; /* Minimum width for each item */
            text-align: center;
        }

        .pending-trade-item:hover {
            background-color: #444466;
            transform: translateY(-1px);
        }

        .pending-trade-item .trade-summary {
            display: block;
            font-weight: bold;
            color: #e0e0e0;
            margin-bottom: 0.25rem;
        }
        .pending-trade-item .trade-details {
            display: block;
            font-size: 0.65rem; /* Even smaller font for details */
            color: #909090;
        }

        /* Login/Signup Modal Styles */
        .auth-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.75);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
        .auth-modal-content {
            background-color: #22223b;
            padding: 2rem;
            border-radius: 0.75rem;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
            width: 90%;
            max-width: 400px;
            text-align: center;
            position: relative;
        }
        .auth-modal-content .close-btn {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: none;
            border: none;
            font-size: 1.5rem;
            color: #e0e0e0;
            cursor: pointer;
            transition: color 0.2s ease;
        }
        .auth-modal-content .close-btn:hover {
            color: #ff0000;
        }
    </style>
</head>
<body dir="ltr">
    <!-- Login/Signup Modal -->
    <div id="authModal" class="auth-modal">
        <div class="auth-modal-content">
            <button class="close-btn" id="closeAuthModalBtn">&times;</button>
            <h2 id="authModalTitle" class="text-2xl font-bold text-white mb-6">تسجيل الدخول</h2>

            <!-- Login Form -->
            <div id="authLoginForm">
                <div class="mb-4 text-left">
                    <label for="authUsername" class="block text-gray-300 text-sm font-bold mb-2">اسم المستخدم:</label>
                    <input type="text" id="authUsername" class="input-field w-full" placeholder="أدخل اسم المستخدم" />
                </div>
                <div class="mb-6 text-left">
                    <label for="authPassword" class="block text-gray-300 text-sm font-bold mb-2">كلمة المرور:</label>
                    <input type="password" id="authPassword" class="input-field w-full" placeholder="أدخل كلمة المرور" />
                </div>
                <div id="authError" class="hidden bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded-lg relative mb-4" role="alert">
                    <span id="authErrorMessage"></span>
                </div>
                <button id="loginAuthBtn" class="btn-primary w-full py-2 rounded-md mb-4">تسجيل الدخول</button>
                <button id="showSignupBtn" class="btn-secondary w-full py-2 rounded-md">ليس لديك حساب؟ إنشاء حساب</button>
            </div>

            <!-- Signup Form -->
            <div id="authSignupForm" class="hidden">
                <div class="mb-4 text-left">
                    <label for="signupUsername" class="block text-gray-300 text-sm font-bold mb-2">اسم المستخدم:</label>
                    <input type="text" id="signupUsername" class="input-field w-full" placeholder="اختر اسم مستخدم فريد" />
                </div>
                <div class="mb-4 text-left">
                    <label for="signupPassword" class="block text-gray-300 text-sm font-bold mb-2">كلمة المرور:</label>
                    <input type="password" id="signupPassword" class="input-field w-full" placeholder="أدخل كلمة المرور (6 أحرف على الأقل)" />
                </div>
                <div class="mb-6 text-left">
                    <label for="signupConfirmPassword" class="block text-gray-300 text-sm font-bold mb-2">تأكيد كلمة المرور:</label>
                    <input type="password" id="signupConfirmPassword" class="input-field w-full" placeholder="أعد إدخال كلمة المرور" />
                </div>
                <div id="signupError" class="hidden bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded-lg relative mb-4" role="alert">
                    <span id="signupErrorMessage"></span>
                </div>
                <button id="signupAuthBtn" class="btn-primary w-full py-2 rounded-md mb-4">إنشاء حساب</button>
                <button id="showLoginBtn" class="btn-secondary w-full py-2 rounded-md">بالفعل لديك حساب؟ تسجيل الدخول</button>
            </div>
        </div>
    </div>

    <div id="lobbyPage" class="main-container hidden">
        <header class="lobby-header">
            <div class="left-section">
                <button class="text-gray-300 hover:text-white transition-colors duration-200" id="backButton">
                    <i class="fas fa-arrow-left mr-2"></i> <span id="backButtonText">BACK</span>
                </button>
                <span class="text-xl font-bold text-white" id="lobbyTitle">LOBBY</span>
            </div>
            <div class="right-section">
                <span class="text-gray-300">
                    <i class="fas fa-users mr-1"></i> <span id="lobbyPlayerCount">0/5</span>
                </span>
                <span class="text-green-400 font-bold">
                    <i class="fas fa-coins mr-1"></i> <span id="lobbyPlayerMoney">0</span>
                </span>
                <button id="toggleOnlinePlayers" class="text-gray-400 hover:text-white text-sm ml-2">
                    <i class="fas fa-eye"></i>
                </button>
                <button id="settingsBtn" class="text-gray-400 hover:text-white text-sm ml-2">
                    <i class="fas fa-cog"></i>
                </button>
                <button id="logoutLobbyBtn" class="text-red-400 hover:text-red-200 text-sm ml-2">
                    <i class="fas fa-sign-out-alt"></i>
                </button>
            </div>
        </header>

        <nav class="game-modes-nav">
            <a href="#" class="active" id="unratedMode">UNRATED</a>
            <a href="#" id="competitiveMode">COMPETITIVE</a>
            </nav>

        <div class="content-area">
            <div class="party-section">
                <div class="party-controls">
                    <label class="flex items-center space-x-2 cursor-pointer">
                        <input type="checkbox" class="toggle-checkbox hidden" id="closedPartyToggle">
                        <div class="toggle-switch relative w-10 h-6 bg-gray-600 rounded-full shadow-inner">
                            <div class="toggle-dot absolute w-4 h-4 bg-white rounded-full shadow inset-y-1 left-1 transition-all duration-300 ease-in-out"></div>
                        </div>
                        <span class="text-gray-300" id="closedPartyText">CLOSED PARTY</span>
                    </label>
                    <input type="text" placeholder="PARTY CODE" class="party-code-input" id="partyCodeInput" />
                </div>

                <div class="player-cards-container" id="lobbyPlayerCardsContainer">
                    </div>

                <button id="lobbyPlayButton">
                    PLAY
                </button>
                <p id="lobbyMessage" class="text-yellow-400 mt-4 hidden">Searching for players...</p>
            </div>

            <div class="online-players-sidebar hidden-content" id="onlinePlayersSidebar">
                <h3 id="onlinePlayersTitle">ONLINE <span class="text-green-400">(0)</span>
                </h3>
                <ul id="onlinePlayersList">
                    </ul>
            </div>
        </div>

        <footer class="lobby-footer">
            </footer>
    </div>

    <div id="gamePage" class="hidden flex flex-col items-center justify-center min-h-screen p-4 md:p-8 w-full overflow-auto">
        <header class="w-full flex justify-center items-center mb-6">
            </header>

        <div class="flex flex-col lg:flex-row gap-6 justify-center items-center w-full">
            <div class="left-sidebar w-full lg:w-1/4 flex flex-col gap-4">
                <div class="bg-[#22223b] p-4 rounded-lg shadow-md">
                    <h3 class="text-lg font-bold mb-2" id="shareGameTitle">Share This Game</h3>
                    <input type="text" value="https://truwpi.io/room/gameid" readonly class="input-field w-full mb-3 text-sm" />
                    <div class="flex gap-2">
                        <button class="btn-secondary w-full py-2 rounded-md" id="copyButton"><i class="fas fa-copy mr-2"></i> <span id="copyButtonText">Copy</span></button>
                        <button class="btn-secondary w-full py-2 rounded-md" id="roomSettingsButton"><i class="fas fa-cog mr-2"></i> <span id="roomSettingsButtonText">Room Settings</span></button>
                    </div>
                </div>

                <div class="bg-[#22223b] p-4 rounded-lg shadow-md">
                    <h3 class="text-lg font-bold mb-2" id="userIdTitle">User ID</h3>
                    <p id="currentUserIdDisplay" class="text-sm text-gray-400 break-all">Not Available (No Database Connection)</p>
                </div>

                <div class="chat-window shadow-md">
                    <div class="chat-messages text-sm" id="chatMessages">
                        <p class="text-gray-400" id="chatUnavailableText">Chat is currently unavailable (No Database Connection).</p>
                        </div>
                    <div class="chat-input-container">
                        <input type="text" id="chatInput" placeholder="Say something..." class="chat-input" disabled />
                        <button id="chatSendBtn" class="chat-send-btn" disabled><span id="sendButtonText">Send</span></button>
                    </div>
                </div>
            </div>

            <div class="game-board-container flex-grow flex justify-center items-center relative">
                <div class="game-board-grid relative">
                    </div>
                <div id="buyPropertyModal" class="absolute inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center z-20 hidden">
                    <div class="bg-[#22223b] p-6 rounded-lg shadow-xl text-center w-80">
                        <h3 class="text-xl font-bold mb-4" id="propertyModalTitle"></h3>
                        <p class="text-gray-300 mb-2" id="propertyModalPriceLabel">Price: <span id="propertyModalPrice" class="text-green-400 font-bold"></span></p>
                        <p class="text-gray-300 mb-4" id="playerCurrentMoneyLabel">Current Money: <span id="playerCurrentMoney" class="text-green-400 font-bold"></span></p>
                        <div class="flex justify-center gap-4">
                            <button id="buyPropertyBtn" class="btn-primary py-2 px-6 rounded-md"><span id="buyButtonText">Buy</span></button>
                            <button id="cancelBuyBtn" class="btn-secondary py-2 px-6 rounded-md"><span id="passButtonText">Pass</span></button>
                        </div>
                    </div>
                </div>

                <div id="propertyDetailsModal" class="property-details-modal hidden">
                    <button class="close-btn" onclick="document.getElementById('propertyDetailsModal').classList.add('hidden');">&times;</button>
                    <div class="flex items-center justify-center gap-3 mb-2">
                        <div id="propertyDetailIcon"></div>
                        <h3 class="text-2xl font-bold text-white text-center" id="propertyDetailName"></h3>
                    </div>
                    <p class="text-gray-300 text-center text-lg" id="propertyDetailPriceLabel">Price: <span id="propertyDetailPrice" class="text-green-400 font-bold"></span></p>

                    <div class="bg-[#33334d] p-4 rounded-md">
                        <h4 class="text-md font-bold mb-2 text-white" id="rentLevelsTitle">Rent Levels:</h4>
                        <ul id="propertyRentLevels">
                            </ul>
                    </div>

                    <div id="upgradeSection" class="flex flex-col items-center gap-2">
                        <p class="text-gray-300 text-center text-md" id="currentUpgradeLevelDisplayLabel">Current Level: <span id="currentUpgradeLevelDisplay" class="font-bold"></span></p>
                        <div class="upgrade-controls flex gap-4">
                            <button id="downgradePropertyBtn" class="py-2 px-4 rounded-md">
                                <i class="fas fa-arrow-down"></i> <span id="downgradeRefundText"></span>
                            </button>
                            <button id="upgradePropertyBtn" class="py-2 px-4 rounded-md">
                                <i class="fas fa-arrow-up"></i> <span id="upgradeCostText"></span>
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <div class="right-sidebar w-full lg:w-1/4 flex flex-col gap-4">
                <div class="bg-[#22223b] p-4 rounded-lg shadow-md">
                    <h3 class="text-lg font-bold mb-2" id="playersTitle">Players</h3>
                    <ul id="playersList">
                        </ul>
                </div>

                <div class="bg-[#22223b] p-4 rounded-lg shadow-md">
                    <h3 class="text-lg font-bold mb-2" id="tradesTitle">Trades</h3>
                    <p class="text-sm text-gray-400 mb-3" id="makeTradeText">
                        Make trades with other players to exchange properties, money, bonus cards.
                    </p>
                    <p class="text-sm text-gray-400 mb-3" id="useCreateText">
                        Use the "Create" button to initiate a new trade.
                    </p>
                    <button class="btn-primary w-full py-2 rounded-md" onclick="openTradeCreationModal(gameState.players[gameState.currentPlayerIndex].id)"><i class="fas fa-plus mr-2"></i> <span id="createButtonText">Create</span></button>
                </div>

                <div class="bg-[#22223b] p-4 rounded-lg shadow-md">
                    <h3 class="text-lg font-bold mb-2" id="pendingTradesTitle">Pending Trades (<span id="pendingTradesCount">0</span>)</h3>
                    <div id="pendingTradesList" class="pending-trades-container">
                        <p class="text-gray-400" id="noPendingTradesText">No pending trades.</p>
                    </div>
                </div>

                <div class="bg-[#22223b] p-4 rounded-lg shadow-md">
                    <h3 class="text-lg font-bold mb-2" id="myPropertiesTitle">My Properties (<span id="myPropertiesCount">0</span>)</h3>
                    <ul id="myPropertiesList" class="text-sm text-gray-400">
                        <li id="noPropertiesText">No properties currently.</li>
                    </ul>
                    <button class="btn-secondary w-full py-2 rounded-md mt-4" onclick="openSellPropertyModal()"><i class="fas fa-hand-holding-usd mr-2"></i> <span id="sellPropertyButtonText">Sell Property</span></button>
                </div>
            </div>
        </div>
    </div>

    <div id="tradeCreationModal" class="fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center z-40 hidden">
        <div class="bg-[#22223b] p-6 rounded-lg shadow-xl text-center w-11/12 max-w-lg relative">
            <h3 class="text-xl font-bold mb-4" id="createTradeOfferTitle">Create Trade Offer</h3>
            <button class="close-btn absolute top-3 right-3 text-gray-400 hover:text-white" onclick="document.getElementById('tradeCreationModal').classList.add('hidden');">&times;</button>
            <input type="hidden" id="tradeOfferIdToModify" value="">

            <div class="mb-4 text-left">
                <label for="tradeRecipient" class="block text-gray-300 text-sm font-bold mb-2" id="tradeWithLabel">Trade with:</label>
                <select id="tradeRecipient" class="input-field w-full"></select>
            </div>

            <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                <div class="bg-[#33334d] p-4 rounded-md text-left">
                    <h4 class="font-bold mb-2" id="youOfferTitle">You Offer:</h4>
                    <label for="offerMoney" class="block text-gray-300 text-xs mb-1" id="offerMoneyLabel">Money:</label>
                    <input type="number" id="offerMoney" class="input-field w-full mb-2" value="0" min="0">
                    <p class="text-gray-300 text-xs mb-1" id="yourPropertiesLabel">Your Properties:</p>
                    <div id="offeredPropertiesList" class="max-h-32 overflow-y-auto border border-gray-600 rounded-md p-2 text-sm">
                        <p class="text-gray-400" id="noPropertiesToOfferText">No properties to offer.</p>
                    </div>
                </div>

                <div class="bg-[#33334d] p-4 rounded-md text-left">
                    <h4 class="font-bold mb-2" id="youRequestTitle">You Request:</h4>
                    <label for="requestMoney" class="block text-gray-300 text-xs mb-1" id="requestMoneyLabel">Money:</label>
                    <input type="number" id="requestMoney" class="input-field w-full mb-2" value="0" min="0">
                    <p class="text-gray-300 text-xs mb-1" id="theirPropertiesLabel">Their Properties:</p>
                    <div id="requestedPropertiesList" class="max-h-32 overflow-y-auto border border-gray-600 rounded-md p-2 text-sm">
                        <p class="text-gray-400" id="noPropertiesToRequestText">No properties to request from this player.</p>
                    </div>
                </div>
            </div>

            <button id="sendTradeOfferBtn" class="btn-primary py-2 px-6 rounded-md w-full"><span id="sendOfferButtonText">Send Offer</span></button>
        </div>
    </div>

    <div id="incomingTradeOfferModal" class="fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center z-40 hidden">
        <div class="bg-[#22223b] p-6 rounded-lg shadow-xl text-center w-11/12 max-w-md relative">
            <h3 class="text-xl font-bold mb-4" id="incomingTradeOfferTitle">Incoming Trade Offer</h3>
            <button class="close-btn absolute top-3 right-3 text-gray-400 hover:text-white" onclick="document.getElementById('incomingTradeOfferModal').classList.add('hidden');">&times;</button>
            <p class="text-gray-300 mb-2" id="offerFromLabel">From: <span id="offerSenderName" class="font-bold"></span></p>

            <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                <div class="bg-[#33334d] p-4 rounded-md text-left">
                    <h4 class="font-bold mb-2" id="theyOfferTitle">They Offer:</h4>
                    <p class="text-gray-300 text-sm mb-1" id="offerReceivedMoneyLabel">Money: $<span id="offerReceivedMoney"></span></p>
                    <p class="text-gray-300 text-sm mb-1" id="offerReceivedPropertiesLabel">Properties:</p>
                    <ul id="offerReceivedProperties" class="list-disc list-inside text-sm text-gray-400"></ul>
                </div>
                <div class="bg-[#33334d] p-4 rounded-md text-left">
                    <h4 class="font-bold mb-2" id="theyRequestTitle">They Request:</h4>
                    <p class="text-gray-300 text-sm mb-1" id="requestSentMoneyLabel">Money: $<span id="requestSentMoney"></span></p>
                    <p class="text-gray-300 text-sm mb-1" id="requestSentPropertiesLabel">Properties:</p>
                    <ul id="requestSentProperties" class="list-disc list-inside text-sm text-gray-400"></ul>
                </div>
            </div>

            <div class="flex justify-center gap-4">
                <button id="acceptTradeBtn" class="btn-primary py-2 px-6 rounded-md"><span id="acceptButtonText">Accept</span></button>
                <button id="declineTradeBtn" class="btn-secondary py-2 px-6 rounded-md"><span id="declineButtonText">Decline</span></button>
                </div>
        </div>
    </div>

    <div id="tradeDetailsViewModal" class="fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center z-40 hidden">
        <div class="bg-[#22223b] p-6 rounded-lg shadow-xl text-center w-11/12 max-w-md relative">
            <h3 class="text-xl font-bold mb-4" id="tradeDetailsViewTitle">Trade Offer Details</h3>
            <button class="close-btn absolute top-3 right-3 text-gray-400 hover:text-white" onclick="document.getElementById('tradeDetailsViewModal').classList.add('hidden');">&times;</button>
            <p class="text-gray-300 mb-2" id="tradeDetailsHeader"><span id="tradeDetailsSenderName" class="font-bold"></span> <span id="tradeDetailsToText"></span> <span id="tradeDetailsRecipientName" class="font-bold"></span></p>

            <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                <div class="bg-[#33334d] p-4 rounded-md text-left">
                    <h4 class="font-bold mb-2" id="offeringTitle">Offering:</h4>
                    <p class="text-gray-300 text-sm mb-1" id="tradeDetailsOfferedMoneyLabel">Money: $<span id="tradeDetailsOfferedMoney"></span></p>
                    <p class="text-gray-300 text-sm mb-1" id="tradeDetailsOfferedPropertiesLabel">Properties:</p>
                    <ul id="tradeDetailsOfferedProperties" class="list-disc list-inside text-sm text-gray-400"></ul>
                </div>
                <div class="bg-[#33334d] p-4 rounded-md text-left">
                    <h4 class="font-bold mb-2" id="requestingTitle">Requesting:</h4>
                    <p class="text-gray-300 text-sm mb-1" id="tradeDetailsRequestedMoneyLabel">Money: $<span id="tradeDetailsRequestedMoney"></span></p>
                    <p class="text-gray-300 text-sm mb-1" id="tradeDetailsRequestedPropertiesLabel">Properties:</p>
                    <ul id="tradeDetailsRequestedProperties" class="list-disc list-inside text-sm text-gray-400"></ul>
                </div>
            </div>

            <div id="tradeDetailsActionButtons" class="flex justify-center gap-4">
                </div>
        </div>
    </div>

    <div id="sellPropertyModal" class="fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center z-40 hidden">
        <div class="bg-[#22223b] p-6 rounded-lg shadow-xl text-center w-11/12 max-w-lg relative">
            <h3 class="text-xl font-bold mb-4" id="sellPropertiesTitle">Sell Properties</h3>
            <button class="close-btn absolute top-3 right-3 text-gray-400 hover:text-white" onclick="document.getElementById('sellPropertyModal').classList.add('hidden');">&times;</button>

            <div id="propertiesToSellList" class="max-h-64 overflow-y-auto border border-gray-600 rounded-md p-2 text-sm mb-4">
                <p class="text-gray-400" id="noPropertiesToSellText">No properties to sell.</p>
            </div>

            <button id="confirmSellPropertiesBtn" class="btn-primary py-2 px-6 rounded-md w-full"><span id="sellSelectedPropertiesButtonText">Sell Selected Properties</span></button>
        </div>
    </div>

    <div id="settingsModal" class="fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center z-50 hidden">
        <div class="bg-[#22223b] p-6 rounded-lg shadow-xl text-center w-11/12 max-w-sm relative">
            <h3 class="text-xl font-bold mb-4" id="settingsModalTitle">Settings</h3>
            <div class="mb-4 text-left">
                <label for="languageSelect" class="block text-gray-300 text-sm font-bold mb-2" id="languageLabel">Language:</label>
                <select id="languageSelect" class="input-field w-full">
                    <option value="en" id="langOptionEn">English</option>
                    <option value="ar" id="langOptionAr">العربية</option>
                </select>
            </div>
            <div class="flex justify-center gap-4">
                <button id="applySettingsBtn" class="btn-primary py-2 px-6 rounded-md"><span id="applyButtonText">Apply</span></button>
                <button id="closeSettingsBtn" class="btn-secondary py-2 px-6 rounded-md"><span id="closeButtonText">Close</span></button>
            </div>
        </div>
    </div>

    <script type="module">
        // Debugging: Log script start
        console.log("Script execution started.");

        // Firebase SDKs for Firestore
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import {
            getFirestore,
            collection,
            doc,
            getDoc,
            setDoc,
            addDoc,
            query,
            where,
            getDocs,
            onSnapshot,
            updateDoc,
            deleteDoc
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Firebase Configuration (updated with user's provided config)
        const firebaseConfig = {
            apiKey: "AIzaSyDBw9rCwNV-3vfQ9GrgD03kJ4C42yT3aPs",
            authDomain: "bank-e7c89.firebaseapp.com",
            projectId: "bank-e7c89",
            storageBucket: "bank-e7c89.firebasestorage.app",
            messagingSenderId: "634088407451",
            appId: "1:634088407451:web:7c98a8aff0623c9339613e",
            measurementId: "G-EJ8WZJ8L6F"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);

        // Global App ID for Firestore paths (provided by Canvas environment)
        const __app_id = "truwpi-game"; // Using a fixed app ID for demo purposes
        const usersCollectionRef = collection(db, `artifacts/${__app_id}/public/data/users`);
        const gamesCollectionRef = collection(db, `artifacts/${__app_id}/public/data/games`);

        // Game State Object
        const gameState = {
            currentUser: null, // Stores the currently logged-in user's data from Firestore
            currentGameId: null, // The ID of the game the current user is in
            players: [], // Players in the current game
            currentPlayerIndex: 0,
            boardProperties: {}, // To store ownership of properties
            boardCellsInfo: [], // To store details of each cell including price and owner
            STARTING_MONEY: 5000,
            PASS_GO_MONEY: 500,
            pendingTradeOffers: [],
            currentActiveTradeOffer: null,
            leaderId: null, // ID of the current game leader (host)
            currentLanguage: 'en', // Default language
            onlineUsersListener: null, // Firestore listener for online users
            currentGameListener: null // Firestore listener for the current game
        };

        const MAX_PLAYERS_PER_GAME = 5; // Maximum number of players allowed in a game

        // Timer variables
        let turnTimer = null;
        let timeLeft = 0;
        const TURN_DURATION_SECONDS = 90; // 1.5 minutes

        // Translation dictionary
        const translations = {
            en: {
                // ... (existing English translations) ...
                back: "BACK",
                lobby: "LOBBY",
                unrated: "UNRATED",
                competitive: "COMPETITIVE",
                closedParty: "CLOSED PARTY",
                partyCode: "PARTY CODE",
                addPlayer: "Add Player", // This will be removed, but kept for translation consistency
                play: "PLAY",
                online: "ONLINE",
                money: "Money",
                ready: "Ready",
                userId: "User ID",
                shareGame: "Share This Game",
                copy: "Copy",
                roomSettings: "Room Settings",
                saySomething: "Say something...",
                send: "Send",
                players: "Players",
                trades: "Trades",
                create: "Create",
                pendingTrades: "Pending Trades",
                myProperties: "My Properties",
                sellProperty: "Sell Property",
                noProperties: "No properties currently.",
                noPendingTrades: "No pending trades.",
                start: "Start",
                surprise: "Surprise",
                goToJail: "Go to Jail",
                vacation: "Vacation",
                water: "Water",
                electricity: "Electricity",
                internet: "Internet",
                airport: "Airport",
                timeExpired: (playerName) => `${playerName}'s turn time expired! They have been removed from the game.`,
                allPlayersRemoved: "All players have been removed. Game Over!",
                playerPassedStart: (playerName, amount) => `Player ${playerName} passed Start and collected $${amount}!`,
                playerInDebt: (playerName, balance) => `${playerName}, you are in debt! You cannot play until your balance is non-negative. Sell properties to clear your debt. Your balance: $${balance}.`,
                landedOnUnowned: (propertyName) => `Landed on unowned property: ${propertyName}.`,
                landedOnOwned: (propertyName, ownerName, rent, playerName) => `${playerName} landed on ${propertyName}, owned by ${ownerName}. Paid rent $${rent}.`,
                landedOnOwn: (propertyName) => `You landed on your own property: ${propertyName}.`,
                landedOnJail: (playerName) => `${playerName} went to Jail! (Jail logic not yet implemented)`,
                landedOnSurprise: (playerName) => `${playerName} landed on Surprise! (Surprise logic not yet implemented)`,
                landedOnVacation: (playerName) => `${playerName} is on Vacation!`,
                landedOnMisc: (content) => `You landed on: ${content}`,
                buyPropertyQuestion: (propertyName) => `Do you want to buy ${propertyName}?`,
                price: "Price",
                currentMoney: "Current Money",
                buy: "Buy",
                pass: "Pass",
                playerBought: (playerName, propertyName, price) => `${playerName} bought ${propertyName} for $${price}!`,
                playerPassed: (playerName, propertyName) => `${playerName} decided to pass on ${propertyName}.`,
                notOwnedOrExists: "You do not own this city or it does not exist!",
                mustOwnAllCities: (country) => `You must own all cities in ${country} to upgrade this property!`,
                maxLevel: "Property is already at maximum upgrade level!",
                notEnoughMoney: "You do not have enough money to upgrade this property!",
                playerUpgraded: (playerName, propertyName, level) => `${playerName} upgraded ${propertyName}! Current Level: ${level}`,
                minLevel: "Property is at base level, cannot downgrade further!",
                playerDowngraded: (playerName, propertyName, amount, level) => `${playerName} downgraded ${propertyName} and received $${amount}! Current Level: ${level}`,
                sellProperties: "Sell Properties",
                sellSelected: "Sell Selected Properties",
                noPropertiesToSell: "You have no properties to sell.",
                selectAtLeastOne: "Please select at least one property to sell.",
                playerSold: (playerName, count, amount, balance) => `${playerName} sold ${count} property(ies) and received $${amount}! Your current balance: $${balance}`,
                maxPlayersReached: "Maximum number of players reached!",
                addAtLeastOnePlayer: "Please add at least one player to start the game.",
                turnEnded: (currentPlayerName, nextPlayerName) => `Turn ended for ${currentPlayerName}. It's now ${nextPlayerName}'s turn.`,
                createTradeOffer: "Create Trade Offer",
                tradeWith: "Trade with:",
                youOffer: "You Offer:",
                money: "Money",
                yourProperties: "Your Properties:",
                noPropertiesToOffer: "No properties to offer.",
                youRequest: "You Request:",
                theirProperties: "Their Properties:",
                noPropertiesToRequest: "No properties to request from this player.",
                sendOffer: "Send Offer",
                selectRecipient: "Please select a trade recipient.",
                specifyItems: "Please specify at least one item to offer or request.",
                insufficientMoneyOffer: "You do not have enough money to offer this amount.",
                onlyOwnProperties: "You can only offer properties that you own.",
                onlyRequestOwned: "You can only request properties owned by the selected player.",
                offerSent: (recipientName) => `Trade offer sent to ${recipientName}!`,
                incomingTradeOffer: "Incoming Trade Offer",
                from: "From:",
                theyOffer: "They Offer:",
                none: "None",
                theyRequest: "They Request:",
                accept: "Accept",
                decline: "Decline",
                tradeError: "Error: Sender or recipient not found for trade.",
                senderInsufficientMoney: (senderName) => `${senderName} does not have enough money to complete this trade.`,
                recipientInsufficientMoney: (recipientName) => `${recipientName} does not have enough money to complete this trade.`,
                senderMissingProps: (senderName) => `${senderName} no longer owns some of the properties they are offering.`,
                recipientMissingProps: (recipientName) => `${recipientName} no longer owns some of the properties requested from them.`,
                tradeAccepted: (senderName, recipientName) => `Trade between ${senderName} and ${recipientName} accepted!`,
                tradeDeclined: (senderName, recipientName) => `Trade offer from ${senderName} to ${recipientName} declined.`,
                tradeCancelled: (senderName, recipientName) => `Trade offer from ${senderName} to ${recipientName} cancelled.`,
                tradeNotFound: "Trade offer not found.",
                tradeDetails: "Trade Offer Details",
                to: "To:",
                offering: "Offering:",
                requesting: "Requesting:",
                modify: "Modify",
                cancel: "Cancel",
                currentLevel: "Current Level:",
                baseRent: "Base Rent",
                level: "Level",
                max: "Max",
                min: "Min",
                makeTrade: "Make trades with other players to exchange properties, money, bonus cards.",
                useCreate: "Use the \"Create\" button to initiate a new trade.",
                aiPlayer: (id) => `AI Player ${id}`,
                settings: "Settings",
                language: "Language",
                english: "English",
                arabic: "العربية",
                apply: "Apply",
                close: "Close",
                kick: "Kick",
                confirmKick: (playerName) => `Are you sure you want to kick ${playerName} from the lobby?`,
                leader: "Leader",
                playerKicked: (playerName) => `${playerName} has been kicked from the lobby.`,
                onlyLeaderCanKick: "Only the party leader can kick players.",
                username: "Username",
                password: "Password",
                confirmPassword: "Confirm Password",
                login: "Login",
                createAccount: "Create Account",
                alreadyHaveAccount: "Already have an account? Login",
                dontHaveAccount: "Don't have an account? Create Account",
                invalidCredentials: "Invalid username or password.",
                usernameTaken: "Username is already taken.",
                passwordsMismatch: "Passwords do not match.",
                passwordTooShort: "Password must be at least 6 characters long.",
                loggedInAs: (username) => `Logged in as: ${username}`,
                searchingForPlayers: "Searching for players...",
                noOtherPlayers: "No other players online to trade with.",
                prop: "prop",
                props: "props",
                offer: "Offer",
                request: "Request",
                modifyTradeOffer: "Modify Trade Offer",
                notLoggedIn: "You are not logged in.",
                welcome: "Welcome",
                guestUser: "Guest User",
                yourUserId: "Your User ID",
                logout: "Logout",
                chatUnavailable: "Chat is currently unavailable (No Database Connection)."
            },
            ar: {
                back: "العودة",
                lobby: "الردهة",
                unrated: "غير مصنف",
                competitive: "تنافسي",
                closedParty: "حفلة مغلقة",
                partyCode: "رمز الحفلة",
                addPlayer: "إضافة لاعب",
                play: "العب",
                online: "متصل",
                money: "المال",
                ready: "جاهز",
                userId: "معرف المستخدم",
                shareGame: "مشاركة هذه اللعبة",
                copy: "نسخ",
                roomSettings: "إعدادات الغرفة",
                saySomething: "قل شيئًا...",
                send: "إرسال",
                players: "اللاعبون",
                trades: "الصفقات",
                create: "إنشاء",
                pendingTrades: "الصفقات المعلقة",
                myProperties: "ممتلكاتي",
                sellProperty: "بيع ممتلكات",
                noProperties: "لا توجد ممتلكات حاليًا.",
                noPendingTrades: "لا توجد صفقات معلقة.",
                start: "البداية",
                surprise: "مفاجأة",
                goToJail: "اذهب إلى السجن",
                vacation: "إجازة",
                water: "الماء",
                electricity: "الكهرباء",
                internet: "الإنترنت",
                airport: "المطار",
                timeExpired: (playerName) => `انتهى وقت دور ${playerName}! لقد تم إزالته من اللعبة.`,
                allPlayersRemoved: "تمت إزالة جميع اللاعبين. انتهت اللعبة!",
                playerPassedStart: (playerName, amount) => `مر اللاعب ${playerName} على البداية وجمع $${amount}!`,
                playerInDebt: (playerName, balance) => `أيها اللاعب ${playerName}، أنت مدين! لا يمكنك اللعب حتى يصبح رصيدك غير سالب. قم ببيع الممتلكات لتسوية دينك. رصيدك الحالي: $${balance}.`,
                landedOnUnowned: (propertyName) => `هبطت على عقار غير مملوك: ${propertyName}.`,
                landedOnOwned: (propertyName, ownerName, rent, playerName) => `هبط ${playerName} على ${propertyName}، المملوك لـ ${ownerName}. دفع إيجار $${rent}.`,
                landedOnOwn: (propertyName) => `لقد هبطت على عقارك الخاص: ${propertyName}.`,
                landedOnJail: (playerName) => `ذهب ${playerName} إلى السجن! (لم يتم تنفيذ منطق السجن بعد)`,
                landedOnSurprise: (playerName) => `هبط ${playerName} على مفاجأة! (لم يتم تنفيذ منطق المفاجأة بعد)`,
                landedOnVacation: (playerName) => ` ${playerName} في إجازة!`,
                landedOnMisc: (content) => `لقد هبطت على: ${content}`,
                buyPropertyQuestion: (propertyName) => `هل تريد شراء ${propertyName}؟`,
                price: "السعر",
                currentMoney: "المال الحالي",
                buy: "شراء",
                pass: "تخطي",
                playerBought: (playerName, propertyName, price) => `اشترى ${playerName} ${propertyName} مقابل $${price}!`,
                playerPassed: (playerName, propertyName) => `قرر ${playerName} تخطي ${propertyName}.`,
                notOwnedOrExists: "أنت لا تملك هذه المدينة أو أنها غير موجودة!",
                mustOwnAllCities: (country) => `يجب أن تمتلك جميع المدن في ${country} لترقية هذا العقار!`,
                maxLevel: "العقار بالفعل في أقصى مستوى ترقية!",
                notEnoughMoney: "ليس لديك ما يكفي من المال لترقية هذا العقار!",
                playerUpgraded: (playerName, propertyName, level) => `قام ${playerName} بترقية ${propertyName}! المستوى الحالي: ${level}`,
                minLevel: "العقار في المستوى الأساسي، لا يمكن تخفيض مستواه أكثر!",
                playerDowngraded: (playerName, propertyName, amount, level) => `قام ${playerName} بتخفيض مستوى ${propertyName} واستلم $${amount}! المستوى الحالي: ${level}`,
                sellProperties: "بيع الممتلكات",
                sellSelected: "بيع الممتلكات المحددة",
                noPropertiesToSell: "ليس لديك ممتلكات لبيعها.",
                selectAtLeastOne: "الرجاء تحديد عقار واحد على الأقل للبيع.",
                playerSold: (playerName, count, amount, balance) => `باع ${playerName} ${count} عقار(ات) واستلم $${amount}! رصيدك الحالي: $${balance}`,
                maxPlayersReached: "تم الوصول إلى الحد الأقصى لعدد اللاعبين!",
                addAtLeastOnePlayer: "الرجاء إضافة لاعب واحد على الأقل لبدء اللعبة.",
                turnEnded: (currentPlayerName, nextPlayerName) => `انتهى دور ${currentPlayerName}. الآن دور ${nextPlayerName}.`,
                createTradeOffer: "إنشاء عرض تبادل",
                tradeWith: "التبادل مع:",
                youOffer: "أنت تعرض:",
                money: "المال:",
                yourProperties: "ممتلكاتك:",
                noPropertiesToOffer: "لا توجد ممتلكات لعرضها.",
                youRequest: "أنت تطلب:",
                theirProperties: "ممتلكاتهم:",
                noPropertiesToRequest: "لا توجد ممتلكات لطلبها من هذا اللاعب.",
                sendOffer: "إرسال العرض",
                selectRecipient: "الرجاء تحديد مستلم للعرض.",
                specifyItems: "الرجاء تحديد عنصر واحد على الأقل للعرض أو الطلب.",
                insufficientMoneyOffer: "ليس لديك ما يكفي من المال لعرض هذا المبلغ.",
                onlyOwnProperties: "يمكنك فقط عرض الممتلكات التي تملكها.",
                onlyRequestOwned: "يمكنك فقط طلب الممتلكات التي يملكها اللاعب المحدد.",
                offerSent: (recipientName) => `تم إرسال عرض التبادل إلى ${recipientName}!`,
                incomingTradeOffer: "عرض تبادل وارد",
                from: "من:",
                theyOffer: "هم يعرضون:",
                none: "لا شيء",
                theyRequest: "هم يطلبون:",
                accept: "قبول",
                decline: "رفض",
                tradeError: "خطأ: لم يتم العثور على المرسل أو المستلم للصفقة.",
                senderInsufficientMoney: (senderName) => `ليس لدى ${senderName} ما يكفي من المال لإتمام هذه الصفقة.`,
                recipientInsufficientMoney: (recipientName) => `ليس لدى ${recipientName} ما يكفي من المال لإتمام هذه الصفقة.`,
                senderMissingProps: (senderName) => `لم يعد ${senderName} يملك بعض الممتلكات التي يعرضها.`,
                recipientMissingProps: (recipientName) => `لم يعد ${recipientName} يملك بعض الممتلكات المطلوبة منهم.`,
                tradeAccepted: (senderName, recipientName) => `تم قبول الصفقة بين ${senderName} و ${recipientName}!`,
                tradeDeclined: (senderName, recipientName) => `تم رفض عرض التبادل من ${senderName} إلى ${recipientName}.`,
                tradeCancelled: (senderName, recipientName) => `تم إلغاء عرض التبادل من ${senderName} إلى ${recipientName}.`,
                tradeNotFound: "لم يتم العثور على عرض التبادل.",
                tradeDetails: "تفاصيل عرض التبادل",
                to: "إلى:",
                offering: "يعرض:",
                requesting: "يطلب:",
                modify: "تعديل",
                cancel: "إلغاء",
                currentLevel: "المستوى الحالي:",
                baseRent: "الإيجار الأساسي",
                level: "المستوى",
                max: "الحد الأقصى",
                min: "الحد الأدنى",
                makeTrade: "قم بإجراء صفقات مع لاعبين آخرين لتبادل الممتلكات والمال وبطاقات المكافآت.",
                useCreate: "استخدم زر \"إنشاء\" لبدء صفقة جديدة.",
                aiPlayer: (id) => `اللاعب الآلي ${id}`,
                settings: "الإعدادات",
                language: "اللغة",
                english: "الإنجليزية",
                arabic: "العربية",
                apply: "تطبيق",
                close: "إغلاق",
                kick: "طرد",
                confirmKick: (playerName) => `هل أنت متأكد أنك تريد طرد ${playerName} من الردهة؟`,
                leader: "القائد",
                playerKicked: (playerName) => `${playerName} تم طرده من الردهة.`,
                onlyLeaderCanKick: "فقط قائد الحفلة يمكنه طرد اللاعبين.",
                username: "اسم المستخدم",
                password: "كلمة المرور",
                confirmPassword: "تأكيد كلمة المرور",
                login: "تسجيل الدخول",
                createAccount: "إنشاء حساب",
                alreadyHaveAccount: "بالفعل لديك حساب؟ تسجيل الدخول",
                dontHaveAccount: "ليس لديك حساب؟ إنشاء حساب",
                invalidCredentials: "اسم المستخدم أو كلمة المرور غير صحيحة.",
                usernameTaken: "اسم المستخدم هذا موجود بالفعل.",
                passwordsMismatch: "كلمات المرور غير متطابقة.",
                passwordTooShort: "يجب أن تتكون كلمة المرور من 6 أحرف على الأقل.",
                loggedInAs: (username) => `تم تسجيل الدخول باسم: ${username}`,
                searchingForPlayers: "جاري البحث عن لاعبين...",
                noOtherPlayers: "لا يوجد لاعبون آخرون متصلون للمقايضة معهم.",
                prop: "عقار",
                props: "عقارات",
                offer: "عرض",
                request: "طلب",
                modifyTradeOffer: "تعديل عرض التبادل",
                notLoggedIn: "أنت غير مسجل الدخول.",
                welcome: "مرحباً",
                guestUser: "مستخدم ضيف",
                yourUserId: "معرف المستخدم الخاص بك",
                logout: "تسجيل الخروج",
                chatUnavailable: "الدردشة غير متاحة حالياً (لا يوجد اتصال بقاعدة البيانات)."
            }
        };

        function getTranslation(key, ...args) {
            const translation = translations[gameState.currentLanguage][key];
            if (typeof translation === 'function') {
                return translation(...args);
            }
            return translation || key; // Fallback to key if not found
        }

        function updateAllTextContent() {
            // Update header
            document.getElementById('backButtonText').textContent = getTranslation('back');
            document.getElementById('lobbyTitle').textContent = getTranslation('lobby');
            document.getElementById('unratedMode').textContent = getTranslation('unrated');
            document.getElementById('competitiveMode').textContent = getTranslation('competitive');

            // Update party section
            document.getElementById('closedPartyText').textContent = getTranslation('closedParty');
            document.getElementById('partyCodeInput').placeholder = getTranslation('partyCode');

            // Update lobby player cards (re-render)
            updateLobbyPlayerCards();

            document.getElementById('lobbyPlayButton').textContent = getTranslation('play');
            document.getElementById('lobbyMessage').textContent = getTranslation('searchingForPlayers');


            // Update online players sidebar
            document.getElementById('onlinePlayersTitle').innerHTML = `${getTranslation('online')} <span class="text-green-400">(${document.getElementById('onlinePlayersList').children.length})</span>`;

            // Update game page elements
            document.getElementById('shareGameTitle').textContent = getTranslation('shareGame');
            document.getElementById('copyButtonText').textContent = getTranslation('copy');
            document.getElementById('roomSettingsButtonText').textContent = getTranslation('roomSettings');
            document.getElementById('userIdTitle').textContent = getTranslation('userId');
            document.getElementById('currentUserIdDisplay').textContent = gameState.currentUser ? gameState.currentUser.username : getTranslation('notLoggedIn');
            document.getElementById('chatUnavailableText').textContent = getTranslation('chatUnavailable'); // Assuming chatUnavailable key
            document.getElementById('chatInput').placeholder = getTranslation('saySomething');
            document.getElementById('sendButtonText').textContent = getTranslation('send');

            document.getElementById('playersTitle').textContent = getTranslation('players');
            document.getElementById('tradesTitle').textContent = getTranslation('trades');
            document.getElementById('makeTradeText').textContent = getTranslation('makeTrade');
            document.getElementById('useCreateText').textContent = getTranslation('useCreate');
            document.getElementById('createButtonText').textContent = getTranslation('create');
            document.getElementById('pendingTradesTitle').innerHTML = `${getTranslation('pendingTrades')} (<span id="pendingTradesCount">${gameState.pendingTradeOffers.length}</span>)`;
            document.getElementById('noPendingTradesText').textContent = getTranslation('noPendingTrades');
            document.getElementById('myPropertiesTitle').innerHTML = `${getTranslation('myProperties')} (<span id="myPropertiesCount">${Object.values(gameState.boardProperties).filter(prop => prop.ownerId === gameState.currentUser?.id).length}</span>)`;
            document.getElementById('noPropertiesText').textContent = getTranslation('noProperties');
            document.getElementById('sellPropertyButtonText').textContent = getTranslation('sellProperty');

            // Modals
            document.getElementById('propertyModalTitle').textContent = getTranslation('buyPropertyQuestion', ''); // Title is dynamic, only update "Do you want to buy" part
            document.getElementById('propertyModalPriceLabel').childNodes[0].nodeValue = getTranslation('price') + ": ";
            document.getElementById('playerCurrentMoneyLabel').childNodes[0].nodeValue = getTranslation('currentMoney') + ": ";
            document.getElementById('buyButtonText').textContent = getTranslation('buy');
            document.getElementById('passButtonText').textContent = getTranslation('pass');

            document.getElementById('rentLevelsTitle').textContent = getTranslation('rentLevels');
            document.getElementById('currentUpgradeLevelDisplayLabel').childNodes[0].nodeValue = getTranslation('currentLevel') + ": ";
            document.getElementById('downgradeRefundText').textContent = getTranslation('min'); // Default text
            document.getElementById('upgradeCostText').textContent = getTranslation('max'); // Default text

            document.getElementById('createTradeOfferTitle').textContent = getTranslation('createTradeOffer');
            document.getElementById('tradeWithLabel').textContent = getTranslation('tradeWith') + ":";
            document.getElementById('youOfferTitle').textContent = getTranslation('youOffer');
            document.getElementById('offerMoneyLabel').textContent = getTranslation('money') + ":";
            document.getElementById('yourPropertiesLabel').textContent = getTranslation('yourProperties');
            document.getElementById('noPropertiesToOfferText').textContent = getTranslation('noPropertiesToOffer');
            document.getElementById('youRequestTitle').textContent = getTranslation('youRequest');
            document.getElementById('requestMoneyLabel').textContent = getTranslation('money') + ":";
            document.getElementById('theirPropertiesLabel').textContent = getTranslation('theirProperties');
            document.getElementById('noPropertiesToRequestText').textContent = getTranslation('noPropertiesToRequest');
            document.getElementById('sendOfferButtonText').textContent = getTranslation('sendOffer');

            document.getElementById('incomingTradeOfferTitle').textContent = getTranslation('incomingTradeOffer');
            document.getElementById('offerFromLabel').childNodes[0].nodeValue = getTranslation('from') + ": ";
            document.getElementById('theyOfferTitle').textContent = getTranslation('theyOffer');
            document.getElementById('offerReceivedMoneyLabel').childNodes[0].nodeValue = getTranslation('money') + ": $";
            document.getElementById('offerReceivedPropertiesLabel').textContent = getTranslation('properties') + ":";
            document.getElementById('theyRequestTitle').textContent = getTranslation('theyRequest');
            document.getElementById('requestSentMoneyLabel').childNodes[0].nodeValue = getTranslation('money') + ": $";
            document.getElementById('requestSentPropertiesLabel').textContent = getTranslation('properties') + ":";
            document.getElementById('acceptButtonText').textContent = getTranslation('accept');
            document.getElementById('declineButtonText').textContent = getTranslation('decline');

            document.getElementById('tradeDetailsViewTitle').textContent = getTranslation('tradeDetails');
            document.getElementById('tradeDetailsHeader').childNodes[0].nodeValue = getTranslation('from') + ": ";
            document.getElementById('tradeDetailsToText').textContent = getTranslation('to');
            document.getElementById('offeringTitle').textContent = getTranslation('offering');
            document.getElementById('tradeDetailsOfferedMoneyLabel').childNodes[0].nodeValue = getTranslation('money') + ": $";
            document.getElementById('tradeDetailsOfferedPropertiesLabel').textContent = getTranslation('properties') + ":";
            document.getElementById('requestingTitle').textContent = getTranslation('requesting');
            document.getElementById('tradeDetailsRequestedMoneyLabel').childNodes[0].nodeValue = getTranslation('money') + ": $";
            document.getElementById('tradeDetailsRequestedPropertiesLabel').textContent = getTranslation('properties') + ":";

            document.getElementById('sellPropertiesTitle').textContent = getTranslation('sellProperties');
            document.getElementById('noPropertiesToSellText').textContent = getTranslation('noPropertiesToSell');
            document.getElementById('sellSelectedPropertiesButtonText').textContent = getTranslation('sellSelected');

            document.getElementById('settingsModalTitle').textContent = getTranslation('settings');
            document.getElementById('languageLabel').textContent = getTranslation('language') + ":";
            document.getElementById('langOptionEn').textContent = getTranslation('english');
            document.getElementById('langOptionAr').textContent = getTranslation('arabic');
            document.getElementById('applyButtonText').textContent = getTranslation('apply');
            document.getElementById('closeButtonText').textContent = getTranslation('close');

            // Auth Modal
            document.getElementById('authModalTitle').textContent = getTranslation('login');
            document.getElementById('authUsername').placeholder = getTranslation('username');
            document.getElementById('authPassword').placeholder = getTranslation('password');
            document.getElementById('loginAuthBtn').textContent = getTranslation('login');
            document.getElementById('showSignupBtn').textContent = getTranslation('dontHaveAccount');

            document.getElementById('signupUsername').placeholder = getTranslation('username');
            document.getElementById('signupPassword').placeholder = getTranslation('passwordTooShort'); // Placeholder for password constraint
            document.getElementById('signupConfirmPassword').placeholder = getTranslation('confirmPassword');
            document.getElementById('signupAuthBtn').textContent = getTranslation('createAccount');
            document.getElementById('showLoginBtn').textContent = getTranslation('alreadyHaveAccount');

            // Update board cell display to reflect new language for city names
            if (gameState.boardCellsInfo.length > 0) {
                gameState.boardCellsInfo.forEach(cell => {
                    const cellElement = document.querySelector(`.${cell.id}`);
                    if (cellElement) {
                        updateBoardCellDisplay(cellElement, cell);
                    }
                });
            }

            // Update document direction if language is Arabic
            document.body.dir = (gameState.currentLanguage === 'ar') ? 'rtl' : 'ltr';
        }

        // Custom alert function (replaces window.alert)
        function alert(message) {
            const existingAlert = document.getElementById('custom-alert');
            if (existingAlert) {
                existingAlert.remove();
            }

            const alertDiv = document.createElement('div');
            alertDiv.id = 'custom-alert';
            // Increased vertical padding (py-10) and reduced horizontal padding (px-3)
            alertDiv.className = 'fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-gray-800 text-white py-10 px-3 rounded-lg shadow-lg z-50 flex flex-col items-center';
            alertDiv.style.minWidth = '250px';

            const messageP = document.createElement('p');
            messageP.textContent = message;
            // Increased text size for alert message
            messageP.className = 'text-xl mb-4 text-center';
            alertDiv.appendChild(messageP);

            const closeButton = document.createElement('button');
            closeButton.textContent = 'OK';
            closeButton.className = 'bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded-md focus:outline-none focus:ring-2 focus:ring-purple-500';
            closeButton.onclick = () => alertDiv.remove();
            alertDiv.appendChild(closeButton);

            document.body.appendChild(alertDiv);
        }

        // Function to show money gain/loss effect directly in the player list
        function showMoneyEffect(playerId, amount, type) {
            const moneyChangeSpan = document.getElementById(`player-money-change-${playerId}`);
            if (!moneyChangeSpan) return;

            moneyChangeSpan.textContent = `${type === 'gain' ? '+' : '-'}${amount}`;
            moneyChangeSpan.classList.remove('plus', 'minus'); // Clear previous classes
            moneyChangeSpan.classList.add(type); // Add 'gain' or 'loss'
            moneyChangeSpan.classList.add('active'); // Activate animation

            // Set a timeout to remove the 'active' class (trigger fade out)
            setTimeout(() => {
                moneyChangeSpan.classList.remove('active');
                // Clear text content after the transition finishes for cleanliness
                setTimeout(() => {
                    moneyChangeSpan.textContent = '';
                }, 700); // Match the transition duration in CSS
            }, 1500); // Show for 1.5 seconds before starting to fade
        }


        // Function to shuffle an array (Fisher-Yates algorithm) - No longer used for board generation
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        // Function to get the URL for a country flag image (still used for property details modal icon)
        function getCountryFlagImage(country) {
            const countryCodes = {
                "France": "fr", "فرنسا": "fr",
                "Germany": "de", "ألمانيا": "de",
                "USA": "us", "الولايات المتحدة": "us",
                "Canada": "ca", "كندا": "ca",
                "Brazil": "br", "البرازيل": "br",
                "Argentina": "ar", "الأرجنتين": "ar",
                "Egypt": "eg", "مصر": "eg",
                "Nigeria": "ng", "نيجيريا": "ng",
                "Japan": "jp", "اليابان": "jp",
                "India": "in", "الهند": "in",
                "Mexico": "mx", "المكسيك": "mx",
                "United Kingdom": "gb", "المملكة المتحدة": "gb",
                "Australia": "au", "أستراليا": "au",
                "UAE": "ae", "الإمارات": "ae",
                "Singapore": "sg", "سنغافورة": "sg",
                "South Africa": "za", "جنوب أفريقيا": "za"
            };
            const code = countryCodes[country] ? countryCodes[country].toLowerCase() : 'xx'; // 'xx' for unknown
            const imageUrl = `https://flagcdn.com/w40/${code}.png`;
            // Fallback to a placeholder image if the actual flag image fails to load
            const fallbackImageUrl = `https://placehold.co/40x30/cccccc/000000?text=${encodeURIComponent(country.substring(0,2).toUpperCase())}`;
            return `<img src="${imageUrl}" alt="${country} Flag" class="w-6 h-auto" onerror="this.onerror=null;this.src='${fallbackImageUrl}';">`;
        }

        // Function to get a generic city emoji
        function getCityEmoji() {
            return "🏙️"; // A generic city emoji for city properties
        }

        // Function to get the emoji for a company property
        function getCompanyEmoji(companyName) {
            const companyEmojis = {
                "Water": "💧", "الماء": "💧",
                "Electricity": "⚡", "الكهرباء": "⚡",
                "Internet": "🌐", "الإنترنت": "🌐",
                "Airport": "✈️", "المطار": "✈️"
            };
            return companyEmojis[companyName] || ''; // Return emoji or empty string if not found
        }

        // Define the board path in sequential order (used for player movement and cell ID mapping)
        const boardPath = [
            "cell-top-right-corner", // 0: Start
            "cell-top-1", // 1
            "cell-top-2", // 2
            "cell-top-3", // 3
            "cell-top-4", // 4
            "cell-top-5", // 5: Water
            "cell-top-6", // 6
            "cell-top-7", // 7
            "cell-top-8", // 8
            "cell-top-9", // 9
            "cell-top-left-corner", // 10: Surprise
            "cell-left-1", // 11
            "cell-left-2", // 12
            "cell-left-3", // 13
            "cell-left-4", // 14
            "cell-left-5", // 15: Electricity
            "cell-left-6", // 16
            "cell-left-7", // 17
            "cell-left-8", // 18
            "cell-left-9", // 19
            "cell-bottom-left-corner", // 20: Go to Jail
            "cell-bottom-1", // 21
            "cell-bottom-2", // 22
            "cell-bottom-3", // 23
            "cell-bottom-4", // 24
            "cell-bottom-5", // 25: Internet
            "cell-bottom-6", // 26
            "cell-bottom-7", // 27
            "cell-bottom-8", // 28
            "cell-bottom-9", // 29
            "cell-bottom-right-corner", // 30: Vacation
            "cell-right-1", // 31
            "cell-right-2", // 32
            "cell-right-3", // 33
            "cell-right-4", // 34
            "cell-right-5", // 35: Airport
            "cell-right-6", // 36
            "cell-right-7", // 37
            "cell-right-8", // 38
            "cell-right-9"  // 39
        ];

        // Helper to round to the nearest multiple of 5
        function roundToNearestFive(num) {
            return Math.round(num / 5) * 5;
        }

        // Define base prices for countries (richer countries have higher base prices)
        // Prices are now fixed, multiples of 5, and within 100-500 range
        const countryBasePrices = {
            "USA": 480, "الولايات المتحدة": 480,
            "Germany": 440, "ألمانيا": 440,
            "Japan": 460, "اليابان": 460,
            "France": 420, "فرنسا": 420,
            "Canada": 400, "كندا": 400,
            "Brazil": 205, "البرازيل": 205,
            "Argentina": 185, "الأرجنتين": 185,
            "Egypt": 165, "مصر": 165,
            "India": 125, "الهند": 125,
            "Mexico": 225, "المكسيك": 225
        };

        // Function to generate rent levels based on base price
        function generateRentLevels(basePrice) {
            const rents = [];
            rents[0] = roundToNearestFive(basePrice * 0.10); // Base Rent
            rents[1] = roundToNearestFive(basePrice * 0.25); // Level 1
            rents[2] = roundToNearestFive(basePrice * 0.50); // Level 2
            rents[3] = roundToNearestFive(basePrice * 0.75); // Level 3
            rents[4] = roundToNearestFive(basePrice * 1.00); // Level 4
            return rents;
        }

        /**
         * Updates the visual display of a single board cell based on its current state.
         * This is called after a property is purchased, upgraded, or downgraded.
         * @param {HTMLElement} cellElement - The DOM element of the cell to update.
         * @param {object} cellInfo - The cell's information object from gameState.boardCellsInfo.
         */
        function updateBoardCellDisplay(cellElement, cellInfo) {
            if (!cellElement) {
                console.error("Cell element is null or undefined.");
                return;
            }
            if (!cellInfo) {
                console.error("Cell info is null or undefined for cell element:", cellElement);
                return;
            }

            // Preserve player tokens and existing color bar
            const playerTokens = Array.from(cellElement.querySelectorAll('.player-token'));
            const existingColorBar = cellElement.querySelector('.property-color-bar');

            cellElement.innerHTML = ''; // Clear everything else

            // Re-append the color bar or create a new one
            let colorBar;
            if (existingColorBar) {
                colorBar = existingColorBar;
            } else {
                colorBar = document.createElement('div');
                colorBar.classList.add('w-full', 'h-2', 'absolute', 'top-0', 'left-0', 'property-color-bar');
            }

            const ownerPlayer = cellInfo.owner !== null ? gameState.players.find(p => p.id === cellInfo.owner) : null;

            // Logic for color bar visibility and color
            if (cellInfo.type === 'city' || cellInfo.type === 'company') {
                colorBar.classList.remove('hidden'); // Always show for city/company
                colorBar.style.backgroundColor = ownerPlayer ? ownerPlayer.color : '#FFFFFF'; // White if unowned, player color if owned
            } else {
                colorBar.classList.add('hidden'); // Hide for other cell types (corners)
            }
            cellElement.appendChild(colorBar);

            // Create a container for the main content to control its z-index and layout
            const contentContainer = document.createElement('div');
            contentContainer.className = 'flex flex-col items-center justify-center h-full w-full relative z-2'; // z-index 2 for content

            // Get the display name for the current language
            let displayName = cellInfo.content[gameState.currentLanguage] || cellInfo.content['en'] || cellInfo.content;
            let countryName = cellInfo.country ? (cellInfo.country[gameState.currentLanguage] || cellInfo.country['en'] || cellInfo.country) : '';


            if (cellInfo.type === 'city') {
                // City Name (under the color bar)
                const nameDiv = document.createElement('div');
                nameDiv.className = 'text-xs font-bold leading-tight mt-1'; // Added mt-1 to move down slightly
                nameDiv.textContent = displayName;
                contentContainer.appendChild(nameDiv);

                // Country Flag
                const countryFlagDiv = document.createElement('div');
                countryFlagDiv.className = 'flex-shrink-0 mb-1'; // Added mb-1 to move up slightly
                countryFlagDiv.innerHTML = getCountryFlagImage(countryName);
                contentContainer.appendChild(countryFlagDiv);

                // Price
                const priceDiv = document.createElement('div');
                priceDiv.className = 'text-xs font-bold text-green-400 leading-tight';
                priceDiv.textContent = `$${cellInfo.price}`;
                contentContainer.appendChild(priceDiv);

                // Level
                const levelDiv = document.createElement('div');
                levelDiv.className = 'text-xs text-gray-400 leading-tight';
                levelDiv.textContent = `${getTranslation('level')}: ${cellInfo.currentUpgradeLevel}`; // Abbreviated "Level"
                contentContainer.appendChild(levelDiv);

            } else if (cellInfo.type === 'company') {
                const nameDiv = document.createElement('div');
                nameDiv.className = 'text-xs font-bold leading-tight';
                nameDiv.textContent = displayName;
                contentContainer.appendChild(nameDiv);

                const priceDiv = document.createElement('div');
                priceDiv.className = 'text-xs font-bold text-green-400 leading-tight';
                priceDiv.textContent = `$${cellInfo.price}`;
                contentContainer.appendChild(priceDiv);

                const emojiDiv = document.createElement('div');
                emojiDiv.className = 'text-lg';
                emojiDiv.innerHTML = getCompanyEmoji(displayName);
                contentContainer.appendChild(emojiDiv);

            } else if (cellInfo.type === 'corner') {
                const emojiDiv = document.createElement('div');
                emojiDiv.className = 'text-3xl';
                emojiDiv.innerHTML = cellInfo.emoji;
                contentContainer.appendChild(emojiDiv);
            }

            // Append the content container to the cell
            cellElement.appendChild(contentContainer);

            // Re-append player tokens
            playerTokens.forEach(token => cellElement.appendChild(token));

            console.log(`Updated cell ${cellInfo.id}. InnerHTML:`, cellElement.innerHTML); // Debug log
        }


        // Function to populate the board with cities and special cells dynamically
        function populateBoard() {
            // Assign the static board layout for "World 1"
            // This ensures the board is always the same and cities of the same country are adjacent.
            gameState.boardCellsInfo = [
                // Index 0: Start
                { id: "cell-top-right-corner", type: "corner", content: { en: "Start", ar: "البداية" }, emoji: "➡️", boardIndex: 0, owner: null },

                // Top Row Cities (USA)
                { id: "cell-top-1", type: "city", content: { en: "New York", ar: "نيويورك" }, country: { en: "USA", ar: "الولايات المتحدة" }, price: countryBasePrices["USA"], currentUpgradeLevel: 0, rentLevels: generateRentLevels(countryBasePrices["USA"]), owner: null },
                { id: "cell-top-2", type: "city", content: { en: "Los Angeles", ar: "لوس أنجلوس" }, country: { en: "USA", ar: "الولايات المتحدة" }, price: countryBasePrices["USA"], currentUpgradeLevel: 0, rentLevels: generateRentLevels(countryBasePrices["USA"]), owner: null },
                { id: "cell-top-3", type: "city", content: { en: "Chicago", ar: "شيكاغو" }, country: { en: "USA", ar: "الولايات المتحدة" }, price: countryBasePrices["USA"], currentUpgradeLevel: 0, rentLevels: generateRentLevels(countryBasePrices["USA"]), owner: null },
                { id: "cell-top-4", type: "city", content: { en: "Houston", ar: "هيوستن" }, country: { en: "USA", ar: "الولايات المتحدة" }, price: countryBasePrices["USA"], currentUpgradeLevel: 0, rentLevels: generateRentLevels(countryBasePrices["USA"]), owner: null },

                // Index 5: Water Company
                { id: "cell-top-5", type: "company", content: { en: "Water", ar: "الماء" }, price: 150, emoji: "💧", rentLevels: [15], boardIndex: 5, owner: null },

                // Top Row Cities (Germany)
                { id: "cell-top-6", type: "city", content: { en: "Berlin", ar: "برلين" }, country: { en: "Germany", ar: "ألمانيا" }, price: countryBasePrices["Germany"], currentUpgradeLevel: 0, rentLevels: generateRentLevels(countryBasePrices["Germany"]), owner: null },
                { id: "cell-top-7", type: "city", content: { en: "Munich", ar: "ميونخ" }, country: { en: "Germany", ar: "ألمانيا" }, price: countryBasePrices["Germany"], currentUpgradeLevel: 0, rentLevels: generateRentLevels(countryBasePrices["Germany"]), owner: null },
                { id: "cell-top-8", type: "city", content: { en: "Hamburg", ar: "هامبورغ" }, country: { en: "Germany", ar: "ألمانيا" }, price: countryBasePrices["Germany"], currentUpgradeLevel: 0, rentLevels: generateRentLevels(countryBasePrices["Germany"]), owner: null },
                { id: "cell-top-9", type: "city", content: { en: "Frankfurt", ar: "فرانكفورت" }, country: { en: "Germany", ar: "ألمانيا" }, price: countryBasePrices["Germany"], currentUpgradeLevel: 0, rentLevels: generateRentLevels(countryBasePrices["Germany"]), owner: null },

                // Index 10: Surprise
                { id: "cell-top-left-corner", type: "corner", content: { en: "Surprise", ar: "مفاجأة" }, emoji: "📦", boardIndex: 10, owner: null },

                // Left Column Cities (Japan)
                { id: "cell-left-1", type: "city", content: { en: "Tokyo", ar: "طوكيو" }, country: { en: "Japan", ar: "اليابان" }, price: countryBasePrices["Japan"], currentUpgradeLevel: 0, rentLevels: generateRentLevels(countryBasePrices["Japan"]), owner: null },
                { id: "cell-left-2", type: "city", content: { en: "Osaka", ar: "أوساكا" }, country: { en: "Japan", ar: "اليابان" }, price: countryBasePrices["Japan"], currentUpgradeLevel: 0, rentLevels: generateRentLevels(countryBasePrices["Japan"]), owner: null },
                { id: "cell-left-3", type: "city", content: { en: "Kyoto", ar: "كيوتو" }, country: { en: "Japan", ar: "اليابان" }, price: countryBasePrices["Japan"], currentUpgradeLevel: 0, rentLevels: generateRentLevels(countryBasePrices["Japan"]), owner: null },
                { id: "cell-left-4", type: "city", content: { en: "Sapporo", ar: "سابورو" }, country: { en: "Japan", ar: "اليابان" }, price: countryBasePrices["Japan"], currentUpgradeLevel: 0, rentLevels: generateRentLevels(countryBasePrices["Japan"]), owner: null },

                // Index 15: Electricity Company
                { id: "cell-left-5", type: "company", content: { en: "Electricity", ar: "الكهرباء" }, price: 150, emoji: "⚡", rentLevels: [15], boardIndex: 15, owner: null },

                // Left Column Cities (France)
                { id: "cell-left-6", type: "city", content: { en: "Paris", ar: "باريس" }, country: { en: "France", ar: "فرنسا" }, price: countryBasePrices["France"], currentUpgradeLevel: 0, rentLevels: generateRentLevels(countryBasePrices["France"]), owner: null },
                { id: "cell-left-7", type: "city", content: { en: "Marseille", ar: "مرسيليا" }, country: { en: "France", ar: "فرنسا" }, price: countryBasePrices["France"], currentUpgradeLevel: 0, rentLevels: generateRentLevels(countryBasePrices["France"]), owner: null },
                { id: "cell-left-8", type: "city", content: { en: "Lyon", ar: "ليون" }, country: { en: "France", ar: "فرنسا" }, price: countryBasePrices["France"], currentUpgradeLevel: 0, rentLevels: generateRentLevels(countryBasePrices["France"]), owner: null },
                { id: "cell-left-9", type: "city", content: { en: "Nice", ar: "نيس" }, country: { en: "France", ar: "فرنسا" }, price: countryBasePrices["France"], currentUpgradeLevel: 0, rentLevels: generateRentLevels(countryBasePrices["France"]), owner: null },

                // Index 20: Go to Jail
                { id: "cell-bottom-left-corner", type: "corner", content: { en: "Go to Jail", ar: "اذهب إلى السجن" }, emoji: "🚓", boardIndex: 20, owner: null },

                // Bottom Row Cities (Canada, Brazil, Argentina)
                { id: "cell-bottom-1", type: "city", content: { en: "Toronto", ar: "تورونتو" }, country: { en: "Canada", ar: "كندا" }, price: countryBasePrices["Canada"], currentUpgradeLevel: 0, rentLevels: generateRentLevels(countryBasePrices["Canada"]), owner: null },
                { id: "cell-bottom-2", type: "city", content: { en: "Montreal", ar: "مونتريال" }, country: { en: "Canada", ar: "كندا" }, price: countryBasePrices["Canada"], currentUpgradeLevel: 0, rentLevels: generateRentLevels(countryBasePrices["Canada"]), owner: null },
                { id: "cell-bottom-3", type: "city", content: { en: "Vancouver", ar: "فانكوفر" }, country: { en: "Canada", ar: "كندا" }, price: countryBasePrices["Canada"], currentUpgradeLevel: 0, rentLevels: generateRentLevels(countryBasePrices["Canada"]), owner: null },
                { id: "cell-bottom-4", type: "city", content: { en: "Rio de Janeiro", ar: "ريو دي جانيرو" }, country: { en: "Brazil", ar: "البرازيل" }, price: countryBasePrices["Brazil"], currentUpgradeLevel: 0, rentLevels: generateRentLevels(countryBasePrices["Brazil"]), owner: null },

                // Index 25: Internet Company
                { id: "cell-bottom-5", type: "company", content: { en: "Internet", ar: "الإنترنت" }, price: 150, emoji: "🌐", rentLevels: [15], boardIndex: 25, owner: null },

                // Bottom Row Cities (Brazil, Argentina)
                { id: "cell-bottom-6", type: "city", content: { en: "Sao Paulo", ar: "ساو باولو" }, country: { en: "Brazil", ar: "البرازيل" }, price: countryBasePrices["Brazil"], currentUpgradeLevel: 0, rentLevels: generateRentLevels(countryBasePrices["Brazil"]), owner: null },
                { id: "cell-bottom-7", type: "city", content: { en: "Brasilia", ar: "برازيليا" }, country: { en: "Brazil", ar: "البرازيل" }, price: countryBasePrices["Brazil"], currentUpgradeLevel: 0, rentLevels: generateRentLevels(countryBasePrices["Brazil"]), owner: null },
                { id: "cell-bottom-8", type: "city", content: { en: "Buenos Aires", ar: "بوينس آيرس" }, country: { en: "Argentina", ar: "الأرجنتين" }, price: countryBasePrices["Argentina"], currentUpgradeLevel: 0, rentLevels: generateRentLevels(countryBasePrices["Argentina"]), owner: null },
                { id: "cell-bottom-9", type: "city", content: { en: "Cordoba", ar: "قرطبة" }, country: { en: "Argentina", ar: "الأرجنتين" }, price: countryBasePrices["Argentina"], currentUpgradeLevel: 0, rentLevels: generateRentLevels(countryBasePrices["Argentina"]), owner: null },

                // Index 30: Vacation
                { id: "cell-bottom-right-corner", type: "corner", content: { en: "Vacation", ar: "إجازة" }, emoji: "🏖️", boardIndex: 30, owner: null },

                // Right Column Cities (Egypt, India, Mexico)
                { id: "cell-right-1", type: "city", content: { en: "Cairo", ar: "القاهرة" }, country: { en: "Egypt", ar: "مصر" }, price: countryBasePrices["Egypt"], currentUpgradeLevel: 0, rentLevels: generateRentLevels(countryBasePrices["Egypt"]), owner: null },
                { id: "cell-right-2", type: "city", content: { en: "Alexandria", ar: "الإسكندرية" }, country: { en: "Egypt", ar: "مصر" }, price: countryBasePrices["Egypt"], currentUpgradeLevel: 0, rentLevels: generateRentLevels(countryBasePrices["Egypt"]), owner: null },
                { id: "cell-right-3", type: "city", content: { en: "Giza", ar: "الجيزة" }, country: { en: "Egypt", ar: "مصر" }, price: countryBasePrices["Egypt"], currentUpgradeLevel: 0, rentLevels: generateRentLevels(countryBasePrices["Egypt"]), owner: null },
                { id: "cell-right-4", type: "city", content: { en: "Mumbai", ar: "مومباي" }, country: { en: "India", ar: "الهند" }, price: countryBasePrices["India"], currentUpgradeLevel: 0, rentLevels: generateRentLevels(countryBasePrices["India"]), owner: null },

                // Index 35: Airport Company
                { id: "cell-right-5", type: "company", content: { en: "Airport", ar: "المطار" }, price: 2000, emoji: "✈️", rentLevels: [15], boardIndex: 35, owner: null },

                // Right Column Cities (India, Mexico)
                { id: "cell-right-6", type: "city", content: { en: "Delhi", ar: "دلهي" }, country: { en: "India", ar: "الهند" }, price: countryBasePrices["India"], currentUpgradeLevel: 0, rentLevels: generateRentLevels(countryBasePrices["India"]), owner: null },
                { id: "cell-right-7", type: "city", content: { en: "Bangalore", ar: "بنغالور" }, country: { en: "India", ar: "الهند" }, price: countryBasePrices["India"], currentUpgradeLevel: 0, rentLevels: generateRentLevels(countryBasePrices["India"]), owner: null },
                { id: "cell-right-8", type: "city", content: { en: "Mexico City", ar: "مدينة مكسيكو" }, country: { en: "Mexico", ar: "المكسيك" }, price: countryBasePrices["Mexico"], currentUpgradeLevel: 0, rentLevels: generateRentLevels(countryBasePrices["Mexico"]), owner: null },
                { id: "cell-right-9", type: "city", content: { en: "Guadalajara", ar: "غوادالاخارا" }, country: { en: "Mexico", ar: "المكسيك" }, price: countryBasePrices["Mexico"], currentUpgradeLevel: 0, rentLevels: generateRentLevels(countryBasePrices["Mexico"]), owner: null }
            ];


            const gameBoardGrid = document.querySelector('.game-board-grid');
            if (!gameBoardGrid) {
                console.error("Game board grid element not found!");
                return;
            }
            gameBoardGrid.innerHTML = ''; // Clear existing cells

            gameState.boardCellsInfo.forEach((cell, index) => {
                const cellElement = document.createElement('div');
                cellElement.classList.add('board-cell');
                cellElement.classList.add(boardPath[index]); // Add the specific class for grid positioning
                if (cell.type === 'corner') {
                    cellElement.classList.add('corner-cell');
                }

                // Add click listener for property details modal
                if (cell.type === 'city' || cell.type === 'company') {
                    cellElement.addEventListener('click', () => displayPropertyDetails(cell.id));
                }

                gameBoardGrid.appendChild(cellElement); // Append the element first

                // Then, update its display content
                updateBoardCellDisplay(cellElement, cell);
            });

            // Re-append the center area after all cells are added
            const boardCenter = document.createElement('div');
            boardCenter.classList.add('board-center');
            boardCenter.innerHTML = `
                <div id="randomNumberDisplay" class="text-white text-5xl font-bold mb-4"></div>
                <div id="turnTimerDisplay" class="text-red-400 text-3xl font-bold mb-4 hidden"></div>
                <button
                    id="rollDiceButton"
                    class="btn-primary flex items-center justify-center text-white text-2xl font-bold py-4 px-12 rounded-xl focus:outline-none focus:ring-4 focus->ring-purple-500 focus:ring-opacity-50"
                >
                    ${getTranslation('play')}
                </button>
            `;
            gameBoardGrid.appendChild(boardCenter);

            // Re-attach event listener for the new rollDiceButton
            const newRollDiceButton = document.getElementById('rollDiceButton');
            const newRandomNumberDisplay = document.getElementById('randomNumberDisplay');
            if (newRollDiceButton) {
                newRollDiceButton.addEventListener('click', handleRollDice);
            }
        }

        // Function to create and add player tokens to the board
        function addPlayerTokens() {
            gameState.players.forEach(player => {
                const playerToken = document.createElement('div');
                playerToken.id = `player-token-${player.id}`;
                playerToken.classList.add('player-token', `player-color-${player.id}`);
                playerToken.textContent = player.id; // Display player ID or initial
                // Set initial position to "Start" cell
                const startCell = document.querySelector(`.${boardPath[player.positionIndex]}`);
                if (startCell) {
                    startCell.appendChild(playerToken);
                }
            });
            updatePlayersList(); // Initial highlight for current player
        }

        // Function to update players list in sidebar
        function updatePlayersList() {
            const playersListElem = document.getElementById('playersList');
            playersListElem.innerHTML = ''; // Clear current list

            gameState.players.forEach((player, index) => {
                const listItem = document.createElement('li');
                listItem.classList.add('flex', 'justify-between', 'items-center', 'py-1');
                if (index === gameState.currentPlayerIndex) {
                    listItem.classList.add('current-player-highlight'); // Highlight current player in sidebar
                }
                // Updated innerHTML to include the money-change span
                listItem.innerHTML = `
                    <span>
                        <i class="fas fa-user-circle mr-2" style="color: ${player.color};"></i> ${player.name}
                        <span id="player-money-change-${player.id}" class="money-change"></span>
                    </span>
                    <span class="flex items-center gap-2">
                        <span class="text-green-400">$<span id="player-money-${player.id}">${player.money}</span></span>
                        <button class="text-blue-400 hover:text-blue-200 text-sm" onclick="openTradeCreationModal(gameState.players[gameState.currentPlayerIndex].id)">
                            <i class="fas fa-handshake"></i>
                        </button>
                    </span>
                `;
                playersListElem.appendChild(listItem);
            });

            // Update player token highlight on the board
            gameState.players.forEach((player, index) => {
                const playerToken = document.getElementById(`player-token-${player.id}`);
                if (playerToken) {
                    if (index === gameState.currentPlayerIndex) {
                        playerToken.classList.add('current-player-highlight');
                    } else {
                        playerToken.classList.remove('current-player-highlight');
                    }
                }
            });
        }

        // Function to update player's properties list
        function updateMyPropertiesList() {
            const myPropertiesListElem = document.getElementById('myPropertiesList');
            const myPropertiesCountElem = document.getElementById('myPropertiesCount');
            const currentPlayer = gameState.players.find(p => p.id === gameState.currentUser?.id); // Get current logged-in player

            if (!currentPlayer) {
                myPropertiesListElem.innerHTML = `<li class="text-sm text-gray-400">${getTranslation('noProperties')}</li>`;
                myPropertiesCountElem.textContent = '0';
                return;
            }

            // Filter properties that belong to the current player
            const playerProperties = Object.values(gameState.boardProperties).filter(
                prop => prop.ownerId === currentPlayer.id
            );

            myPropertiesListElem.innerHTML = ''; // Clear current list
            myPropertiesCountElem.textContent = playerProperties.length;

            if (playerProperties.length === 0) {
                const listItem = document.createElement('li');
                listItem.classList.add('text-sm', 'text-gray-400');
                listItem.textContent = getTranslation('noProperties');
                myPropertiesListElem.appendChild(listItem);
            } else {
                playerProperties.forEach(prop => {
                    const listItem = document.createElement('li');
                    listItem.classList.add('text-sm', 'text-gray-300', 'py-0.5', 'flex', 'items-center', 'gap-2'); // Added flex for alignment

                    // Find the original cell info to get type, country, and emoji
                    const originalCell = gameState.boardCellsInfo.find(cell => cell.id === prop.id);

                    let iconHtml = '';
                    let propertyDisplayName = originalCell.content[gameState.currentLanguage] || originalCell.content['en'] || originalCell.content;
                    if (originalCell && originalCell.type === 'city') {
                        // Display country flag then city name
                        iconHtml = `${getCountryFlagImage(originalCell.country[gameState.currentLanguage] || originalCell.country['en'])} `;
                    } else if (originalCell && originalCell.type === 'company') {
                        iconHtml = `<span class="text-lg">${getCompanyEmoji(propertyDisplayName)}</span>`;
                    }

                    listItem.innerHTML = `
                        ${iconHtml}
                        <span>${propertyDisplayName} ($${prop.price})</span>
                    `; // Use originalCell.content for full name in list
                    myPropertiesListElem.appendChild(listItem);
                });
            }
        }

        // Function to check and update button state based on debt
        function checkPlayerDebtStatus() {
            const rollDiceButton = document.getElementById('rollDiceButton');
            const currentPlayer = gameState.players[gameState.currentPlayerIndex];

            if (!currentPlayer) { // If no current player (e.g., game just ended)
                rollDiceButton.disabled = true;
                return;
            }

            // If the current player is indebted, disable the button
            if (currentPlayer.money < 0) {
                rollDiceButton.disabled = true;
                resetTurnTimer(); // Pause the timer if indebted
                // If the button text is "PLAY", it means they haven't rolled yet.
                // If it's "END", they already rolled and are now indebted.
                // In both cases, they cannot proceed until debt is cleared.
            } else {
                // If money is non-negative, enable the button if it's currently disabled
                // and the game is ready for a roll or an end turn.
                if (rollDiceButton.disabled) {
                    // Only re-enable if the button is supposed to be active for the current player's turn
                    // This prevents enabling it prematurely if it's disabled for other reasons (e.g., during movement)
                    if (rollDiceButton.textContent === getTranslation('play') || rollDiceButton.textContent === 'END') { // 'END' is not translated
                         rollDiceButton.disabled = false;
                    }
                }
                // If the player was indebted and cleared it, restart the timer if it was paused
                if (turnTimer === null && rollDiceButton.textContent === 'END') {
                    startTurnTimer();
                }
            }
        }

        // --- Timer Functions ---
        function startTurnTimer() {
            // Clear any existing timer to prevent multiple intervals running
            if (turnTimer) {
                clearInterval(turnTimer);
                console.log(`[Timer Debug] ${Date.now()}: Cleared existing timer ID ${turnTimer} before starting new one.`);
                turnTimer = null; // Ensure it's nullified
            }

            const turnTimerDisplay = document.getElementById('turnTimerDisplay');
            turnTimerDisplay.classList.remove('hidden'); // Show timer display
            timeLeft = TURN_DURATION_SECONDS;
            updateTimerDisplay(); // Initial display update

            const currentPlayer = gameState.players[gameState.currentPlayerIndex];
            console.log(`[Timer Debug] ${Date.now()}: Starting timer for ${currentPlayer?.name || 'unknown player'} (ID: ${currentPlayer?.id}). Initial time left: ${timeLeft}s. Current player index: ${gameState.currentPlayerIndex}. Total players: ${gameState.players.length}.`);

            turnTimer = setInterval(() => {
                const currentCheckPlayer = gameState.players[gameState.currentPlayerIndex]; // Get player inside interval for current check
                if (!currentCheckPlayer) {
                    console.log(`[Timer Debug] ${Date.now()}: No current player found in interval (player might have been kicked or game ended). Stopping timer.`);
                    resetTurnTimer();
                    return;
                }

                if (currentCheckPlayer.money < 0) {
                    console.log(`[Timer Debug] ${Date.now()}: Timer paused for ${currentCheckPlayer.name} (ID: ${currentCheckPlayer.id}). Money: ${currentCheckPlayer.money}. Time left: ${timeLeft}s. Timer ID: ${turnTimer}.`);
                    updateTimerDisplay(); // Still update to show current time, but it won't decrement
                    return;
                }

                timeLeft--;
                updateTimerDisplay();
                console.log(`[Timer Debug] ${Date.now()}: Timer ticked for ${currentCheckPlayer.name} (ID: ${currentCheckPlayer.id}). Time left: ${timeLeft}s. Timer ID: ${turnTimer}.`);

                if (timeLeft <= 0) {
                    console.log(`[Timer Debug] ${Date.now()}: Time ran out for ${currentCheckPlayer.name} (ID: ${currentCheckPlayer.id}). Kicking player. Timer ID: ${turnTimer}.`);
                    clearInterval(turnTimer); // Stop the interval immediately
                    turnTimer = null; // Nullify the timer ID
                    kickPlayer(); // Trigger kick logic
                }
            }, 1000);
            console.log(`[Timer Debug] ${Date.now()}: New timer set with ID: ${turnTimer}`);
        }

        function resetTurnTimer() {
            console.log(`[Timer Debug] ${Date.now()}: resetTurnTimer called. Attempting to clear timer ID: ${turnTimer}.`);
            if (turnTimer) {
                clearInterval(turnTimer);
                console.log(`[Timer Debug] ${Date.now()}: Successfully cleared timer ID: ${turnTimer}.`);
                turnTimer = null; // Explicitly set to null
            }
            timeLeft = 0;
            updateTimerDisplay();
            document.getElementById('turnTimerDisplay').classList.add('hidden'); // Hide timer display
        }

        function updateTimerDisplay() {
            const minutes = Math.floor(timeLeft / 60);
            const seconds = timeLeft % 60;
            document.getElementById('turnTimerDisplay').textContent =
                `${getTranslation('timeLeft')}: ${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        // Function to kick a player from the game (due to timer)
        async function kickPlayer() {
            console.log(`[Player Kick Debug] ${Date.now()}: kickPlayer called. Before kick - Current player index: ${gameState.currentPlayerIndex}. Total players: ${gameState.players.length}. Players array:`, gameState.players.map(p => p.name));
            const kickedPlayer = gameState.players[gameState.currentPlayerIndex];
            if (!kickedPlayer) {
                console.error(`[Player Kick Error] ${Date.now()}: No player to kick at current index ${gameState.currentPlayerIndex}. This should not happen if called from timer.`);
                return;
            }

            // Ensure timer is fully stopped before modifying player state
            resetTurnTimer();

            alert(getTranslation('timeExpired', kickedPlayer.name));
            console.log(`[Player Kick Debug] ${Date.now()}: Alert shown for ${kickedPlayer.name}.`);

            // Revert properties owned by the kicked player
            Object.keys(gameState.boardProperties).forEach(propId => {
                if (gameState.boardProperties[propId].ownerId === kickedPlayer.id) {
                    const propertyInCellsInfo = gameState.boardCellsInfo.find(cell => cell.id === propId);
                    if (propertyInCellsInfo) {
                        propertyInCellsInfo.owner = null;
                        propertyInCellsInfo.currentUpgradeLevel = 0;
                        updateBoardCellDisplay(document.querySelector(`.${propId}`), propertyInCellsInfo);
                    }
                    delete gameState.boardProperties[propId];
                }
            });
            console.log(`[Player Kick Debug] ${Date.now()}: Properties reverted for ${kickedPlayer.name}.`);

            // Remove player token from the board
            const playerToken = document.getElementById(`player-token-${kickedPlayer.id}`);
            if (playerToken) {
                playerToken.remove();
                console.log(`[Player Kick Debug] ${Date.now()}: Token removed for ${kickedPlayer.name}.`);
            }

            // Remove player from the game state
            gameState.players.splice(gameState.currentPlayerIndex, 1);
            console.log(`[Player Kick Debug] ${Date.now()}: Player ${kickedPlayer.name} removed from array. Remaining players: ${gameState.players.length}. Players array after splice:`, gameState.players.map(p => p.name));

            // Update game state in Firestore
            if (gameState.currentGameId) {
                await updateDoc(doc(gamesCollectionRef, gameState.currentGameId), {
                    players: gameState.players,
                    boardProperties: gameState.boardProperties,
                    currentPlayerIndex: gameState.currentPlayerIndex // Update index after splice
                });
            }

            // If the kicked player was the leader, reassign leaderId
            if (kickedPlayer.id === gameState.leaderId && gameState.players.length > 0) {
                gameState.leaderId = gameState.players[0].id;
                console.log(`[Player Kick Debug] ${Date.now()}: Leader ${kickedPlayer.name} was kicked. New leader: ${gameState.players[0].name}.`);
            } else if (gameState.players.length === 0) {
                gameState.leaderId = null; // No leader if no players
            }


            if (gameState.players.length === 0) {
                alert(getTranslation('allPlayersRemoved'));
                console.log(`[Game Over] ${Date.now()}: No players left. Game Over.`);
                document.getElementById('gamePage').classList.add('hidden');
                document.getElementById('lobbyPage').classList.remove('hidden');
                // Delete game document from Firestore
                if (gameState.currentGameId) {
                    await deleteDoc(doc(gamesCollectionRef, gameState.currentGameId));
                    gameState.currentGameId = null;
                    if (gameState.currentGameListener) {
                        gameState.currentGameListener(); // Unsubscribe
                        gameState.currentGameListener = null;
                    }
                }
                return;
            }

            // Adjust currentPlayerIndex if necessary
            if (gameState.currentPlayerIndex >= gameState.players.length) {
                gameState.currentPlayerIndex = 0;
                console.log(`[Player Kick Debug] ${Date.now()}: Current player index adjusted to 0 (was out of bounds).`);
            }
            console.log(`[Player Kick Debug] ${Date.now()}: After kick - New current player index: ${gameState.currentPlayerIndex}. Next player: ${gameState.players[gameState.currentPlayerIndex]?.name}.`);

            // Update UI for the new current player
            updatePlayersList();
            updateMyPropertiesList();
            updatePendingTradesList(); // This will filter out trades involving the kicked player
            checkPlayerDebtStatus(); // Check next player's debt status to disable button if needed

            // Start the timer for the next player's turn, ONLY IF there are players left
            if (gameState.players.length > 0) {
                startTurnTimer();
            }
            updateLobbyPlayerCards(); // Update lobby cards to reflect removal and potential new leader
        }


        // Function to handle dice roll and player movement
        async function handleRollDice() {
            const randomNumberDisplay = document.getElementById('randomNumberDisplay');
            const rollDiceButton = document.getElementById('rollDiceButton');
            const currentPlayer = gameState.players[gameState.currentPlayerIndex];

            // Only allow current player to roll
            if (currentPlayer.id !== gameState.currentUser.id) {
                alert("It's not your turn!");
                return;
            }

            // Check if the current player is indebted before allowing them to roll
            if (currentPlayer.money < 0) {
                alert(getTranslation('playerInDebt', currentPlayer.name, currentPlayer.money));
                rollDiceButton.disabled = true; // Ensure the button is disabled
                return; // Prevent rolling the dice
            }

            rollDiceButton.disabled = true; // Disable roll button immediately
            resetTurnTimer(); // Stop the timer while dice are rolling and moving
            console.log(`[Roll Dice Debug] ${Date.now()}: Player ${currentPlayer.name} (ID: ${currentPlayer.id}) rolling dice. Timer reset.`);

            const roll = Math.floor(Math.random() * 6) + 1;
            randomNumberDisplay.textContent = roll;
            console.log(`[Roll Dice Debug] ${Date.now()}: Player ${currentPlayer.name} rolled: ${roll}`);

            const playerToken = document.getElementById(`player-token-${currentPlayer.id}`);
            playerToken.classList.add('moving'); // Add moving class for visual effect

            const oldPositionIndex = currentPlayer.positionIndex;
            let targetPositionRaw = oldPositionIndex; // Start from old position

            // Animate player token movement step by step
            for (let i = 1; i <= roll; i++) {
                targetPositionRaw = (oldPositionIndex + i);
                const intermediatePositionIndex = targetPositionRaw % boardPath.length;
                const nextCellId = boardPath[intermediatePositionIndex];
                const nextCell = document.querySelector(`.${nextCellId}`);
                if (nextCell) {
                    // Temporarily move token to the next cell
                    nextCell.appendChild(playerToken);
                    await new Promise(resolve => setTimeout(resolve, 300)); // Short delay for animation
                }
            }

            playerToken.classList.remove('moving'); // Remove moving class after animation
            currentPlayer.positionIndex = targetPositionRaw % boardPath.length; // Update final position

            // Check if player passes or lands on Start (index 0)
            if (targetPositionRaw >= boardPath.length && oldPositionIndex !== 0) {
                currentPlayer.money += gameState.PASS_GO_MONEY;
                alert(getTranslation('playerPassedStart', currentPlayer.name, gameState.PASS_GO_MONEY));
                showMoneyEffect(currentPlayer.id, gameState.PASS_GO_MONEY, 'gain'); // Visual effect for money gain
                updatePlayersList(); // Update player's money display
                console.log(`[Roll Dice Debug] ${Date.now()}: Player ${currentPlayer.name} passed Start. Money: ${currentPlayer.money}`);
            }

            console.log(`[Roll Dice Debug] ${Date.now()}: Player ${currentPlayer.name} moved to cell: ${boardPath[currentPlayer.positionIndex]} (Index: ${currentPlayer.positionIndex}).`);

            // Handle landing on the cell
            handleLandingOnCell(currentPlayer, boardPath[currentPlayer.positionIndex]);

            // Update game state in Firestore
            await updateDoc(doc(gamesCollectionRef, gameState.currentGameId), {
                players: gameState.players,
                boardProperties: gameState.boardProperties, // In case property was bought
            });

            // Change button text to "END" after movement and cell action
            rollDiceButton.textContent = 'END';
            rollDiceButton.removeEventListener('click', handleRollDice); // Remove old listener
            rollDiceButton.addEventListener('click', endTurn); // Add new listener for ending turn
            checkPlayerDebtStatus(); // Check debt status after landing and potentially going into debt
            if (currentPlayer.money >= 0) { // Only start timer if not indebted
                startTurnTimer(); // Start the timer after the player has finished their action
            }
            console.log(`[Roll Dice Debug] ${Date.now()}: Roll dice sequence for ${currentPlayer.name} completed. Button changed to 'END'.`);
        }

        // Function to handle actions when a player lands on a cell
        function handleLandingOnCell(player, cellId) {
            console.log(`[Cell Land Debug] ${Date.now()}: Player ${player.name} (ID: ${player.id}) landed on cell: ${cellId}.`);

            const landedCellInfo = gameState.boardCellsInfo.find(cell => cell.id === cellId);

            if (!landedCellInfo) {
                console.error(`[Cell Land Error] ${Date.now()}: Landed on unknown cell: ${cellId}`);
                return; // Do not call endTurn here, rely on the "END" button
            }

            let propertyDisplayName = landedCellInfo.content[gameState.currentLanguage] || landedCellInfo.content['en'] || landedCellInfo.content;

            if (landedCellInfo.type === 'city' || landedCellInfo.type === 'company') {
                // Check if property is owned
                if (landedCellInfo.owner === null) {
                    // Show buy option
                    console.log(`[Cell Land Debug] ${Date.now()}: Landed on unowned property: ${propertyDisplayName}. Displaying buy option.`);
                    displayBuyOption(player, landedCellInfo);
                } else if (landedCellInfo.owner !== player.id) {
                    // Property is owned by another player - handle rent
                    const ownerPlayer = gameState.players.find(p => p.id === landedCellInfo.owner);
                    const rentAmount = landedCellInfo.rentLevels[landedCellInfo.currentUpgradeLevel]; // Use rent from current upgrade level

                    player.money -= rentAmount;
                    ownerPlayer.money += rentAmount;
                    updatePlayersList();
                    showMoneyEffect(player.id, rentAmount, 'loss'); // Visual effect for money loss
                    showMoneyEffect(ownerPlayer.id, rentAmount, 'gain'); // Visual effect for money gain

                    if (player.money < 0) {
                        alert(getTranslation('playerInDebt', player.name, player.money));
                        console.log(`[Cell Land Debug] ${Date.now()}: Player ${player.name} in debt. Money: ${player.money}.`);
                    } else {
                        alert(getTranslation('landedOnOwned', propertyDisplayName, ownerPlayer.name, rentAmount, player.name));
                        console.log(`[Cell Land Debug] ${Date.now()}: Player ${player.name} paid rent. Money: ${player.money}.`);
                    }
                    checkPlayerDebtStatus(); // Check debt status after rent payment
                } else {
                    // Landed on own property
                    alert(getTranslation('landedOnOwn', propertyDisplayName));
                    console.log(`[Cell Land Debug] ${Date.now()}: Player ${player.name} landed on own property.`);
                }
            } else if (landedCellInfo.type === 'corner') {
                // Handle corner actions
                if (landedCellInfo.content[gameState.currentLanguage] === getTranslation("goToJail")) {
                    alert(getTranslation('landedOnJail', player.name));
                    console.log(`[Cell Land Debug] ${Date.now()}: Player ${player.name} landed on Go to Jail.`);
                } else if (landedCellInfo.content[gameState.currentLanguage] === getTranslation("surprise")) {
                    alert(getTranslation('landedOnSurprise', player.name));
                    console.log(`[Cell Land Debug] ${Date.now()}: Player ${player.name} landed on Surprise.`);
                } else if (landedCellInfo.content[gameState.currentLanguage] === getTranslation("vacation")) {
                    alert(getTranslation('landedOnVacation', player.name));
                    console.log(`[Cell Land Debug] ${Date.now()}: Player ${player.name} landed on Vacation.`);
                }
            } else {
                // Other types of cells (e.g., tax, bonus cards - future expansion)
                alert(getTranslation('landedOnMisc', propertyDisplayName));
                console.log(`[Cell Land Debug] ${Date.now()}: Player ${player.name} landed on miscellaneous cell: ${propertyDisplayName}.`);
            }
            // IMPORTANT: Do NOT call endTurn() here. The "END" button handles turn progression.
        }

        // Function to display the buy property modal
        function displayBuyOption(player, property) {
            const buyModal = document.getElementById('buyPropertyModal');
            const modalTitle = document.getElementById('propertyModalTitle');
            const modalPrice = document.getElementById('propertyModalPrice');
            const playerMoneyDisplay = document.getElementById('playerCurrentMoney');
            const buyButton = document.getElementById('buyPropertyBtn');
            const cancelButton = document.getElementById('cancelBuyBtn');

            let propertyDisplayName = property.content[gameState.currentLanguage] || property.content['en'] || property.content;

            modalTitle.textContent = getTranslation('buyPropertyQuestion', propertyDisplayName);
            modalPrice.textContent = `$${property.price}`;
            playerMoneyDisplay.textContent = `$${player.money}`;

            buyModal.classList.remove('hidden');
            console.log(`[Buy Option Debug] ${Date.now()}: Buy property modal displayed for: ${propertyDisplayName}. Player: ${player.name}.`);


            // Clear previous listeners to prevent multiple bindings
            buyButton.onclick = null;
            cancelButton.onclick = null;

            buyButton.onclick = async () => {
                if (player.money >= property.price) {
                    player.money -= property.price;
                    property.owner = player.id; // Assign owner ID
                    gameState.boardProperties[property.id] = { // Store ownership in gameState
                        id: property.id,
                        content: property.content, // Use content for property name
                        price: property.price, // Store original purchase price
                        ownerId: player.id,
                        currentUpgradeLevel: property.currentUpgradeLevel // Store initial upgrade level
                    };

                    // Find the cell element to update its color bar
                    const cellElement = document.querySelector(`.${property.id}`);
                    if (cellElement) {
                        updateBoardCellDisplay(cellElement, property); // Update the cell display after purchase
                    }


                    updatePlayersList();
                    updateMyPropertiesList();
                    alert(getTranslation('playerBought', player.name, propertyDisplayName, property.price));
                    showMoneyEffect(player.id, property.price, 'loss'); // Visual effect for money loss
                    buyModal.classList.add('hidden');
                    console.log(`[Buy Option Debug] ${Date.now()}: Player ${player.name} bought ${propertyDisplayName}. Money: ${player.money}.`);
                } else {
                    // Allow buying with negative money, but player becomes indebted
                    player.money -= property.price;
                    property.owner = player.id;
                    gameState.boardProperties[property.id] = {
                        id: property.id,
                        content: property.content,
                        price: property.price,
                        ownerId: player.id,
                        currentUpgradeLevel: property.currentUpgradeLevel
                    };

                    const cellElement = document.querySelector(`.${property.id}`);
                    if (cellElement) {
                        updateBoardCellDisplay(cellElement, property);
                    }

                    updatePlayersList();
                    updateMyPropertiesList();
                    alert(getTranslation('playerInDebt', player.name, player.money));
                    showMoneyEffect(player.id, property.price, 'loss');
                    buyModal.classList.add('hidden');
                    console.log(`[Buy Option Debug] ${Date.now()}: Player ${player.name} bought ${propertyDisplayName} and went into debt. Money: ${player.money}.`);
                }
                checkPlayerDebtStatus(); // Check debt status after purchase

                // Update game state in Firestore
                if (gameState.currentGameId) {
                    await updateDoc(doc(gamesCollectionRef, gameState.currentGameId), {
                        players: gameState.players,
                        boardProperties: gameState.boardProperties,
                        boardCellsInfo: gameState.boardCellsInfo // Update cell info for owner/level
                    });
                }
                // IMPORTANT: Do NOT call endTurn() here. The "END" button handles turn progression.
            };

            cancelButton.onclick = async () => {
                buyModal.classList.add('hidden');
                alert(getTranslation('playerPassed', player.name, propertyDisplayName));
                console.log(`[Buy Option Debug] ${Date.now()}: Player ${player.name} passed on ${propertyDisplayName}.`);
                checkPlayerDebtStatus(); // Check debt status (in case they were already indebted)
                // IMPORTANT: Do NOT call endTurn() here. The "END" button handles turn progression.
            };
        }

        // Function to check if a player owns all cities of a specific country
        function checkCountryOwnership(player, country) {
            const countryCities = gameState.boardCellsInfo.filter(cell => cell.type === 'city' && (cell.country[gameState.currentLanguage] === country || cell.country['en'] === country));
            if (countryCities.length === 0) {
                return false; // No cities for this country defined
            }
            return countryCities.every(city => gameState.boardProperties[city.id] && gameState.boardProperties[city.id].ownerId === player.id);
        }

        // Function to display property details modal
        function displayPropertyDetails(cellId) {
            const propertyDetailsModal = document.getElementById('propertyDetailsModal');
            const propertyDetailIcon = document.getElementById('propertyDetailIcon');
            const propertyDetailName = document.getElementById('propertyDetailName');
            const propertyDetailPrice = document.getElementById('propertyDetailPrice');
            const propertyRentLevelsList = document.getElementById('propertyRentLevels');
            const currentUpgradeLevelDisplay = document.getElementById('currentUpgradeLevelDisplay');
            const upgradePropertyBtn = document.getElementById('upgradePropertyBtn');
            const downgradePropertyBtn = document.getElementById('downgradePropertyBtn');
            const upgradeCostText = document.getElementById('upgradeCostText'); // New span for upgrade cost
            const downgradeRefundText = document.getElementById('downgradeRefundText'); // New span for downgrade refund
            const upgradeSection = document.getElementById('upgradeSection');

            const property = gameState.boardCellsInfo.find(cell => cell.id === cellId);
            const currentPlayer = gameState.players.find(p => p.id === gameState.currentUser?.id); // Get current logged-in player

            if (!property) {
                console.error("Property not found for details:", cellId);
                return;
            }

            let propertyDisplayName = property.content[gameState.currentLanguage] || property.content['en'] || property.content;
            let propertyCountryName = property.country ? (property.country[gameState.currentLanguage] || property.country['en'] || property.country) : '';

            // Populate modal content
            propertyDetailName.textContent = propertyDisplayName;
            propertyDetailPrice.textContent = `$${property.price}`;

            // Set icon (flag or emoji)
            if (property.type === 'city') {
                propertyDetailIcon.innerHTML = getCountryFlagImage(propertyCountryName); // Still use country flag for property details modal
            } else if (property.type === 'company') {
                propertyDetailIcon.innerHTML = `<span class="text-3xl">${getCompanyEmoji(propertyDisplayName)}</span>`;
            }

            // Populate rent levels
            propertyRentLevelsList.innerHTML = '';
            let rentLevelLabels;
            if (property.type === 'city') {
                rentLevelLabels = [getTranslation("baseRent"), `${getTranslation("level")} 1`, `${getTranslation("level")} 2`, `${getTranslation("level")} 3`, `${getTranslation("level")} 4`];
            } else if (property.type === 'company') {
                rentLevelLabels = [getTranslation("baseRent")]; // Only base rent for companies
            } else {
                rentLevelLabels = [getTranslation("baseRent"), `${getTranslation("level")} 1`, `${getTranslation("level")} 2`, `${getTranslation("level")} 3`, `${getTranslation("level")} 4`]; // Fallback
            }

            property.rentLevels.forEach((rent, index) => {
                const listItem = document.createElement('li');
                listItem.classList.add('rent-level-item');
                if (index === property.currentUpgradeLevel) {
                    listItem.classList.add('current-rent');
                }
                listItem.innerHTML = `<span>${rentLevelLabels[index]}:</span> <span>$${rent}</span>`;
                propertyRentLevelsList.appendChild(listItem);
            });

            // Show upgrade section only if owned by current player and it's a city
            if (currentPlayer && property.owner === currentPlayer.id && property.type === 'city') {
                upgradeSection.classList.remove('hidden');
                currentUpgradeLevelDisplay.textContent = `${getTranslation('level')} ${property.currentUpgradeLevel}`; // Display "Level X"

                const ownsAllCountryCities = checkCountryOwnership(currentPlayer, propertyCountryName);

                // Calculate and display next upgrade cost
                if (property.currentUpgradeLevel < property.rentLevels.length - 1 && ownsAllCountryCities) {
                    const nextRentLevelValue = property.rentLevels[property.currentUpgradeLevel + 1];
                    const upgradeCost = roundToNearestFive(nextRentLevelValue * 0.5); // 50% of the next rent price, rounded to nearest 5
                    upgradeCostText.textContent = `$${upgradeCost}`;
                    upgradePropertyBtn.disabled = currentPlayer.money < upgradeCost;
                } else {
                    upgradeCostText.textContent = getTranslation("max"); // Indicate max level
                    upgradePropertyBtn.disabled = true;
                }

                // Calculate and display downgrade refund amount
                if (property.currentUpgradeLevel > 0) {
                    const currentRentLevelValue = property.rentLevels[property.currentUpgradeLevel];
                    const refundedAmount = roundToNearestFive(currentRentLevelValue * 0.5); // Refund 50% of current level rent, rounded to nearest 5
                    downgradeRefundText.textContent = `$${refundedAmount}`;
                    downgradePropertyBtn.disabled = false;
                } else {
                    downgradeRefundText.textContent = getTranslation("min"); // Indicate min level
                    downgradePropertyBtn.disabled = true;
                }

                // Re-attach listeners to prevent multiple bindings
                upgradePropertyBtn.onclick = () => handleUpgradeProperty(property.id);
                downgradePropertyBtn.onclick = () => handleDowngradeProperty(property.id);

            } else {
                upgradeSection.classList.add('hidden'); // Hide upgrade section if not owned by current player or if it's a company
            }

            propertyDetailsModal.classList.remove('hidden');
            console.log(`[Property Details Debug] ${Date.now()}: Property details modal displayed for: ${propertyDisplayName}.`);
        }

        // Handle property upgrade
        async function handleUpgradeProperty(propertyId) {
            const property = gameState.boardCellsInfo.find(cell => cell.id === propertyId);
            const currentPlayer = gameState.players.find(p => p.id === gameState.currentUser?.id);

            let propertyDisplayName = property.content[gameState.currentLanguage] || property.content['en'] || property.content;
            let propertyCountryName = property.country ? (property.country[gameState.currentLanguage] || property.country['en'] || property.country) : '';

            if (!property || property.owner !== currentPlayer.id || property.type !== 'city') { // Ensure it's a city owned by current player
                alert(getTranslation("notOwnedOrExists"));
                console.warn(`[Upgrade Debug] ${Date.now()}: Upgrade failed. Not owned by current player or not a city.`);
                return;
            }

            const ownsAllCountryCities = checkCountryOwnership(currentPlayer, propertyCountryName);
            if (!ownsAllCountryCities) {
                alert(getTranslation('mustOwnAllCities', propertyCountryName));
                console.warn(`[Upgrade Debug] ${Date.now()}: Upgrade failed. Does not own all cities in country.`);
                return;
            }

            if (property.currentUpgradeLevel >= property.rentLevels.length - 1) { // Check against rentLevels length
                alert(getTranslation("maxLevel"));
                console.warn(`[Upgrade Debug] ${Date.now()}: Upgrade failed. Max level reached.`);
                return;
            }

            const nextRentLevelValue = property.rentLevels[property.currentUpgradeLevel + 1];
            const upgradeCost = roundToNearestFive(nextRentLevelValue * 0.5); // 50% of the next rent price, rounded to nearest 5

            if (currentPlayer.money < upgradeCost) {
                alert(getTranslation("notEnoughMoney"));
                console.warn(`[Upgrade Debug] ${Date.now()}: Upgrade failed. Insufficient money.`);
                return;
            }

            currentPlayer.money -= upgradeCost;
            property.currentUpgradeLevel++;

            // Update the property in gameState.boardProperties as well
            if (gameState.boardProperties[property.id]) {
                gameState.boardProperties[property.id].currentUpgradeLevel = property.currentUpgradeLevel;
            }

            updatePlayersList();
            updateMyPropertiesList(); // This might not show upgrade level, but good to call
            displayPropertyDetails(propertyId); // Re-display modal to update info

            const cellElement = document.querySelector(`.${property.id}`);
            if (cellElement) {
                updateBoardCellDisplay(cellElement, property); // Update the cell display after upgrade
            }

            alert(getTranslation('playerUpgraded', currentPlayer.name, propertyDisplayName, property.currentUpgradeLevel));
            showMoneyEffect(currentPlayer.id, upgradeCost, 'loss'); // Visual effect for money loss
            checkPlayerDebtStatus(); // Check debt status after upgrade
            console.log(`[Upgrade Debug] ${Date.now()}: Player ${currentPlayer.name} upgraded ${propertyDisplayName} to level ${property.currentUpgradeLevel}. Cost: $${upgradeCost}. Money: ${currentPlayer.money}.`);

            // Update game state in Firestore
            if (gameState.currentGameId) {
                await updateDoc(doc(gamesCollectionRef, gameState.currentGameId), {
                    players: gameState.players,
                    boardProperties: gameState.boardProperties,
                    boardCellsInfo: gameState.boardCellsInfo // Update cell info for owner/level
                });
            }
        }

        // Handle property downgrade
        async function handleDowngradeProperty(propertyId) {
            const property = gameState.boardCellsInfo.find(cell => cell.id === propertyId);
            const currentPlayer = gameState.players.find(p => p.id === gameState.currentUser?.id);

            let propertyDisplayName = property.content[gameState.currentLanguage] || property.content['en'] || property.content;

            if (!property || property.owner !== currentPlayer.id || property.type !== 'city') { // Ensure it's a city owned by current player
                alert(getTranslation("notOwnedOrExists"));
                console.warn(`[Downgrade Debug] ${Date.now()}: Downgrade failed. Not owned by current player or not a city.`);
                return;
            }

            if (property.currentUpgradeLevel <= 0) {
                alert(getTranslation("minLevel"));
                console.warn(`[Downgrade Debug] ${Date.now()}: Downgrade failed. Already at min level.`);
                return;
            }

            // Refund half the cost of the last upgrade (which was 50% of the rent of the level it's downgrading *from*)
            const currentRentLevelValue = property.rentLevels[property.currentUpgradeLevel];
            const refundedAmount = roundToNearestFive(currentRentLevelValue * 0.5); // Refund 50% of current level rent, rounded to nearest 5

            currentPlayer.money += refundedAmount;
            property.currentUpgradeLevel--;

            // Update the property in gameState.boardProperties as well
            if (gameState.boardProperties[property.id]) {
                gameState.boardProperties[property.id].currentUpgradeLevel = property.currentUpgradeLevel;
            }

            updatePlayersList();
            updateMyPropertiesList();
            displayPropertyDetails(propertyId); // Re-display modal to update info

            const cellElement = document.querySelector(`.${property.id}`);
            if (cellElement) {
                updateBoardCellDisplay(cellElement, property); // Update the cell display after downgrade
            }

            alert(getTranslation('playerDowngraded', currentPlayer.name, propertyDisplayName, refundedAmount, property.currentUpgradeLevel));
            showMoneyEffect(currentPlayer.id, refundedAmount, 'gain'); // Visual effect for money gain
            checkPlayerDebtStatus(); // Check debt status after downgrade
            console.log(`[Downgrade Debug] ${Date.now()}: Player ${currentPlayer.name} downgraded ${propertyDisplayName} to level ${property.currentUpgradeLevel}. Refunded: $${refundedAmount}. Money: ${currentPlayer.money}.`);

            // Update game state in Firestore
            if (gameState.currentGameId) {
                await updateDoc(doc(gamesCollectionRef, gameState.currentGameId), {
                    players: gameState.players,
                    boardProperties: gameState.boardProperties,
                    boardCellsInfo: gameState.boardCellsInfo // Update cell info for owner/level
                });
            }
        }


        // Function to end the current player's turn and switch to the next
        async function endTurn() {
            const rollDiceButton = document.getElementById('rollDiceButton');
            const currentPlayer = gameState.players[gameState.currentPlayerIndex];

            // Only allow current player to end turn
            if (currentPlayer.id !== gameState.currentUser.id) {
                alert("It's not your turn!");
                return;
            }

            console.log(`[End Turn Debug] ${Date.now()}: endTurn called for ${currentPlayer?.name || 'unknown player'} (ID: ${currentPlayer?.id}). Money: ${currentPlayer?.money}.`);

            // Check if the current player is indebted (money is negative)
            if (currentPlayer.money < 0) {
                alert(getTranslation('playerInDebt', currentPlayer.name, currentPlayer.money));
                // Keep the button as "END" and disabled
                rollDiceButton.textContent = 'END';
                rollDiceButton.disabled = true;
                // Re-attach the endTurn listener to itself so it remains in the 'END' state
                rollDiceButton.removeEventListener('click', handleRollDice); // Ensure handleRollDice is removed
                rollDiceButton.removeEventListener('click', endTurn); // Remove existing endTurn listener
                rollDiceButton.addEventListener('click', endTurn); // Re-add endTurn listener
                console.log(`[End Turn Debug] ${Date.now()}: Player ${currentPlayer.name} is in debt. Cannot end turn.`);
                return; // Prevent ending the turn
            }

            // If not indebted, proceed with ending the turn
            resetTurnTimer(); // Stop the timer for the current player
            rollDiceButton.textContent = getTranslation('play');
            rollDiceButton.removeEventListener('click', endTurn);
            rollDiceButton.addEventListener('click', handleRollDice);
            rollDiceButton.disabled = false;

            gameState.currentPlayerIndex = (gameState.currentPlayerIndex + 1) % gameState.players.length;
            const nextPlayer = gameState.players[gameState.currentPlayerIndex];
            alert(getTranslation('turnEnded', currentPlayer.name, nextPlayer.name));
            console.log(`[End Turn Debug] ${Date.now()}: Turn ended for ${currentPlayer.name}. It's now ${nextPlayer.name}'s turn (ID: ${nextPlayer.id}). New current player index: ${gameState.currentPlayerIndex}.`);
            updatePlayersList(); // Re-render to update money display and highlight
            updateMyPropertiesList(); // Update properties for the new current player
            checkPlayerDebtStatus(); // Check next player's debt status to disable button if needed

            // Update game state in Firestore
            if (gameState.currentGameId) {
                await updateDoc(doc(gamesCollectionRef, gameState.currentGameId), {
                    currentPlayerIndex: gameState.currentPlayerIndex,
                    players: gameState.players // Update players array as well (money, position)
                });
            }

            // Start the timer for the next player
            startTurnTimer();
        }

        // --- Trade System Functions ---

        /**
         * Populates the requested properties list based on the selected recipient.
         * @param {string} recipientUserId - The Firestore userId of the player whose properties are to be listed.
         */
        function updateRequestedPropertiesForRecipient(recipientUserId) {
            const requestedPropertiesList = document.getElementById('requestedPropertiesList');
            requestedPropertiesList.innerHTML = ''; // Clear current list

            const recipientPlayerInGame = gameState.players.find(p => p.userId === recipientUserId);

            if (!recipientPlayerInGame) {
                const p = document.createElement('p');
                p.classList.add('text-gray-400');
                p.textContent = getTranslation('noPropertiesToRequest');
                requestedPropertiesList.appendChild(p);
                return;
            }

            const recipientProperties = Object.values(gameState.boardProperties).filter(prop => prop.ownerId === recipientPlayerInGame.id);

            if (recipientProperties.length > 0) {
                recipientProperties.forEach(prop => {
                    const listItem = document.createElement('div');
                    listItem.className = 'flex items-center gap-2';
                    const originalCell = gameState.boardCellsInfo.find(cell => cell.id === prop.id);
                    let iconHtml = '';
                    let propertyDisplayName = originalCell.content[gameState.currentLanguage] || originalCell.content['en'] || originalCell.content;
                    if (originalCell && originalCell.type === 'city') {
                        iconHtml = `${getCountryFlagImage(originalCell.country[gameState.currentLanguage] || originalCell.country['en'])}`;
                    } else if (originalCell && originalCell.type === 'company') {
                        iconHtml = `<span class="text-lg">${getCompanyEmoji(propertyDisplayName)}</span>`;
                    }
                    listItem.innerHTML = `
                        <input type="checkbox" id="request-prop-${prop.id}" value="${prop.id}" class="form-checkbox h-4 w-4 text-purple-600">
                        <label for="request-prop-${prop.id}" class="text-gray-300 text-sm flex items-center gap-1">
                            ${iconHtml} <span>${propertyDisplayName}</span>
                        </label>
                    `;
                    requestedPropertiesList.appendChild(listItem);
                });
            } else {
                const p = document.createElement('p');
                p.classList.add('text-gray-400');
                p.textContent = getTranslation('noPropertiesToRequest');
                requestedPropertiesList.appendChild(p);
            }
        }

        /**
         * Opens the trade creation modal, populating it with available options.
         * @param {string} senderUserId - The Firestore userId of the player initiating the trade.
         * @param {object} [existingOffer=null] - Optional: An existing trade offer object to pre-fill the modal for modification.
         */
        function openTradeCreationModal(senderUserId, existingOffer = null) {
            const tradeCreationModal = document.getElementById('tradeCreationModal');
            const tradeRecipientSelect = document.getElementById('tradeRecipient');
            const offeredPropertiesList = document.getElementById('offeredPropertiesList');
            const offerMoneyInput = document.getElementById('offerMoney');
            const requestMoneyInput = document.getElementById('requestMoney');
            const tradeOfferIdToModify = document.getElementById('tradeOfferIdToModify');

            const senderPlayerInGame = gameState.players.find(p => p.userId === senderUserId);

            if (!senderPlayerInGame) {
                console.error("Sender player not found in current game for trade:", senderUserId);
                alert("Error: You are not in a game or your player data is missing.");
                return;
            }

            // Clear previous selections/inputs
            offerMoneyInput.value = 0;
            requestMoneyInput.value = 0;
            offeredPropertiesList.innerHTML = '';
            tradeRecipientSelect.innerHTML = '';
            tradeOfferIdToModify.value = ''; // Clear ID for new offers

            // Populate trade recipient dropdown (all players in the game except the sender)
            const otherPlayersInGame = gameState.players.filter(p => p.userId !== senderUserId);
            if (otherPlayersInGame.length === 0) {
                alert(getTranslation("noOtherPlayers"));
                tradeCreationModal.classList.add('hidden');
                return;
            }

            otherPlayersInGame.forEach(player => {
                const option = document.createElement('option');
                option.value = player.userId; // Use userId for recipient
                option.textContent = player.name;
                tradeRecipientSelect.appendChild(option);
            });

            // Set up the change listener for the recipient dropdown
            tradeRecipientSelect.onchange = (event) => {
                const selectedRecipientUserId = event.target.value;
                updateRequestedPropertiesForRecipient(selectedRecipientUserId);
            };

            // Populate offered properties (current player's properties)
            const senderProperties = Object.values(gameState.boardProperties).filter(prop => prop.ownerId === senderPlayerInGame.id);
            if (senderProperties.length > 0) {
                senderProperties.forEach(prop => {
                    const listItem = document.createElement('div');
                    listItem.className = 'flex items-center gap-2';
                    const originalCell = gameState.boardCellsInfo.find(cell => cell.id === prop.id);
                    let iconHtml = '';
                    let propertyDisplayName = originalCell.content[gameState.currentLanguage] || originalCell.content['en'] || originalCell.content;
                    if (originalCell && originalCell.type === 'city') {
                        iconHtml = `${getCountryFlagImage(originalCell.country[gameState.currentLanguage] || originalCell.country['en'])}`;
                    } else if (originalCell && originalCell.type === 'company') {
                        iconHtml = `<span class="text-lg">${getCompanyEmoji(propertyDisplayName)}</span>`;
                    }
                    listItem.innerHTML = `
                        <input type="checkbox" id="offer-prop-${prop.id}" value="${prop.id}" class="form-checkbox h-4 w-4 text-purple-600">
                        <label for="offer-prop-${prop.id}" class="text-gray-300 text-sm flex items-center gap-1">
                            ${iconHtml} <span>${propertyDisplayName}</span>
                        </label>
                    `;
                    offeredPropertiesList.appendChild(listItem);
                });
            } else {
                const p = document.createElement('p');
                p.classList.add('text-gray-400');
                p.textContent = getTranslation('noPropertiesToOffer');
                offeredPropertiesList.appendChild(p);
            }

            // If an existing offer is provided, pre-fill the modal
            if (existingOffer) {
                tradeCreationModal.querySelector('h3').textContent = getTranslation('modifyTradeOffer');
                tradeOfferIdToModify.value = existingOffer.offerId;
                offerMoneyInput.value = existingOffer.offeredMoney;
                requestMoneyInput.value = existingOffer.requestedMoney;

                // Select recipient
                tradeRecipientSelect.value = existingOffer.recipientUserId;

                // Check offered properties
                existingOffer.offeredProperties.forEach(propId => {
                    const checkbox = document.getElementById(`offer-prop-${propId}`);
                    if (checkbox) checkbox.checked = true;
                });

                // Update requested properties for the selected recipient and then check them
                updateRequestedPropertiesForRecipient(existingOffer.recipientUserId);
                setTimeout(() => { // Small delay to ensure properties are rendered
                    existingOffer.requestedProperties.forEach(propId => {
                        const checkbox = document.getElementById(`request-prop-${prop.id}`);
                        if (checkbox) checkbox.checked = true;
                    });
                }, 50);

            } else {
                tradeCreationModal.querySelector('h3').textContent = getTranslation('createTradeOffer');
                // Populate requested properties for the initially selected recipient (only for new offers)
                if (tradeRecipientSelect.value) {
                    updateRequestedPropertiesForRecipient(tradeRecipientSelect.value);
                }
            }

            tradeCreationModal.classList.remove('hidden');
            console.log(`[Trade Debug] ${Date.now()}: Trade creation modal opened for sender ${senderUserId}. Existing offer: ${existingOffer ? 'yes' : 'no'}.`);
        }

        /**
         * Sends the trade offer based on the values in the trade creation modal.
         */
        async function sendTradeOffer() {
            const senderPlayerInGame = gameState.players.find(p => p.userId === gameState.currentUser.id); // The current logged-in player is the sender
            const recipientUserId = document.getElementById('tradeRecipient').value;
            const offeredMoney = parseInt(document.getElementById('offerMoney').value);
            const requestedMoney = parseInt(document.getElementById('requestMoney').value);
            const tradeOfferId = document.getElementById('tradeOfferIdToModify').value; // Get ID if modifying

            const offeredProperties = Array.from(document.querySelectorAll('#offeredPropertiesList input:checked')).map(cb => cb.value);
            const requestedProperties = Array.from(document.querySelectorAll('#requestedPropertiesList input:checked')).map(cb => cb.value);

            if (!recipientUserId) {
                alert(getTranslation("selectRecipient"));
                console.warn(`[Trade Debug] ${Date.now()}: Send trade failed: No recipient selected.`);
                return;
            }

            if (offeredMoney <= 0 && requestedMoney <= 0 && offeredProperties.length === 0 && requestedProperties.length === 0) {
                alert(getTranslation("specifyItems"));
                console.warn(`[Trade Debug] ${Date.now()}: Send trade failed: No items specified.`);
                return;
            }

            // Validate offered money
            if (offeredMoney > senderPlayerInGame.money) {
                alert(getTranslation("insufficientMoneyOffer"));
                console.warn(`[Trade Debug] ${Date.now()}: Send trade failed: Insufficient money offered by sender.`);
                return;
            }

            // Validate offered properties are actually owned by sender
            const invalidOfferedProps = offeredProperties.filter(propId =>
                !gameState.boardProperties[propId] || gameState.boardProperties[propId].ownerId !== senderPlayerInGame.id
            );
            if (invalidOfferedProps.length > 0) {
                alert(getTranslation("onlyOwnProperties"));
                console.warn(`[Trade Debug] ${Date.now()}: Send trade failed: Invalid offered properties.`);
                return;
            }

            // Validate requested properties are actually owned by recipient
            const recipientPlayerInGame = gameState.players.find(p => p.userId === recipientUserId);
            const invalidRequestedProps = requestedProperties.filter(propId =>
                !gameState.boardProperties[propId] || gameState.boardProperties[propId].ownerId !== recipientPlayerInGame.id
            );
            if (invalidRequestedProps.length > 0) {
                alert(getTranslation("onlyRequestOwned"));
                console.warn(`[Trade Debug] ${Date.now()}: Send trade failed: Invalid requested properties.`);
                return;
            }

            const newTradeOffer = {
                offerId: tradeOfferId ? tradeOfferId : crypto.randomUUID(), // Reuse ID if modifying, otherwise new UUID
                senderUserId: senderPlayerInGame.userId, // Use userId for sender
                recipientUserId: recipientUserId, // Use userId for recipient
                offeredMoney: offeredMoney,
                offeredProperties: offeredProperties,
                requestedMoney: requestedMoney,
                requestedProperties: requestedProperties,
                status: "pending",
                timestamp: Date.now()
            };

            // If modifying, remove the old offer before adding the new one
            if (tradeOfferId) {
                gameState.pendingTradeOffers = gameState.pendingTradeOffers.filter(o => o.offerId !== tradeOfferId);
                console.log(`[Trade Debug] ${Date.now()}: Modifying existing trade offer ID: ${tradeOfferId}.`);
            }

            gameState.pendingTradeOffers.push(newTradeOffer);
            document.getElementById('tradeCreationModal').classList.add('hidden');
            alert(getTranslation('offerSent', recipientPlayerInGame.name));
            console.log(`[Trade Debug] ${Date.now()}: Trade offer sent. Offer details:`, newTradeOffer);

            // Update game state in Firestore
            if (gameState.currentGameId) {
                await updateDoc(doc(gamesCollectionRef, gameState.currentGameId), {
                    pendingTradeOffers: gameState.pendingTradeOffers
                });
            }
            updatePendingTradesList(); // Update the public list
        }

        /**
         * Displays an incoming trade offer to the recipient.
         * @param {object} offer - The trade offer object.
         */
        function displayIncomingTradeOffer(offer) {
            const incomingTradeOfferModal = document.getElementById('incomingTradeOfferModal');
            const offerSenderName = document.getElementById('offerSenderName');
            const offerReceivedMoney = document.getElementById('offerReceivedMoney');
            const offerReceivedProperties = document.getElementById('offerReceivedProperties');
            const requestSentMoney = document.getElementById('requestSentMoney');
            const requestSentProperties = document.getElementById('requestSentProperties');

            const sender = gameState.players.find(p => p.userId === offer.senderUserId);
            if (!sender) {
                console.error(`[Trade Debug] ${Date.now()}: Sender not found for incoming trade offer.`);
                return;
            }

            gameState.currentActiveTradeOffer = offer; // Store the active offer
            console.log(`[Trade Debug] ${Date.now()}: Displaying incoming trade offer from ${sender.name} (ID: ${sender.id}). Offer ID: ${offer.offerId}.`);

            offerSenderName.textContent = sender.name;
            offerReceivedMoney.textContent = offer.offeredMoney;
            requestSentMoney.textContent = offer.requestedMoney;

            offerReceivedProperties.innerHTML = '';
            if (offer.offeredProperties.length > 0) {
                offer.offeredProperties.forEach(propId => {
                    const prop = gameState.boardCellsInfo.find(cell => cell.id === propId);
                    if (prop) {
                        const listItem = document.createElement('li');
                        listItem.classList.add('flex', 'items-center', 'gap-1'); // Added flex for horizontal alignment
                        let iconHtml = '';
                        let propertyDisplayName = prop.content[gameState.currentLanguage] || prop.content['en'] || prop.content;
                        if (prop.type === 'city') {
                            iconHtml = `${getCountryFlagImage(prop.country[gameState.currentLanguage] || prop.country['en'])}`;
                        } else if (prop.type === 'company') {
                            iconHtml = `<span class="text-lg">${getCompanyEmoji(propertyDisplayName)}</span>`;
                        }
                        listItem.innerHTML = `${iconHtml} <span>${propertyDisplayName}</span>`; // Wrapped text in span
                        offerReceivedProperties.appendChild(listItem);
                    }
                });
            } else {
                offerReceivedProperties.innerHTML = `<li>${getTranslation('none')}</li>`;
            }

            requestSentProperties.innerHTML = '';
            if (offer.requestedProperties.length > 0) {
                offer.requestedProperties.forEach(propId => {
                    const prop = gameState.boardCellsInfo.find(cell => cell.id === propId);
                    if (prop) {
                        const listItem = document.createElement('li');
                        listItem.classList.add('flex', 'items-center', 'gap-1'); // Added flex for horizontal alignment
                        let iconHtml = '';
                        let propertyDisplayName = prop.content[gameState.currentLanguage] || prop.content['en'] || prop.content;
                        if (prop.type === 'city') {
                            iconHtml = `${getCountryFlagImage(prop.country[gameState.currentLanguage] || prop.country['en'])}`;
                        } else if (prop.type === 'company') {
                            iconHtml = `<span class="text-lg">${getCompanyEmoji(propertyDisplayName)}</span>`;
                        }
                        listItem.innerHTML = `${iconHtml} <span>${propertyDisplayName}</span>`; // Wrapped text in span
                        requestSentProperties.appendChild(listItem);
                    }
                });
            } else {
                requestSentProperties.innerHTML = `<li>${getTranslation('none')}</li>`;
            }

            incomingTradeOfferModal.classList.remove('hidden');
        }

        /**
         * Handles the acceptance of the current active trade offer.
         */
        async function acceptTrade() {
            const offer = gameState.currentActiveTradeOffer;
            if (!offer) {
                console.error(`[Trade Debug] ${Date.now()}: No active trade offer to accept.`);
                return;
            }

            const sender = gameState.players.find(p => p.userId === offer.senderUserId);
            const recipient = gameState.players.find(p => p.userId === offer.recipientUserId);

            if (!sender || !recipient) {
                alert(getTranslation("tradeError"));
                console.error(`[Trade Debug] ${Date.now()}: Accept trade failed: Sender or recipient not found.`);
                return;
            }

            // Check if sender has enough money to offer
            if (sender.money < offer.offeredMoney) {
                alert(getTranslation('senderInsufficientMoney', sender.name));
                console.warn(`[Trade Debug] ${Date.now()}: Accept trade failed: Sender (${sender.name}) insufficient money.`);
                declineTrade(); // Automatically decline if sender can't pay
                return;
            }

            // Check if recipient has enough money to pay what's requested
            if (recipient.money < offer.requestedMoney) {
                alert(getTranslation('recipientInsufficientMoney', recipient.name));
                console.warn(`[Trade Debug] ${Date.now()}: Accept trade failed: Recipient (${recipient.name}) insufficient money.`);
                return; // Recipient can't accept if they don't have enough money
            }

            // Check if sender still owns the properties they are offering
            const senderMissingProps = offer.offeredProperties.filter(propId =>
                !gameState.boardProperties[propId] || gameState.boardProperties[propId].ownerId !== sender.id
            );
            if (senderMissingProps.length > 0) {
                alert(getTranslation('senderMissingProps', sender.name));
                console.warn(`[Trade Debug] ${Date.now()}: Accept trade failed: Sender (${sender.name}) missing offered properties.`);
                declineTrade();
                return;
            }

            // Check if recipient still owns the properties being requested from them
            const recipientMissingProps = offer.requestedProperties.filter(propId =>
                !gameState.boardProperties[propId] || gameState.boardProperties[propId].ownerId !== recipient.id
            );
            if (recipientMissingProps.length > 0) {
                alert(getTranslation('recipientMissingProps', recipient.name));
                console.warn(`[Trade Debug] ${Date.now()}: Accept trade failed: Recipient (${recipient.name}) missing requested properties.`);
                return; // Recipient can't accept if they don't own requested properties
            }


            // Perform money transfer
            sender.money -= offer.offeredMoney;
            recipient.money += offer.offeredMoney;
            showMoneyEffect(sender.id, offer.offeredMoney, 'loss');
            showMoneyEffect(recipient.id, offer.offeredMoney, 'gain');
            console.log(`[Trade Debug] ${Date.now()}: Money transfer: ${sender.name} paid $${offer.offeredMoney} to ${recipient.name}.`);


            sender.money += offer.requestedMoney;
            recipient.money -= offer.requestedMoney;
            showMoneyEffect(sender.id, offer.requestedMoney, 'gain');
            showMoneyEffect(recipient.id, offer.requestedMoney, 'loss');
            console.log(`[Trade Debug] ${Date.now()}: Money transfer: ${recipient.name} paid $${offer.requestedMoney} to ${sender.name}.`);


            // Perform property transfer
            offer.offeredProperties.forEach(propId => {
                const prop = gameState.boardCellsInfo.find(cell => cell.id === propId);
                if (prop) {
                    prop.owner = recipient.id;
                    gameState.boardProperties[propId].ownerId = recipient.id;
                    // Update property color bar on the board
                    const cellElement = document.querySelector(`.${prop.id}`);
                    if (cellElement) {
                        updateBoardCellDisplay(cellElement, prop);
                    }
                    console.log(`[Trade Debug] ${Date.now()}: Property ${prop.content[gameState.currentLanguage] || prop.content['en']} transferred from ${sender.name} to ${recipient.name}.`);
                }
            });

            offer.requestedProperties.forEach(propId => {
                const prop = gameState.boardCellsInfo.find(cell => cell.id === propId);
                if (prop) {
                    prop.owner = sender.id;
                    gameState.boardProperties[propId].ownerId = sender.id;
                    // Update property color bar on the board
                    const cellElement = document.querySelector(`.${prop.id}`);
                    if (cellElement) {
                        updateBoardCellDisplay(cellElement, prop);
                    }
                    console.log(`[Trade Debug] ${Date.now()}: Property ${prop.content[gameState.currentLanguage] || prop.content['en']} transferred from ${recipient.name} to ${sender.name}.`);
                }
            });

            // Remove the offer from pending offers
            gameState.pendingTradeOffers = gameState.pendingTradeOffers.filter(o => o.offerId !== offer.offerId);
            gameState.currentActiveTradeOffer = null; // Clear active offer

            document.getElementById('incomingTradeOfferModal').classList.add('hidden');
            document.getElementById('tradeDetailsViewModal').classList.add('hidden'); // Hide if open
            alert(getTranslation('tradeAccepted', sender.name, recipient.name));
            console.log(`[Trade Debug] ${Date.now()}: Trade offer ID ${offer.offerId} accepted.`);

            // Update game state in Firestore
            if (gameState.currentGameId) {
                await updateDoc(doc(gamesCollectionRef, gameState.currentGameId), {
                    players: gameState.players,
                    boardProperties: gameState.boardProperties,
                    boardCellsInfo: gameState.boardCellsInfo,
                    pendingTradeOffers: gameState.pendingTradeOffers
                });
            }

            updatePlayersList();
            updateMyPropertiesList(); // Update properties list for both players
            updatePendingTradesList(); // Update the public list
            checkPlayerDebtStatus(); // Check debt status after trade
        }

        /**
         * Handles the decline of the current active trade offer.
         */
        async function declineTrade() {
            const offer = gameState.currentActiveTradeOffer;
            if (!offer) {
                console.error(`[Trade Debug] ${Date.now()}: No active trade offer to decline.`);
                return;
            }

            const sender = gameState.players.find(p => p.userId === offer.senderUserId);
            const recipient = gameState.players.find(p => p.userId === offer.recipientUserId);

            gameState.pendingTradeOffers = gameState.pendingTradeOffers.filter(o => o.offerId !== offer.offerId);
            gameState.currentActiveTradeOffer = null; // Clear active offer

            document.getElementById('incomingTradeOfferModal').classList.add('hidden');
            document.getElementById('tradeDetailsViewModal').classList.add('hidden'); // Hide if open
            alert(getTranslation('tradeDeclined', sender.name, recipient.name));
            console.log(`[Trade Debug] ${Date.now()}: Trade offer ID ${offer.offerId} declined.`);

            // Update game state in Firestore
            if (gameState.currentGameId) {
                await updateDoc(doc(gamesCollectionRef, gameState.currentGameId), {
                    pendingTradeOffers: gameState.pendingTradeOffers
                });
            }
            updatePendingTradesList(); // Update the public list
            checkPlayerDebtStatus(); // Check debt status after trade
        }

        /**
         * Handles the cancellation of a trade offer by the sender.
         * @param {string} offerId - The ID of the trade offer to cancel.
         */
        async function cancelTrade(offerId) {
            const offerIndex = gameState.pendingTradeOffers.findIndex(o => o.offerId === offerId);
            if (offerIndex > -1) {
                const cancelledOffer = gameState.pendingTradeOffers.splice(offerIndex, 1)[0];
                const sender = gameState.players.find(p => p.userId === cancelledOffer.senderUserId);
                const recipient = gameState.players.find(p => p.userId === cancelledOffer.recipientUserId);
                alert(getTranslation('tradeCancelled', sender.name, recipient.name));
                gameState.currentActiveTradeOffer = null; // Clear active offer if it was the one cancelled
                document.getElementById('tradeDetailsViewModal').classList.add('hidden'); // Hide if open
                console.log(`[Trade Debug] ${Date.now()}: Trade offer ID ${offerId} cancelled by sender.`);

                // Update game state in Firestore
                if (gameState.currentGameId) {
                    await updateDoc(doc(gamesCollectionRef, gameState.currentGameId), {
                        pendingTradeOffers: gameState.pendingTradeOffers
                    });
                }
                updatePendingTradesList(); // Update the public list
                checkPlayerDebtStatus(); // Check debt status after cancellation
            } else {
                console.warn(`[Trade Debug] ${Date.now()}: Attempted to cancel non-existent trade offer ID: ${offerId}.`);
            }
        }

        /**
         * Displays the details of a trade offer in a view-only modal, with conditional action buttons.
         * @param {string} offerId - The ID of the trade offer to display.
         */
        function displayTradeDetailsView(offerId) {
            const offer = gameState.pendingTradeOffers.find(o => o.offerId === offerId);
            if (!offer) {
                alert(getTranslation("tradeNotFound"));
                console.warn(`[Trade Debug] ${Date.now()}: Trade offer not found for details view: ${offerId}.`);
                return;
            }

            const tradeDetailsViewModal = document.getElementById('tradeDetailsViewModal');
            const tradeDetailsSenderName = document.getElementById('tradeDetailsSenderName');
            const tradeDetailsRecipientName = document.getElementById('tradeDetailsRecipientName');
            const tradeDetailsOfferedMoney = document.getElementById('tradeDetailsOfferedMoney');
            const tradeDetailsOfferedProperties = document.getElementById('tradeDetailsOfferedProperties');
            const tradeDetailsRequestedMoney = document.getElementById('tradeDetailsRequestedMoney');
            const tradeDetailsRequestedProperties = document.getElementById('tradeDetailsRequestedProperties');
            const tradeDetailsActionButtons = document.getElementById('tradeDetailsActionButtons');

            const sender = gameState.players.find(p => p.userId === offer.senderUserId);
            const recipient = gameState.players.find(p => p.userId === offer.recipientUserId);
            const currentPlayer = gameState.players.find(p => p.userId === gameState.currentUser?.id);

            // Display only names in the details view, without flags
            tradeDetailsSenderName.textContent = sender ? sender.name : 'Unknown';
            tradeDetailsRecipientName.textContent = recipient ? recipient.name : 'Unknown';
            tradeDetailsOfferedMoney.textContent = offer.offeredMoney;
            tradeDetailsRequestedMoney.textContent = offer.requestedMoney;

            // Populate offered properties with flags/emojis
            tradeDetailsOfferedProperties.innerHTML = '';
            if (offer.offeredProperties.length > 0) {
                offer.offeredProperties.forEach(propId => {
                    const prop = gameState.boardCellsInfo.find(cell => cell.id === propId);
                    if (prop) {
                        const listItem = document.createElement('li');
                        listItem.classList.add('flex', 'items-center', 'gap-1'); // Added flex for horizontal alignment
                        let iconHtml = '';
                        let propertyDisplayName = prop.content[gameState.currentLanguage] || prop.content['en'] || prop.content;
                        if (prop.type === 'city') {
                            iconHtml = `${getCountryFlagImage(prop.country[gameState.currentLanguage] || prop.country['en'])}`;
                        } else if (prop.type === 'company') {
                            iconHtml = `<span class="text-lg">${getCompanyEmoji(propertyDisplayName)}</span>`;
                        }
                        listItem.innerHTML = `${iconHtml} <span>${propertyDisplayName}</span>`; // Wrapped text in span
                        tradeDetailsOfferedProperties.appendChild(listItem);
                    }
                });
            } else {
                tradeDetailsOfferedProperties.innerHTML = `<li>${getTranslation('none')}</li>`;
            }

            // Populate requested properties with flags/emojis
            tradeDetailsRequestedProperties.innerHTML = '';
            if (offer.requestedProperties.length > 0) {
                offer.requestedProperties.forEach(propId => {
                    const prop = gameState.boardCellsInfo.find(cell => cell.id === propId);
                    if (prop) {
                        const listItem = document.createElement('li');
                        listItem.classList.add('flex', 'items-center', 'gap-1'); // Added flex for horizontal alignment
                        let iconHtml = '';
                        let propertyDisplayName = prop.content[gameState.currentLanguage] || prop.content['en'] || prop.content;
                        if (prop.type === 'city') {
                            iconHtml = `${getCountryFlagImage(prop.country[gameState.currentLanguage] || prop.country['en'])}`;
                        } else if (prop.type === 'company') {
                            iconHtml = `<span class="text-lg">${getCompanyEmoji(propertyDisplayName)}</span>`;
                        }
                        listItem.innerHTML = `${iconHtml} <span>${propertyDisplayName}</span>`; // Wrapped text in span
                        tradeDetailsRequestedProperties.appendChild(listItem);
                    }
                });
            } else {
                tradeDetailsRequestedProperties.innerHTML = `<li>${getTranslation('none')}</li>`;
            }

            // Clear and add action buttons based on current player's role
            tradeDetailsActionButtons.innerHTML = '';
            gameState.currentActiveTradeOffer = offer; // Set the active offer for accept/decline logic

            if (currentPlayer && currentPlayer.userId === offer.recipientUserId) {
                // Recipient actions
                const acceptBtn = document.createElement('button');
                acceptBtn.className = 'btn-primary py-2 px-6 rounded-md';
                acceptBtn.textContent = getTranslation('accept');
                acceptBtn.onclick = acceptTrade;
                tradeDetailsActionButtons.appendChild(acceptBtn);

                const declineBtn = document.createElement('button');
                declineBtn.className = 'btn-secondary py-2 px-6 rounded-md';
                declineBtn.textContent = getTranslation('decline');
                declineBtn.onclick = declineTrade;
                tradeDetailsActionButtons.appendChild(declineBtn);

                const modifyBtn = document.createElement('button');
                modifyBtn.className = 'btn-secondary py-2 px-6 rounded-md';
                modifyBtn.textContent = getTranslation('modify');
                modifyBtn.onclick = () => {
                    document.getElementById('tradeDetailsViewModal').classList.add('hidden');
                    // When recipient modifies, it's a counter-offer from recipient to sender
                    openTradeCreationModal(currentPlayer.userId, {
                        offerId: offer.offerId, // Keep original offerId for tracking purposes if needed, or generate new
                        senderUserId: currentPlayer.userId,
                        recipientUserId: offer.senderUserId,
                        offeredMoney: offer.requestedMoney, // What recipient was asked for, they now offer
                        offeredProperties: offer.requestedProperties, // What recipient was asked for, they now offer
                        requestedMoney: offer.offeredMoney, // What sender offered, recipient now requests
                        requestedProperties: offer.offeredProperties, // What sender offered, recipient now requests
                    });
                };
                tradeDetailsActionButtons.appendChild(modifyBtn);

            } else if (currentPlayer && currentPlayer.userId === offer.senderUserId) {
                // Sender actions
                const modifyBtn = document.createElement('button');
                modifyBtn.className = 'btn-secondary py-2 px-6 rounded-md';
                modifyBtn.textContent = getTranslation('modify');
                modifyBtn.onclick = () => {
                    document.getElementById('tradeDetailsViewModal').classList.add('hidden');
                    openTradeCreationModal(currentPlayer.userId, offer); // Pass the existing offer to pre-fill
                };
                tradeDetailsActionButtons.appendChild(modifyBtn);

                const cancelBtn = document.createElement('button');
                cancelBtn.className = 'btn-secondary py-2 px-6 rounded-md bg-red-600 hover:bg-red-700';
                cancelBtn.textContent = getTranslation('cancel');
                cancelBtn.onclick = () => cancelTrade(offer.offerId);
                tradeDetailsActionButtons.appendChild(cancelBtn);
            }

            tradeDetailsViewModal.classList.remove('hidden');
            console.log(`[Trade Debug] ${Date.now()}: Trade details view modal displayed for offer ID: ${offerId}. Current player role: ${currentPlayer?.userId === offer.recipientUserId ? 'Recipient' : currentPlayer?.userId === offer.senderUserId ? 'Sender' : 'Viewer'}.`);
        }

        /**
         * Updates the list of pending trade offers displayed in the sidebar.
         */
        function updatePendingTradesList() {
            const pendingTradesListElem = document.getElementById('pendingTradesList');
            const pendingTradesCountElem = document.getElementById('pendingTradesCount');
            pendingTradesListElem.innerHTML = ''; // Clear current list

            // Filter out trades involving players who are no longer in the game
            gameState.pendingTradeOffers = gameState.pendingTradeOffers.filter(offer =>
                gameState.players.some(p => p.userId === offer.senderUserId) &&
                gameState.players.some(p => p.id === offer.recipientUserId) // Still check game player ID for recipient
            );

            pendingTradesCountElem.textContent = gameState.pendingTradeOffers.length;
            console.log(`[Trade Debug] ${Date.now()}: Updating pending trades list. Count: ${gameState.pendingTradeOffers.length}.`);

            if (gameState.pendingTradeOffers.length === 0) {
                const noTradesMessage = document.createElement('p');
                noTradesMessage.classList.add('text-gray-400');
                noTradesMessage.textContent = getTranslation('noPendingTrades');
                pendingTradesListElem.appendChild(noTradesMessage);
            } else {
                gameState.pendingTradeOffers.forEach(offer => {
                    const sender = gameState.players.find(p => p.userId === offer.senderUserId);
                    const recipient = gameState.players.find(p => p.userId === offer.recipientUserId);

                    const senderName = sender ? sender.name : 'Unknown';
                    const recipientName = recipient ? recipient.name : 'Unknown';

                    const tradeItem = document.createElement('div');
                    tradeItem.classList.add('pending-trade-item');
                    tradeItem.innerHTML = `
                        <span class="trade-summary">${senderName} ↔ ${recipientName}</span>
                        <span class="trade-details">${getTranslation('offer')}: $${offer.offeredMoney} + ${offer.offeredProperties.length} ${getTranslation(offer.offeredProperties.length === 1 ? 'prop' : 'props')}</span>
                        <span class="trade-details">${getTranslation('request')}: $${offer.requestedMoney} + ${offer.requestedProperties.length} ${getTranslation(offer.requestedProperties.length === 1 ? 'prop' : 'props')}</span>
                    `;
                    tradeItem.onclick = () => displayTradeDetailsView(offer.offerId);
                    pendingTradesListElem.appendChild(tradeItem);
                });
            }
        }

        /**
         * Opens the sell property modal, populating it with the current player's properties.
         */
        function openSellPropertyModal() {
            const sellPropertyModal = document.getElementById('sellPropertyModal');
            const propertiesToSellList = document.getElementById('propertiesToSellList');
            const currentPlayer = gameState.players.find(p => p.id === gameState.currentUser?.id);

            if (!currentPlayer) {
                alert(getTranslation('notLoggedIn'));
                return;
            }

            propertiesToSellList.innerHTML = ''; // Clear current list

            const playerProperties = Object.values(gameState.boardProperties).filter(
                prop => prop.ownerId === currentPlayer.id
            );
            console.log(`[Sell Property Debug] ${Date.now()}: Opening sell property modal for ${currentPlayer.name}. Properties owned: ${playerProperties.length}.`);

            if (playerProperties.length === 0) {
                const p = document.createElement('p');
                p.classList.add('text-gray-400');
                p.textContent = getTranslation('noPropertiesToSell');
                propertiesToSellList.appendChild(p);
                document.getElementById('confirmSellPropertiesBtn').disabled = true;
            } else {
                document.getElementById('confirmSellPropertiesBtn').disabled = false;
                playerProperties.forEach(prop => {
                    const originalCell = gameState.boardCellsInfo.find(cell => cell.id === prop.id);
                    const sellPrice = roundToNearestFive(originalCell.price / 2); // Sell for half the original price

                    const listItem = document.createElement('div');
                    listItem.className = 'flex items-center gap-2 py-1';
                    let iconHtml = '';
                    let propertyDisplayName = originalCell.content[gameState.currentLanguage] || originalCell.content['en'] || originalCell.content;
                    if (originalCell && originalCell.type === 'city') {
                        iconHtml = `${getCountryFlagImage(originalCell.country[gameState.currentLanguage] || originalCell.country['en'])}`;
                    } else if (originalCell && originalCell.type === 'company') {
                        iconHtml = `<span class="text-lg">${getCompanyEmoji(propertyDisplayName)}</span>`;
                    }
                    listItem.innerHTML = `
                        <input type="checkbox" id="sell-prop-${prop.id}" value="${prop.id}" data-sell-price="${sellPrice}" class="form-checkbox h-4 w-4 text-purple-600">
                        <label for="sell-prop-${prop.id}" class="text-gray-300 text-sm flex items-center gap-1">
                            ${iconHtml} <span>${propertyDisplayName} ($${sellPrice})</span>
                        </label>
                    `;
                    propertiesToSellList.appendChild(listItem);
                });
            }
            sellPropertyModal.classList.remove('hidden');
        }

        /**
         * Handles the selling of selected properties.
         */
        async function sellSelectedProperties() {
            const propertiesToSellCheckboxes = document.querySelectorAll('#propertiesToSellList input[type="checkbox"]:checked');
            const currentPlayer = gameState.players.find(p => p.id === gameState.currentUser?.id);
            let totalRefund = 0;
            const soldPropertyIds = [];

            if (!currentPlayer) {
                alert(getTranslation('notLoggedIn'));
                return;
            }

            if (propertiesToSellCheckboxes.length === 0) {
                alert(getTranslation("selectAtLeastOne"));
                console.warn(`[Sell Property Debug] ${Date.now()}: No properties selected for selling.`);
                return;
            }

            propertiesToSellCheckboxes.forEach(checkbox => {
                const propId = checkbox.value;
                const sellPrice = parseInt(checkbox.dataset.sellPrice);

                totalRefund += sellPrice;
                soldPropertyIds.push(propId);

                // Update the property in gameState.boardCellsInfo and gameState.boardProperties
                const propertyInCellsInfo = gameState.boardCellsInfo.find(cell => cell.id === propId);
                if (propertyInCellsInfo) {
                    propertyInCellsInfo.owner = null; // No owner
                    propertyInCellsInfo.currentUpgradeLevel = 0; // Reset level
                    updateBoardCellDisplay(document.querySelector(`.${propId}`), propertyInCellsInfo);
                }
                delete gameState.boardProperties[propId]; // Remove from owned properties map
                console.log(`[Sell Property Debug] ${Date.now()}: Property ${propertyInCellsInfo?.content[gameState.currentLanguage] || propertyInCellsInfo?.content['en']} (ID: ${propId}) sold for $${sellPrice}.`);
            });

            currentPlayer.money += totalRefund;
            updatePlayersList();
            updateMyPropertiesList();
            document.getElementById('sellPropertyModal').classList.add('hidden');
            alert(getTranslation('playerSold', currentPlayer.name, soldPropertyIds.length, totalRefund, currentPlayer.money));
            showMoneyEffect(currentPlayer.id, totalRefund, 'gain');
            checkPlayerDebtStatus(); // Check debt status after selling properties
            console.log(`[Sell Property Debug] ${Date.now()}: Player ${currentPlayer.name} completed selling properties. Total refund: $${totalRefund}. New money: ${currentPlayer.money}.`);

            // Update game state in Firestore
            if (gameState.currentGameId) {
                await updateDoc(doc(gamesCollectionRef, gameState.currentGameId), {
                    players: gameState.players,
                    boardProperties: gameState.boardProperties,
                    boardCellsInfo: gameState.boardCellsInfo
                });
            }
        }

        /**
         * Kicks a player from the lobby by the leader.
         * @param {string} playerUserIdToKick - The userId of the player to be kicked.
         */
        async function kickPlayerFromLobby(playerUserIdToKick) {
            const leaderPlayer = gameState.players.find(p => p.userId === gameState.currentUser?.id); // Leader is the current logged-in user
            if (!leaderPlayer || leaderPlayer.id !== gameState.leaderId) {
                alert(getTranslation('onlyLeaderCanKick'));
                console.warn(`[Lobby Kick Debug] ${Date.now()}: Kick attempt failed. Current user is not the leader.`);
                return;
            }

            const playerIndexToKick = gameState.players.findIndex(p => p.userId === playerUserIdToKick);
            if (playerIndexToKick === -1) {
                console.warn(`[Lobby Kick Debug] ${Date.now()}: Attempted to kick non-existent player ID: ${playerUserIdToKick}.`);
                return;
            }

            const kickedPlayer = gameState.players[playerIndexToKick];

            // Confirmation dialog (using custom alert)
            alert(getTranslation('confirmKick', kickedPlayer.name));
            const customAlert = document.getElementById('custom-alert');
            const okButton = customAlert.querySelector('button');

            // Replace OK button with Confirm/Cancel for kick
            const confirmButton = document.createElement('button');
            confirmButton.textContent = 'Confirm'; // Not translated, as it's a temporary dialog
            confirmButton.className = 'bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-md focus:outline-none focus:ring-2 focus:ring-red-500 mr-2';
            confirmButton.onclick = async () => {
                gameState.players.splice(playerIndexToKick, 1);
                if (kickedPlayer.id === gameState.leaderId && gameState.players.length > 0) {
                    gameState.leaderId = gameState.players[0].id; // Assign new leader
                } else if (gameState.players.length === 0) {
                    gameState.leaderId = null;
                }
                updateLobbyPlayerCards();
                document.getElementById('custom-alert').remove();
                alert(getTranslation('playerKicked', kickedPlayer.name));
                console.log(`[Lobby Kick Debug] ${Date.now()}: Player ${kickedPlayer.name} (ID: ${kickedPlayer.id}) kicked from lobby.`);

                // Update game document in Firestore
                if (gameState.currentGameId) {
                    await updateDoc(doc(gamesCollectionRef, gameState.currentGameId), {
                        players: gameState.players,
                        leaderId: gameState.leaderId
                    });
                }

                // Disable play button if no players left
                if (gameState.players.length === 0) {
                    document.getElementById('lobbyPlayButton').disabled = true;
                }
            };

            const cancelButton = document.createElement('button');
            cancelButton.textContent = 'Cancel'; // Not translated
            cancelButton.className = 'bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-md focus:outline-none focus:ring-2 focus:ring-gray-500';
            cancelButton.onclick = () => {
                document.getElementById('custom-alert').remove();
                console.log(`[Lobby Kick Debug] ${Date.now()}: Kick action cancelled for player ID: ${playerUserIdToKick}.`);
            };

            okButton.replaceWith(confirmButton, cancelButton);
        }

        /**
         * Dynamically updates the player cards shown in the lobby.
         * This function will create a player card for each player in gameState.players.
         */
        function updateLobbyPlayerCards() {
            const lobbyPlayerCardsContainer = document.getElementById('lobbyPlayerCardsContainer');
            lobbyPlayerCardsContainer.innerHTML = ''; // Clear existing cards

            // Render existing players
            gameState.players.forEach(player => {
                const playerCard = document.createElement('div');
                playerCard.className = 'player-card';

                let crownHtml = '';
                if (player.id === gameState.leaderId) {
                    crownHtml = `<i class="fas fa-crown leader-crown"></i>`;
                }

                let kickButtonHtml = '';
                // Only show kick button if current user is leader and it's not their own card
                if (gameState.currentUser && gameState.leaderId !== null && gameState.currentUser.id === gameState.leaderId && player.id !== gameState.currentUser.id) {
                    kickButtonHtml = `<button class="kick-button" onclick="kickPlayerFromLobby('${player.userId}')">${getTranslation('kick')}</button>`;
                }

                playerCard.innerHTML = `
                    ${crownHtml}
                    <div class="player-icon" style="color: ${player.color};"><i class="fas fa-user-circle"></i></div>
                    <h4 class="text-lg font-bold text-white">${player.name}</h4>
                    <p class="text-gray-400">${getTranslation('money')}: <span class="text-green-400 font-bold">$${player.money}</span></p>
                    <span class="status-badge">${getTranslation('ready')}</span>
                    ${kickButtonHtml}
                `;
                lobbyPlayerCardsContainer.appendChild(playerCard);
            });

            // Add an "Add Player" card for the current user to join if not already in game
            // This logic is now replaced by the "PLAY" button which handles joining/creating games.
            // The lobby player cards will reflect players in the *current game* they are trying to join/create.
            // For now, we'll just show the current user if they are in a game state.

            // Update the lobby player count display
            document.getElementById('lobbyPlayerCount').textContent = `${gameState.players.length}/${MAX_PLAYERS_PER_GAME}`;
            document.getElementById('lobbyPlayerMoney').textContent = gameState.currentUser ? gameState.currentUser.money : '0';
            console.log(`[Lobby Debug] ${Date.now()}: Lobby player cards updated. Current count: ${gameState.players.length}/${MAX_PLAYERS_PER_GAME}.`);
        }

        // --- Settings Modal Functions ---
        function openSettingsModal() {
            const settingsModal = document.getElementById('settingsModal');
            const languageSelect = document.getElementById('languageSelect');
            languageSelect.value = gameState.currentLanguage; // Set dropdown to current language
            settingsModal.classList.remove('hidden');
            console.log(`[Settings Debug] ${Date.now()}: Settings modal opened. Current language: ${gameState.currentLanguage}.`);
        }

        function applySettings() {
            const languageSelect = document.getElementById('languageSelect');
            const selectedLanguage = languageSelect.value;
            if (gameState.currentLanguage !== selectedLanguage) {
                gameState.currentLanguage = selectedLanguage;
                updateAllTextContent(); // Re-render all text content with new language
                // Re-populate board to apply new language for city names etc.
                if (document.getElementById('gamePage').classList.contains('hidden')) {
                    // If in lobby, update lobby cards and online players
                    updateLobbyPlayerCards();
                    updateOnlinePlayersList();
                } else {
                    // If in game, re-populate board to show translated names
                    populateBoard();
                    updatePlayersList();
                    updateMyPropertiesList();
                    updatePendingTradesList();
                }
                console.log(`[Settings Debug] ${Date.now()}: Language set to: ${selectedLanguage}.`);
            }
            closeSettingsModal();
        }

        function closeSettingsModal() {
            const settingsModal = document.getElementById('settingsModal');
            settingsModal.classList.add('hidden');
            console.log(`[Settings Debug] ${Date.now()}: Settings modal closed.`);
        }

        // --- Authentication Functions ---
        const authModal = document.getElementById('authModal');
        const authLoginForm = document.getElementById('authLoginForm');
        const authSignupForm = document.getElementById('authSignupForm');
        const authModalTitle = document.getElementById('authModalTitle');
        const authUsernameInput = document.getElementById('authUsername');
        const authPasswordInput = document.getElementById('authPassword');
        const loginAuthBtn = document.getElementById('loginAuthBtn');
        const showSignupBtn = document.getElementById('showSignupBtn');
        const authErrorDiv = document.getElementById('authError');
        const authErrorMessageSpan = document.getElementById('authErrorMessage');

        const signupUsernameInput = document.getElementById('signupUsername');
        const signupPasswordInput = document.getElementById('signupPassword');
        const signupConfirmPasswordInput = document.getElementById('signupConfirmPassword');
        const signupAuthBtn = document.getElementById('signupAuthBtn');
        const showLoginBtn = document.getElementById('showLoginBtn');
        const signupErrorDiv = document.getElementById('signupError');
        const signupErrorMessageSpan = document.getElementById('signupErrorMessage');
        const closeAuthModalBtn = document.getElementById('closeAuthModalBtn');

        // Simple client-side "hashing" for demonstration. NOT SECURE FOR PRODUCTION!
        // In a real application, this would involve a strong, server-side hashing algorithm like bcrypt.
        function hashPassword(password) {
            return btoa(password); // Base64 encode as a very weak "hash"
        }

        function displayAuthError(errorDiv, errorMessageSpan, message) {
            errorMessageSpan.textContent = message;
            errorDiv.classList.remove('hidden');
        }

        function hideAuthError(errorDiv) {
            errorDiv.classList.add('hidden');
            errorDiv.querySelector('span').textContent = '';
        }

        function showAuthModal(formType = 'login') {
            authModal.classList.remove('hidden');
            if (formType === 'login') {
                authModalTitle.textContent = getTranslation('login');
                authLoginForm.classList.remove('hidden');
                authSignupForm.classList.add('hidden');
                hideAuthError(authErrorDiv);
            } else {
                authModalTitle.textContent = getTranslation('createAccount');
                authLoginForm.classList.add('hidden');
                authSignupForm.classList.remove('hidden');
                hideAuthError(signupErrorDiv);
            }
        }

        async function handleLogin() {
            hideAuthError(authErrorDiv);
            const username = authUsernameInput.value.trim();
            const password = authPasswordInput.value;

            if (!username || !password) {
                displayAuthError(authErrorDiv, authErrorMessageSpan, getTranslation('invalidCredentials'));
                return;
            }

            try {
                const q = query(usersCollectionRef, where("username", "==", username));
                const querySnapshot = await getDocs(q);

                if (querySnapshot.empty) {
                    displayAuthError(authErrorDiv, authErrorMessageSpan, getTranslation('invalidCredentials'));
                    return;
                }

                const userData = querySnapshot.docs[0].data();
                const storedPasswordHash = userData.passwordHash;
                const enteredPasswordHash = hashPassword(password);

                if (storedPasswordHash === enteredPasswordHash) {
                    gameState.currentUser = {
                        id: userData.id, // Firestore document ID as player ID
                        userId: querySnapshot.docs[0].id, // Firestore document ID as user ID
                        name: userData.username,
                        money: userData.money || gameState.STARTING_MONEY,
                        color: userData.color || '#FFFFFF', // Default color if not set
                        positionIndex: userData.positionIndex || 0,
                        isReady: userData.isReady || false,
                        currentGameId: userData.currentGameId || null // Store current game ID
                    };
                    // Update user's online status in Firestore
                    await updateDoc(doc(usersCollectionRef, gameState.currentUser.userId), {
                        isOnline: true,
                        lastActive: Date.now()
                    });

                    authModal.classList.add('hidden');
                    console.log(`User ${username} logged in successfully.`);
                    alert(getTranslation('loggedInAs', username));
                    // Transition to lobby page
                    document.getElementById('lobbyPage').classList.remove('hidden');
                    document.getElementById('lobbyPlayerMoney').textContent = gameState.currentUser.money;
                    document.getElementById('currentUserIdDisplay').textContent = gameState.currentUser.name;
                    startOnlineUsersListener(); // Start listening for other online users
                    updateOnlinePlayersList(); // Initial update of online players
                } else {
                    displayAuthError(authErrorDiv, authErrorMessageSpan, getTranslation('invalidCredentials'));
                }
            } catch (error) {
                console.error("Login error:", error);
                displayAuthError(authErrorDiv, authErrorMessageSpan, `Login failed: ${error.message}`);
            }
        }

        async function handleSignup() {
            hideAuthError(signupErrorDiv);
            const username = signupUsernameInput.value.trim();
            const password = signupPasswordInput.value;
            const confirmPassword = signupConfirmPasswordInput.value;

            if (!username || !password || !confirmPassword) {
                displayAuthError(signupErrorDiv, signupErrorMessageSpan, getTranslation('fillAllFields')); // Assuming translation key
                return;
            }
            if (password.length < 6) {
                displayAuthError(signupErrorDiv, signupErrorMessageSpan, getTranslation('passwordTooShort'));
                return;
            }
            if (password !== confirmPassword) {
                displayAuthError(signupErrorDiv, signupErrorMessageSpan, getTranslation('passwordsMismatch'));
                return;
            }

            try {
                // Check if username already exists
                const q = query(usersCollectionRef, where("username", "==", username));
                const querySnapshot = await getDocs(q);
                if (!querySnapshot.empty) {
                    displayAuthError(signupErrorDiv, signupErrorMessageSpan, getTranslation('usernameTaken'));
                    return;
                }

                const newUserId = crypto.randomUUID(); // Generate a unique ID for the user
                const playerColors = ['#FF0000', '#0000FF', '#00FF00', '#FFFF00', '#FF4500']; // Red, Blue, Green, Yellow, OrangeRed
                const assignedColor = playerColors[Math.floor(Math.random() * playerColors.length)]; // Assign a random color

                await setDoc(doc(usersCollectionRef, newUserId), {
                    username: username,
                    passwordHash: hashPassword(password),
                    isOnline: false, // Not online until they log in
                    lastActive: null,
                    money: gameState.STARTING_MONEY,
                    color: assignedColor,
                    positionIndex: 0,
                    isReady: false,
                    currentGameId: null,
                    id: newUserId // Store the ID within the document as well
                });

                alert(getTranslation('createAccountSuccess')); // Assuming translation key
                // As requested, redirect to login page after successful signup
                showAuthModal('login');
                authUsernameInput.value = username; // Pre-fill username for convenience
                signupUsernameInput.value = '';
                signupPasswordInput.value = '';
                signupConfirmPasswordInput.value = '';
            } catch (error) {
                console.error("Signup error:", error);
                displayAuthError(signupErrorDiv, signupErrorMessageSpan, `Signup failed: ${error.message}`);
            }
        }

        async function handleLogout() {
            if (gameState.currentUser) {
                try {
                    // Update user's online status in Firestore
                    await updateDoc(doc(usersCollectionRef, gameState.currentUser.userId), {
                        isOnline: false,
                        lastActive: Date.now()
                    });
                    // If in a game, remove from game
                    if (gameState.currentGameId) {
                        const gameDocRef = doc(gamesCollectionRef, gameState.currentGameId);
                        const gameSnap = await getDoc(gameDocRef);
                        if (gameSnap.exists()) {
                            const gameData = gameSnap.data();
                            const updatedPlayers = gameData.players.filter(p => p.userId !== gameState.currentUser.userId);
                            await updateDoc(gameDocRef, { players: updatedPlayers });
                        }
                        if (gameState.currentGameListener) {
                            gameState.currentGameListener(); // Unsubscribe from game updates
                            gameState.currentGameListener = null;
                        }
                        gameState.currentGameId = null;
                    }
                } catch (error) {
                    console.error("Error updating online status on logout:", error);
                }
            }
            gameState.currentUser = null;
            gameState.players = []; // Clear game players
            gameState.boardProperties = {};
            gameState.pendingTradeOffers = [];
            gameState.currentActiveTradeOffer = null;
            gameState.leaderId = null;
            resetTurnTimer(); // Stop any game timers
            if (gameState.onlineUsersListener) {
                gameState.onlineUsersListener(); // Stop listening for online users
                gameState.onlineUsersListener = null;
            }

            document.getElementById('gamePage').classList.add('hidden');
            document.getElementById('lobbyPage').classList.add('hidden');
            showAuthModal('login'); // Show login modal again
            updateAllTextContent(); // Update UI for logged out state
            console.log("User logged out.");
        }

        // --- Online Users Listener ---
        function startOnlineUsersListener() {
            if (gameState.onlineUsersListener) {
                gameState.onlineUsersListener(); // Unsubscribe from previous listener if exists
            }
            gameState.onlineUsersListener = onSnapshot(usersCollectionRef, (snapshot) => {
                const onlineUsers = [];
                snapshot.forEach(doc => {
                    const userData = doc.data();
                    // Consider a user online if their isOnline flag is true and lastActive is recent (e.g., last 2 minutes)
                    if (userData.isOnline && (Date.now() - userData.lastActive < 120000)) { // 2 minutes
                        onlineUsers.push({ id: userData.id, userId: doc.id, name: userData.username, color: userData.color });
                    }
                });
                updateOnlinePlayersList(onlineUsers);
            }, (error) => {
                console.error("Error listening to online users:", error);
            });
        }

        function updateOnlinePlayersList(onlineUsers = []) {
            const onlinePlayersListElem = document.getElementById('onlinePlayersList');
            const onlinePlayersTitle = document.getElementById('onlinePlayersTitle');
            onlinePlayersListElem.innerHTML = '';
            onlinePlayersTitle.innerHTML = `${getTranslation('online')} <span class="text-green-400">(${onlineUsers.length})</span>`;

            if (onlineUsers.length === 0) {
                const listItem = document.createElement('li');
                listItem.classList.add('text-gray-400', 'text-sm');
                listItem.textContent = getTranslation('noOnlinePlayers'); // Assuming translation key
                onlinePlayersListElem.appendChild(listItem);
            } else {
                onlineUsers.forEach(user => {
                    const listItem = document.createElement('li');
                    listItem.classList.add('flex', 'justify-between', 'items-center', 'py-1');
                    listItem.innerHTML = `
                        <span><i class="fas fa-circle mr-2" style="color: ${user.color}; font-size: 0.75rem;"></i> ${user.name}</span>
                        <span class="player-status">${getTranslation('online')}</span>
                    `;
                    onlinePlayersListElem.appendChild(listItem);
                });
            }
        }

        // --- Game Management Functions ---
        async function findOrCreateGame() {
            if (!gameState.currentUser) {
                alert(getTranslation('notLoggedIn'));
                return;
            }

            document.getElementById('lobbyPlayButton').disabled = true;
            document.getElementById('lobbyMessage').classList.remove('hidden');

            try {
                // 1. Check for existing 'waiting' games
                const q = query(gamesCollectionRef, where("status", "==", "waiting"));
                const querySnapshot = await getDocs(q);

                let gameDoc;
                let gameData;

                if (!querySnapshot.empty) {
                    // Join an existing waiting game
                    gameDoc = querySnapshot.docs[0];
                    gameData = gameDoc.data();
                    gameState.currentGameId = gameDoc.id;

                    // Check if current user is already in this game
                    const isAlreadyInGame = gameData.players.some(p => p.userId === gameState.currentUser.userId);
                    if (!isAlreadyInGame) {
                        // Add current user to players array in game data
                        const newPlayerInGame = {
                            id: gameData.players.length + 1, // Simple sequential ID for in-game player
                            userId: gameState.currentUser.userId, // Link to actual user document
                            name: gameState.currentUser.name,
                            money: gameState.STARTING_MONEY,
                            positionIndex: 0,
                            color: gameState.currentUser.color,
                            isReady: false
                        };
                        gameData.players.push(newPlayerInGame);
                        // Update Firestore document
                        await updateDoc(doc(gamesCollectionRef, gameState.currentGameId), {
                            players: gameData.players
                        });
                        console.log(`Joined existing game: ${gameState.currentGameId}`);
                    } else {
                        console.log(`Already in game: ${gameState.currentGameId}`);
                    }
                } else {
                    // No waiting games, create a new one
                    const newGameId = crypto.randomUUID();
                    gameState.currentGameId = newGameId;

                    const initialPlayer = {
                        id: 1, // First player in this game instance
                        userId: gameState.currentUser.userId,
                        name: gameState.currentUser.name,
                        money: gameState.STARTING_MONEY,
                        positionIndex: 0,
                        color: gameState.currentUser.color,
                        isReady: false
                    };

                    gameData = {
                        players: [initialPlayer],
                        status: "waiting",
                        leaderId: initialPlayer.id, // The first player in game is the leader
                        hostUserId: gameState.currentUser.userId, // The Firestore userId of the host
                        boardCellsInfo: [], // Will be populated when game starts
                        boardProperties: {},
                        currentPlayerIndex: 0,
                        pendingTradeOffers: [],
                        createdAt: Date.now(),
                        lastActivity: Date.now()
                    };

                    await setDoc(doc(gamesCollectionRef, gameState.currentGameId), gameData);
                    console.log(`Created new game: ${gameState.currentGameId}`);
                }

                // Update current user's gameId in their user document
                await updateDoc(doc(usersCollectionRef, gameState.currentUser.userId), {
                    currentGameId: gameState.currentGameId
                });

                // Start listening to this specific game document
                listenToCurrentGame();

            } catch (error) {
                console.error("Error finding or creating game:", error);
                alert(`Failed to find or create game: ${error.message}`);
                document.getElementById('lobbyPlayButton').disabled = false;
                document.getElementById('lobbyMessage').classList.add('hidden');
            }
        }

        function listenToCurrentGame() {
            if (gameState.currentGameListener) {
                gameState.currentGameListener(); // Unsubscribe from previous listener
            }

            if (!gameState.currentGameId) {
                console.warn("No current game ID to listen to.");
                return;
            }

            gameState.currentGameListener = onSnapshot(doc(gamesCollectionRef, gameState.currentGameId), (docSnap) => {
                if (docSnap.exists()) {
                    const gameData = docSnap.data();
                    console.log("Game state updated from Firestore:", gameData);

                    // Update local gameState with data from Firestore
                    gameState.players = gameData.players || [];
                    gameState.boardProperties = gameData.boardProperties || {};
                    gameState.boardCellsInfo = gameData.boardCellsInfo || [];
                    gameState.currentPlayerIndex = gameData.currentPlayerIndex || 0;
                    gameState.pendingTradeOffers = gameData.pendingTradeOffers || [];
                    gameState.leaderId = gameData.leaderId || (gameState.players.length > 0 ? gameState.players[0].id : null);

                    // Update UI based on the new game state
                    if (gameData.status === 'waiting') {
                        document.getElementById('lobbyPage').classList.remove('hidden');
                        document.getElementById('gamePage').classList.add('hidden');
                        document.getElementById('lobbyMessage').classList.remove('hidden');
                        document.getElementById('lobbyPlayerCount').textContent = `${gameState.players.length}/${MAX_PLAYERS_PER_GAME}`;
                        document.getElementById('lobbyPlayButton').disabled = gameState.players.length < 2; // Enable if 2+ players
                        updateLobbyPlayerCards();
                    } else if (gameData.status === 'in-progress') {
                        document.getElementById('lobbyPage').classList.add('hidden');
                        document.getElementById('gamePage').classList.remove('hidden');
                        document.getElementById('lobbyMessage').classList.add('hidden');
                        populateBoard(); // Re-render board with updated info
                        addPlayerTokens(); // Re-add tokens based on current players
                        updatePlayersList();
                        updateMyPropertiesList();
                        updatePendingTradesList();
                        checkPlayerDebtStatus();
                        // Start timer if it's the current player's turn and not already running
                        const currentPlayerInGame = gameState.players[gameState.currentPlayerIndex];
                        if (currentPlayerInGame && currentPlayerInGame.userId === gameState.currentUser.userId && turnTimer === null) {
                             startTurnTimer();
                        }
                    } else if (gameData.status === 'finished') {
                        alert("Game Over!");
                        handleLogout(); // Log out and return to auth modal
                    }

                } else {
                    console.warn("Current game document no longer exists. Returning to lobby.");
                    alert("The game you were in has ended or been deleted.");
                    handleLogout(); // Log out and return to auth modal
                }
            }, (error) => {
                console.error("Error listening to current game:", error);
                alert(`Error syncing game: ${error.message}`);
                handleLogout(); // Log out on listener error
            });
        }

        async function startGame() {
            if (!gameState.currentUser || !gameState.currentGameId) {
                alert(getTranslation('notLoggedIn'));
                return;
            }

            const gameDocRef = doc(gamesCollectionRef, gameState.currentGameId);
            const gameSnap = await getDoc(gameDocRef);

            if (gameSnap.exists()) {
                const gameData = gameSnap.data();
                // Only the host can start the game
                if (gameData.hostUserId !== gameState.currentUser.userId) {
                    alert("Only the host can start the game.");
                    return;
                }

                if (gameData.players.length < 2) {
                    alert(getTranslation("addAtLeastOnePlayer"));
                    return;
                }

                // Initialize board for the game
                populateBoard(); // This sets gameState.boardCellsInfo
                // Update game document with initial board state and status
                await updateDoc(gameDocRef, {
                    status: "in-progress",
                    boardCellsInfo: gameState.boardCellsInfo,
                    boardProperties: gameState.boardProperties,
                    players: gameData.players // Ensure players array is up-to-date
                });
                console.log(`Game ${gameState.currentGameId} started by host ${gameState.currentUser.name}.`);
            } else {
                alert("Game not found to start.");
                console.error("Game document not found for starting.");
            }
        }


        // DOM Content Loaded event listener
        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOMContentLoaded event fired."); // Debug log
            try {
                const lobbyPage = document.getElementById('lobbyPage');
                const gamePage = document.getElementById('gamePage');
                const lobbyPlayButton = document.getElementById('lobbyPlayButton');
                const toggleOnlinePlayersButton = document.getElementById('toggleOnlinePlayers');
                const onlinePlayersSidebar = document.getElementById('onlinePlayersSidebar');
                const settingsBtn = document.getElementById('settingsBtn');
                const applySettingsBtn = document.getElementById('applySettingsBtn');
                const closeSettingsBtn = document.getElementById('closeSettingsBtn');
                const logoutLobbyBtn = document.getElementById('logoutLobbyBtn');

                // Initial state: show authentication modal
                showAuthModal('login');
                updateAllTextContent(); // Apply initial language to auth modal


                // Auth Modal Event Listeners
                loginAuthBtn.addEventListener('click', handleLogin);
                signupAuthBtn.addEventListener('click', handleSignup);
                showSignupBtn.addEventListener('click', () => showAuthModal('signup'));
                showLoginBtn.addEventListener('click', () => showAuthModal('login'));
                closeAuthModalBtn.addEventListener('click', handleLogout); // Close modal logs out

                // Lobby Page Event Listeners
                if (lobbyPlayButton) {
                    lobbyPlayButton.addEventListener('click', startGame); // Now calls startGame
                    console.log("Lobby Play button event listener attached.");
                } else {
                    console.error("Lobby Play button element not found!");
                }

                if (logoutLobbyBtn) {
                    logoutLobbyBtn.addEventListener('click', handleLogout);
                }

                // Toggle switch functionality for "CLOSED PARTY" on the lobby page
                const toggleCheckbox = document.getElementById('closedPartyToggle');
                if (toggleCheckbox) {
                    toggleCheckbox.addEventListener('change', function() {
                        const toggleDot = this.nextElementSibling.querySelector('.toggle-dot');
                        if (this.checked) {
                            toggleDot.style.left = 'calc(100% - 17px)'; /* Move to right */
                            this.nextElementSibling.style.backgroundColor = '#8a2be2'; /* Purple when active */
                        } else {
                            toggleDot.style.left = '3px'; /* Move to left */
                            this.nextElementSibling.style.backgroundColor = '#6b7280'; /* Gray when inactive */
                        }
                        console.log(`[Lobby Debug] ${Date.now()}: Closed Party toggle changed to: ${this.checked}.`);
                    });
                }

                // Toggle button for Online Players sidebar
                if (toggleOnlinePlayersButton && onlinePlayersSidebar) {
                    onlinePlayersSidebar.classList.add('hidden-content');
                    const icon = toggleOnlinePlayersButton.querySelector('i');
                    icon.classList.remove('fa-eye');
                    icon.classList.add('fa-eye-slash');

                    toggleOnlinePlayersButton.addEventListener('click', () => {
                        onlinePlayersSidebar.classList.toggle('hidden-content');
                        if (onlinePlayersSidebar.classList.contains('hidden-content')) {
                            icon.classList.remove('fa-eye');
                            icon.classList.add('fa-eye-slash');
                            console.log(`[Lobby Debug] ${Date.now()}: Online Players sidebar hidden.`);
                        } else {
                            icon.classList.remove('fa-eye-slash');
                            icon.classList.add('fa-eye');
                            updateOnlinePlayersList(); // Refresh list when shown
                            console.log(`[Lobby Debug] ${Date.now()}: Online Players sidebar shown.`);
                        }
                    });
                }

                // Settings button listeners
                if (settingsBtn) {
                    settingsBtn.addEventListener('click', openSettingsModal);
                }
                if (applySettingsBtn) {
                    applySettingsBtn.addEventListener('click', applySettings);
                }
                if (closeSettingsBtn) {
                    closeSettingsBtn.addEventListener('click', closeSettingsModal);
                }

                // Attach event listener for sending trade offer
                document.getElementById('sendTradeOfferBtn').addEventListener('click', sendTradeOffer);
                document.getElementById('acceptTradeBtn').addEventListener('click', acceptTrade);
                document.getElementById('declineTradeBtn').addEventListener('click', declineTrade);
                document.getElementById('confirmSellPropertiesBtn').addEventListener('click', sellSelectedProperties); // Attach sell properties listener


                // Chat elements are disabled, so no need for listeners
                const chatSendBtn = document.getElementById('chatSendBtn');
                const chatInput = document.getElementById('chatInput');
                if (chatSendBtn) {
                    chatSendBtn.disabled = true;
                }
                if (chatInput) {
                    chatInput.disabled = true;
                }

            } catch (error) {
                console.error("Error during DOMContentLoaded setup:", error); // Catch any errors during setup
            }
        });
    </script>
</body>
</html>
